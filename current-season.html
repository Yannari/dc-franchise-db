<!doctype html>
<html lang="en" data-root=".">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Current Season ‚Äî Season 5</title>
  <link rel="stylesheet" href="styles.css">

  <style>
    .muted{opacity:.78}
    .ai-controls{display:flex;gap:12px;align-items:flex-end;flex-wrap:wrap;margin:14px 0}
    .ai-field{flex:1;min-width:240px}
    .ai-field label{display:block;margin-bottom:6px}
    .ai-field input,.ai-field textarea{
      width:100%;
      border-radius:12px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      color:inherit;
      outline:none;
    }
    .ai-field textarea{resize:vertical}
    .ai-actions{display:flex;gap:10px;flex-wrap:wrap}
    .ai-inline{display:flex;gap:12px;flex-wrap:wrap}
    .ai-list{display:flex;flex-direction:column;gap:12px;margin-top:8px}
    .ai-row{padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.12)}
    .ai-row-top{display:flex;justify-content:space-between;gap:10px;align-items:baseline}
    .ai-row-label{font-weight:700}
    .ai-row-val{opacity:.85;font-variant-numeric:tabular-nums}
    .ai-row-sub{margin-top:6px;opacity:.78;font-size:.92rem}
    .ai-bar{height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:8px}
    .ai-bar span{display:block;height:100%;background:rgba(150,100,255,.85)}
    .ai-tag{display:inline-block;margin-left:8px;font-size:.8rem;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);opacity:.85}
    .ai-line{padding:6px 2px}
  
    /* AI: avatars + cast grid */
    .ai-player{display:flex;align-items:center;gap:10px;min-width:0}
    .ai-avatar{width:28px;height:28px;border-radius:999px;overflow:hidden;flex:0 0 28px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      display:grid;place-items:center}
    .ai-avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .ai-avatar span{font-size:16px;opacity:.9;line-height:1}
    .ai-name{font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ai-out{opacity:.45;filter:grayscale(1)}
    .ai-cast-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(170px,1fr));
      gap:12px;
      margin-top:10px
    }
    .ai-cast-card{
      display:flex;gap:12px;align-items:center;
      padding:12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.12);
      text-decoration:none;color:inherit
    }
    .ai-cast-card:hover{border-color:rgba(255,255,255,.16);background:rgba(0,0,0,.16)}
    .ai-cast-left{display:flex;align-items:center;gap:10px;min-width:0}
    .ai-cast-avatar{width:42px;height:42px;border-radius:999px;overflow:hidden;flex:0 0 42px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      display:grid;place-items:center}
    .ai-cast-avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .ai-cast-avatar span{font-size:20px;opacity:.9}
    .ai-cast-meta{min-width:0}
    .ai-cast-meta .t1{font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ai-cast-meta .t2{opacity:.72;font-size:.9rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  
/* --- AI RE-ARCH (current-season) --- */
.ai-panel{padding:18px;margin:18px 0}
.glass-card{background:rgba(24,16,34,.55);border:1px solid rgba(255,255,255,.08);border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.35);backdrop-filter: blur(10px)}
.section-title{margin:0 0 8px 0;font-size:20px}
.muted{opacity:.75}
.small{font-size:12px}
.ai-head{display:flex;justify-content:space-between;gap:12px;align-items:flex-end;flex-wrap:wrap}
.ai-status{opacity:.85;font-size:13px}
.ai-row{margin-top:12px}
.ai-label{display:block;font-size:12px;letter-spacing:.04em;text-transform:uppercase;opacity:.8;margin-bottom:8px}
.ai-endpoint{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.ai-input{width:100%;min-width:260px;background:rgba(10,8,18,.55);border:1px solid rgba(255,255,255,.10);color:#fff;border-radius:12px;padding:10px 12px;outline:none}
.ai-textarea{width:100%;min-height:170px;background:rgba(10,8,18,.55);border:1px solid rgba(255,255,255,.10);color:#fff;border-radius:12px;padding:12px;outline:none;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;line-height:1.35}
.ai-controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;align-items:flex-end}
.ai-field{flex:1;min-width:160px}
.ai-actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.ai-toggle{display:flex;gap:8px;align-items:center;font-size:13px;opacity:.9;user-select:none}
.ai-toggle input{accent-color: #9b6dff}
.btn{border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
.btn:hover{background:rgba(255,255,255,.10)}
.btn-primary{background:rgba(155,109,255,.22);border-color:rgba(155,109,255,.45)}
.btn-primary:hover{background:rgba(155,109,255,.30)}
.btn-ghost{background:rgba(255,255,255,.06)}

.episode-panel{padding:18px;margin:18px 0}
.episode-hero{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;padding:10px 6px 16px;border-bottom:1px solid rgba(255,255,255,.08);margin-bottom:14px}
.episode-kicker{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75}
.episode-title{font-size:28px;font-weight:800;line-height:1.15;margin-top:4px}
.episode-num{color:rgba(255,255,255,.95)}
.episode-name{color:rgba(155,109,255,.95);margin-left:8px}
.episode-sub{margin-top:8px;opacity:.85}
.subhead{margin:0 0 10px 0}

.players-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:14px}
.player-card{position:relative;display:flex;flex-direction:column;align-items:center;gap:8px;padding:14px;border-radius:16px;text-decoration:none;color:#fff;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.09);transition:transform .12s ease, border-color .12s ease, background .12s ease}
.player-card:hover{transform:translateY(-2px);border-color:rgba(155,109,255,.38);background:rgba(155,109,255,.08)}
.player-card.eliminated{opacity:.38;filter:grayscale(1)}
.pc-avatar{width:64px;height:64px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:flex;align-items:center;justify-content:center;overflow:hidden}
.pc-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.pc-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.75}
.pc-name{font-weight:800;text-align:center}
.pc-title{font-size:12px;opacity:.8;text-align:center;min-height:30px}
.pc-badge{position:absolute;top:10px;right:10px;font-size:10px;letter-spacing:.06em;text-transform:uppercase;background:rgba(255,120,120,.18);border:1px solid rgba(255,120,120,.35);padding:4px 8px;border-radius:999px}
.players-foot{margin-top:10px;opacity:.85;font-size:13px}

.window{padding:18px;margin:18px 0}
.window-head{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
.window-tabs{display:flex;gap:8px;flex-wrap:wrap}
.tab-btn{border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
.tab-btn.active{background:rgba(155,109,255,.22);border-color:rgba(155,109,255,.45)}
.window-body.hidden{display:none}

.cards-grid{display:grid;grid-template-columns:repeat(4, minmax(0,1fr));gap:12px}
.cards-grid.two{grid-template-columns:repeat(4, minmax(0,1fr));margin-top:12px}
@media (max-width: 1100px){
  .cards-grid{grid-template-columns:repeat(2, minmax(0,1fr))}
  .cards-grid.two{grid-template-columns:repeat(2, minmax(0,1fr))}
}
@media (max-width: 620px){
  .cards-grid{grid-template-columns:1fr}
  .cards-grid.two{grid-template-columns:1fr}
}
.mini-panel{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.09);border-radius:16px;padding:14px}
.mini-title{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75;margin-bottom:10px}
.mini-subtitle{font-size:12px;opacity:.75;margin:-4px 0 10px}
.mini-body{font-size:13px;line-height:1.4;opacity:.95}

.rowline{display:flex;gap:10px;align-items:flex-start}
.mini-avatar{width:38px;height:38px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:flex;align-items:center;justify-content:center;overflow:hidden;flex:none}
.mini-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.mini-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.75}
.rowtext{display:flex;flex-direction:column;gap:6px}
.plink{color:#fff;text-decoration:none}
.plink:hover{text-decoration:underline}

.bar-row{padding:10px 10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.14);margin-bottom:10px}
.bar-head{display:flex;justify-content:space-between;gap:10px;align-items:center}
.bar-left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.bar-pct{opacity:.85;font-variant-numeric:tabular-nums}
.bar-track{height:8px;border-radius:999px;background:rgba(255,255,255,.09);margin:8px 0 8px;overflow:hidden}
.bar-fill{height:100%;background:rgba(155,109,255,.75);border-radius:999px}
.bar-note{opacity:.82;font-size:12px;line-height:1.35}

.tiny-avatar{width:22px;height:22px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:inline-flex;align-items:center;justify-content:center;overflow:hidden}
.tiny-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.tiny-fallback{display:inline-flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;font-size:11px;opacity:.75}

.tag{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);opacity:.9}
.tag-up{background:rgba(80,255,170,.12);border-color:rgba(80,255,170,.35)}
.tag-down{background:rgba(255,90,120,.12);border-color:rgba(255,90,120,.35)}
.tag-steady{background:rgba(255,255,255,.08)}

.title-row{display:flex;gap:8px;align-items:center;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,.08)}
.title-row:last-child{border-bottom:none}

.gameplay-grid{display:grid;grid-template-columns:1.2fr .8fr;gap:12px}
@media (max-width: 980px){ .gameplay-grid{grid-template-columns:1fr} }
.compass-wrap{padding:8px}
.compass{position:relative;width:100%;aspect-ratio: 1.6/1;background:rgba(0,0,0,.14);border:1px solid rgba(255,255,255,.10);border-radius:16px;overflow:hidden}
.axis{position:absolute;background:rgba(255,255,255,.10)}
.axis-x{left:0;right:0;top:50%;height:1px}
.axis-y{top:0;bottom:0;left:50%;width:1px}
.axis-label{position:absolute;font-size:11px;opacity:.75}
.axis-label.left{left:10px;top:50%;transform:translateY(-50%)}
.axis-label.right{right:10px;top:50%;transform:translateY(-50%)}
.axis-label.top{top:10px;left:50%;transform:translateX(-50%)}
.axis-label.bottom{bottom:10px;left:50%;transform:translateX(-50%)}
.compass-points{position:absolute;inset:0}
.dot{position:absolute;transform:translate(-50%,-50%);text-decoration:none;color:#fff}
.dot-circle{width:30px;height:30px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid rgba(155,109,255,.40);display:flex;align-items:center;justify-content:center;overflow:hidden}
.dot-circle img{width:100%;height:100%;object-fit:cover;display:none}
.dot-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;font-size:12px;opacity:.8}
.dot-label{display:block;margin-top:4px;font-size:10px;opacity:.85;text-shadow:0 2px 10px rgba(0,0,0,.6);max-width:90px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.table-wrap{overflow:auto;border-radius:16px;border:1px solid rgba(255,255,255,.10)}
.gp-table{width:100%;border-collapse:collapse}
.gp-table th,.gp-table td{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);font-size:13px;text-align:left}
.gp-table th{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75;background:rgba(255,255,255,.04);position:sticky;top:0}
.row-player{display:inline-flex;gap:8px;align-items:center}
</style>

</head>
<body>
<!-- SITE HEADER START -->
<header class="modern-header" id="modernHeader">
  <div class="header-container">
    <!-- Top Bar -->
    <div class="header-top">
      <a href="index.html" class="brand-section" aria-label="Go to home">
        <div class="brand-icon">
          <span class="brand-logo-text">‚ö°</span>
        </div>
        <div class="brand-content">
          <h1>DC <span class="brand-gradient">Franchise</span> Database</h1>
          <p class="brand-subtitle">Season <span id="currentSeasonNum">5</span> Live ‚Ä¢ Click to Explore</p>
        </div>
      </a>

      <div class="stats-badge">
        <div class="stats-main"><span id="totalSeasons">5</span> Seasons ‚Ä¢ <span id="totalPlayers">58</span> Players</div>
        <div class="stats-sub">Icons: <span id="iconFormat">name.png</span></div>
      </div>
    </div>

    <!-- Navigation -->
    <nav class="header-nav" aria-label="Primary navigation">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="index.html" class="nav-link" data-page="index">
            <span class="nav-icon">üè†</span>
            <span>Home</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="current-season.html" class="nav-link" data-page="current-season">
            <span class="nav-icon">üìä</span>
            <span>Current Season</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="voting-analytics.html" class="nav-link" data-page="voting-analytics">
            <span class="nav-icon">üßæ</span>
            <span>Voting Analytics</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="franchise.html" class="nav-link" data-page="franchise">
            <span class="nav-icon">üèõÔ∏è</span>
            <span>Franchise</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="rankings.html" class="nav-link" data-page="rankings">
            <span class="nav-icon">üèÜ</span>
            <span>Rankings</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="seasons.html" class="nav-link" data-page="seasons">
            <span class="nav-icon">üóÇÔ∏è</span>
            <span>Seasons</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="devotees.html" class="nav-link" data-page="devotees">
            <span class="nav-icon">üë•</span>
            <span>Players</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="awards.html" class="nav-link" data-page="awards">
            <span class="nav-icon">üèÖ</span>
            <span>Awards</span>
          </a>
        </li>
      </ul>
    </nav>
  </div>
</header>

<script>
(function() {
  // Load site config and update header stats
  if (window.SITE_CONFIG) {
    document.getElementById('totalSeasons').textContent = window.SITE_CONFIG.seasons;
    document.getElementById('totalPlayers').textContent = window.SITE_CONFIG.players;
    document.getElementById('currentSeasonNum').textContent = window.SITE_CONFIG.currentSeason;
    document.getElementById('iconFormat').textContent = window.SITE_CONFIG.iconFormat;
  }

  // Scroll behavior
  const header = document.getElementById('modernHeader');
  if (!header) return;
  
  window.addEventListener('scroll', () => {
    const currentScroll = window.pageYOffset;
    if (currentScroll > 20) {
      header.classList.add('scrolled');
    } else {
      header.classList.remove('scrolled');
    }
  }, { passive: true });

  // Active page highlighting
  const currentPage = window.location.pathname.split('/').pop() || 'index.html';
  const navLinks = document.querySelectorAll('.nav-link');
  
  navLinks.forEach(link => {
    const linkPage = link.getAttribute('href');
    if (linkPage === currentPage || (currentPage === '' && linkPage === 'index.html')) {
      link.classList.add('active');
    }
  });

  // Path resolution for nested folders
  const root = (document.documentElement.dataset.root || document.body.dataset.root || ".").replace(/\/+$/, "");
  
  if (root !== ".") {
    const allLinks = header.querySelectorAll('a[href]');
    allLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (href && !href.startsWith('http') && !href.startsWith('#')) {
        link.setAttribute('href', root + '/' + href);
      }
    });
  }
})();
</script>
<!-- SITE HEADER END -->

  <div class="container">
  <!-- 1) TOTAL DRAMA ANALYTICS (AI) -->
  <section class="ai-panel glass-card" id="aiPanel">
    <div class="ai-head">
      <h2 class="section-title">üìà Total Drama Analytics <span class="muted">(AI)</span></h2>
      <div class="ai-status" id="aiStatus">Paste your episode summary and generate analytics.</div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="aiWorkerUrl">AI Endpoint (Cloudflare Worker URL)</label>
      <div class="ai-endpoint">
        <input id="aiWorkerUrl" class="ai-input" placeholder="https://dc-analytics.yoursubdomain.workers.dev" />
        <button class="btn btn-ghost" id="aiSaveUrl">Save URL</button>
      </div>
    </div>

    <div class="ai-controls">
      <div class="ai-field">
        <label class="ai-label" for="aiSeason">Season</label>
        <input id="aiSeason" class="ai-input" type="number" min="1" value="5" />
      </div>
      <div class="ai-field">
        <label class="ai-label" for="aiEpisode">Episode</label>
        <input id="aiEpisode" class="ai-input" type="number" min="1" value="1" />
      </div>

      <div class="ai-actions">
        <button class="btn btn-primary" id="aiGenerate">Generate Analytics</button>
        <button class="btn btn-ghost" id="aiLoadCached">Load Cached</button>
        <label class="ai-toggle">
          <input type="checkbox" id="aiAutoLoad" checked />
          <span>Auto-load on refresh</span>
        </label>
      </div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="aiSummary">Episode Summary Input</label>
      <textarea id="aiSummary" class="ai-textarea" spellcheck="false" placeholder="Paste your episode write-up here (like your Episode 1 summary)..."></textarea>
    </div>
  </section>

  <!-- 2) EPISODE HEADER + CURRENT PLAYERS (BIG) -->
  <section class="episode-panel glass-card" id="episodePanel">
    <div class="episode-hero">
      <div>
        <div class="episode-kicker">TOTAL DRAMA ‚Ä¢ Current Episode</div>
        <div class="episode-title">
          <span class="episode-num" id="uiEpisodeNum">Episode 1</span>
          <span class="episode-name" id="uiEpisodeName">‚Äî</span>
        </div>
        <div class="episode-sub">
          <span id="uiPlayersRemaining">‚Äî</span> remaining ‚Ä¢ Click any player to open their profile
        </div>
      </div>

      <div class="episode-hero-actions">
        <button class="btn btn-ghost" id="btnSyncFromSummary">Sync title/players from summary</button>
      </div>
    </div>

    <h3 class="subhead">Current Players</h3>
    <div class="players-grid" id="currentPlayersGrid"></div>
    <div class="players-foot">
      <span class="muted">Tip:</span> eliminated players are greyed out automatically if your summary includes an <b>ELIMINATED</b> block.
    </div>
  </section>

  <!-- 3) SWITCHABLE ANALYTICS WINDOW -->
  <section class="window glass-card" id="analyticsWindow">
    <div class="window-head">
      <h2 class="section-title">üìä Cullhouse Analytics</h2>
      <div class="window-tabs" role="tablist" aria-label="Analytics tabs">
        <button class="tab-btn active" id="tabOverview" role="tab" aria-selected="true">üìò Overview</button>
        <button class="tab-btn" id="tabGameplay" role="tab" aria-selected="false">üß≠ Gameplay</button>
      </div>
    </div>

    <!-- OVERVIEW PAGE -->
    <div class="window-body" id="viewOverview">
      <div class="cards-grid">
        <div class="mini-panel">
          <div class="mini-title">BEST MOVE</div>
          <div class="mini-body" id="cardBestMove">‚Äî</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">BIGGEST RISK</div>
          <div class="mini-body" id="cardBiggestRisk">‚Äî</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">EPISODE SUMMARY</div>
          <div class="mini-body" id="cardEpisodeSummary">‚Äî</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">ALLIANCE OVERVIEW</div>
          <div class="mini-body" id="cardAllianceOverview">‚Äî</div>
        </div>
      </div>

      <div class="cards-grid two">
        <div class="mini-panel">
          <div class="mini-title">BOOT ODDS (NEXT)</div>
          <div class="mini-body" id="cardBootOdds">No boot predictions yet.</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">POWER RANKINGS</div>
          <div class="mini-body" id="cardPowerRankings">No power rankings yet.</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">ALLIANCE STABILITY</div>
          <div class="mini-body" id="cardAllianceStability">No alliance stability yet.</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">TITLES</div>
          <div class="mini-body" id="cardTitles">No titles yet.</div>
        </div>
      </div>
    </div>

    <!-- GAMEPLAY PAGE -->
    <div class="window-body hidden" id="viewGameplay">
      <div class="gameplay-grid">
        <div class="mini-panel gameplay-panel">
          <div class="mini-title">GAMEPLAY COMPASS</div>
          <div class="mini-subtitle">AI-derived placement from your overview stats (Power vs Safety)</div>
          <div class="compass-wrap">
            <div class="compass" id="compass">
              <div class="axis axis-x"></div>
              <div class="axis axis-y"></div>
              <div class="axis-label left">Low Power</div>
              <div class="axis-label right">High Power</div>
              <div class="axis-label top">Safe</div>
              <div class="axis-label bottom">At Risk</div>
              <div class="compass-points" id="compassPoints"></div>
            </div>
          </div>
          <div class="muted small">If you want true ‚ÄúSocial vs Competition‚Äù, I can upgrade your Worker to output compass coordinates directly.</div>
        </div>

        <div class="mini-panel gameplay-panel">
          <div class="mini-title">INDIVIDUAL GAMEPLAY ANALYSIS</div>
          <div class="mini-subtitle">Auto-built from AI output (tag + score + risk)</div>

          <div class="table-wrap">
            <table class="gp-table">
              <thead>
                <tr>
                  <th>Player</th>
                  <th>Title</th>
                  <th>Trend</th>
                  <th>Power</th>
                  <th>Boot Risk</th>
                  <th>Role</th>
                </tr>
              </thead>
              <tbody id="gpTableBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- SCRIPT: AI + RENDERING -->
  <script>

  (function() {
    const $ = (id) => document.getElementById(id);

    const els = {
      workerUrl: $("aiWorkerUrl"),
      saveUrl: $("aiSaveUrl"),
      season: $("aiSeason"),
      episode: $("aiEpisode"),
      generate: $("aiGenerate"),
      loadCached: $("aiLoadCached"),
      autoLoad: $("aiAutoLoad"),
      summary: $("aiSummary"),
      status: $("aiStatus"),

      uiEpNum: $("uiEpisodeNum"),
      uiEpName: $("uiEpisodeName"),
      uiRemain: $("uiPlayersRemaining"),
      syncFromSummary: $("btnSyncFromSummary"),
      playersGrid: $("currentPlayersGrid"),

      tabOverview: $("tabOverview"),
      tabGameplay: $("tabGameplay"),
      viewOverview: $("viewOverview"),
      viewGameplay: $("viewGameplay"),

      cardBestMove: $("cardBestMove"),
      cardBiggestRisk: $("cardBiggestRisk"),
      cardEpisodeSummary: $("cardEpisodeSummary"),
      cardAllianceOverview: $("cardAllianceOverview"),
      cardBootOdds: $("cardBootOdds"),
      cardPowerRankings: $("cardPowerRankings"),
      cardAllianceStability: $("cardAllianceStability"),
      cardTitles: $("cardTitles"),

      compassPoints: $("compassPoints"),
      gpTableBody: $("gpTableBody"),
    };

    // ----------------------------
    // Helpers
    // ----------------------------
    function normalizeWorkerUrl(raw) {
      let url = (raw || "").trim();
      if (!url) return "";
      if (!/^https?:\/\//i.test(url)) url = "https://" + url;
      return url.replace(/\/+$/, "");
    }

    function slugify(name) {
      return (name || "")
        .toLowerCase()
        .trim()
        .replace(/['".]/g, "")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");
    }

    function escapeHtml(s) {
      return String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function setStatus(msg) {
      if (els.status) els.status.textContent = msg;
    }

    function cacheKey(season, episode) {
      return `AI_ANALYTICS_s${season}_e${episode}`;
    }

    function saveLastSelection(season, episode) {
      localStorage.setItem("AI_LAST_SELECTION", JSON.stringify({ season, episode }));
    }

    function loadLastSelection() {
      try { return JSON.parse(localStorage.getItem("AI_LAST_SELECTION") || "null"); } catch { return null; }
    }

    // Extract cast list from summary (best effort)
        function parseBlock(text, headerRegex) {
      const lines = (text || "").split(/\r?\n/);
      let start = -1;
      for (let i = 0; i < lines.length; i++) {
        if (headerRegex.test(lines[i].trim())) { start = i; break; }
      }
      if (start === -1) return [];
      const out = [];
      for (let i = start + 1; i < lines.length; i++) {
        const raw = lines[i];
        const l = (raw || "").trim();
        if (!l) continue;
        if (/^===\s*/.test(l)) break;
        // stop if next major section starts (fallback)
        if (/^(PRE-CHALLENGE|CHALLENGES|POST-CHALLENGE|TRIBAL|VOTING|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
        out.push(l);
      }
      return out;
    }

    function cleanNameLine(l) {
      let s = (l || "").trim();
      if (!s) return "";
      s = s.replace(/^[-‚Ä¢]\s*/, "");
      // strip numbering like "18. Leonard" or "18th Leonard"
      s = s.replace(/^\d+\s*(?:[.)]|(?:st|nd|rd|th)\b)\s*/i, "");
      // strip "Name:18th" or "Name - 18th"
      s = s.replace(/:\s*\d+(?:st|nd|rd|th)\b.*$/i, "").trim();
      s = s.replace(/[‚Äî‚Äì].*$/, "").trim();
      return s;
    }

    function isProbablyName(s) {
      return /^[A-Za-z][A-Za-z0-9' -]*$/.test(s) && s.length <= 30;
    }

    function parseCastFromSummary(text) {
      const lines = (text || "").split(/\r?\n/).map(l => l.trim());
      let names = [];

      // META block: === CAST (ALL) ===
      const castBlock = parseBlock(text, /^===\s*CAST\b/i);
      if (castBlock.length) {
        castBlock.forEach(l => {
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        });
      }

      // TRIBES block: === TRIBES (ACTIVE) === with # Tribe headings
      const tribesBlock = parseBlock(text, /^===\s*TRIBES\b/i);
      if (tribesBlock.length) {
        tribesBlock.forEach(l => {
          if (/^#\s*/.test(l)) return; // header
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        });
      }

      // Pattern 1: after "The Cast arrives"
      const idx = lines.findIndex(l => /the\s+cast\s+arrives/i.test(l));
      if (idx !== -1) {
        for (let i = idx + 1; i < lines.length; i++) {
          const l = lines[i];
          if (!l) break;
          if (/^(PRE-CHALLENGE|CHALLENGES|POST-CHALLENGE|VOTING|TRIBAL|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        }
      }

      // Pattern 2: Active Players lines like "Belo Tribe (6): Amy, Rodney..."
      const tribeLines = lines.filter(l => /tribe\s*\(\d+\)\s*:/i.test(l));
      for (const tl of tribeLines) {
        const after = tl.split(":")[1] || "";
        after.split(",").map(x => x.trim()).filter(Boolean).forEach(n => {
          const cn = cleanNameLine(n);
          if (isProbablyName(cn)) names.push(cn);
        });
      }

      // De-dup while preserving order
      const seen = new Set();
      names = names
        .map(n => n.trim())
        .filter(Boolean)
        .filter(n => {
          const k = n.toLowerCase();
          if (seen.has(k)) return false;
          seen.add(k);
          return true;
        });

      return names;
    }

    function parseEpisodeTitle(text) {
      // Episode 2: "Shadows of Doubt"
      const m = (text || "").match(/Episode\s+(\d+)\s*[:\-]\s*["‚Äú]?([^"\n‚Äù]+)["‚Äù]?/i);
      if (m) return { num: parseInt(m[1], 10), title: m[2].trim() };
      // EPISODE 1 SUMMARY (no title)
      const m2 = (text || "").match(/EPISODE\s+(\d+)/i);
      if (m2) return { num: parseInt(m2[1], 10), title: "" };
      return null;
    }

        function parseEliminated(text) {
      const rawLines = (text || "").split(/\r?\n/);
      const lines = rawLines.map(l => (l || "").trim());

      const out = [];
      const pushName = (l) => {
        const n = cleanNameLine(l);
        if (isProbablyName(n)) out.push(n);
      };

      // META block: === ELIMINATED ===
      const elimBlock = parseBlock(text, /^===\s*ELIMINATED\b/i);
      if (elimBlock.length) {
        elimBlock.forEach(pushName);
      }

      // Traditional "ELIMINATED" section(s)
      for (let i = 0; i < lines.length; i++) {
        if (!/^ELIMINATED\b/i.test(lines[i])) continue;
        for (let j = i + 1; j < lines.length; j++) {
          const l = lines[j];
          if (!l) break;
          if (/^===\s*/.test(l)) break;
          if (/^(Vote count|Reason|Edge of Extinction|Not applicable|TRIBAL|MAJOR STRATEGIC|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
          pushName(l);
        }
      }

      // Footer style: "Eliminated:" list
      for (let i = 0; i < lines.length; i++) {
        if (!/^Eliminated\s*:/i.test(lines[i])) continue;
        for (let j = i + 1; j < lines.length; j++) {
          const l = lines[j];
          if (!l) break;
          if (/^===\s*/.test(l)) break;
          if (/^(NEXT EPISODE QUESTIONS|CURRENT GAME STATUS|TRIBAL|MAJOR STRATEGIC)\b/i.test(l)) break;
          pushName(l);
        }
      }

      // De-dup
      const seen = new Set();
      return out.filter(n => {
        const k = n.toLowerCase();
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      });
    }

    function getProbForPlayer(bootPredictions, player) {
      if (!Array.isArray(bootPredictions)) return 0;
      const found = bootPredictions.find(x => (x?.player || "").toLowerCase() === (player || "").toLowerCase());
      return found ? Number(found.prob) || 0 : 0;
    }

    // ----------------------------
    // Rendering: Current Players grid
    // ----------------------------
    function renderPlayersGrid(castNames, eliminatedNames, titlesMap) {
      const eliminated = new Set((eliminatedNames || []).map(n => n.toLowerCase()));
      const cast = (castNames || []).slice(0, 60);

      if (!cast.length) {
        els.playersGrid.innerHTML = `<div class="muted">No cast detected yet. Click ‚ÄúSync title/players from summary‚Äù.</div>`;
        els.uiRemain.textContent = "‚Äî";
        return;
      }

      const remainingCount = cast.filter(n => !eliminated.has(n.toLowerCase())).length;
      els.uiRemain.textContent = `${remainingCount} players`;

      els.playersGrid.innerHTML = cast.map((name) => {
        const id = slugify(name);
        const isOut = eliminated.has(name.toLowerCase());
        const title = titlesMap?.[name.toLowerCase()] || "";
        const subtitle = title ? escapeHtml(title) : "‚Äî";
        const classes = "player-card" + (isOut ? " eliminated" : "");
        return `
          <a class="${classes}" href="player.html?player=${id}" data-player="${id}">
            <div class="pc-avatar">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
              <span class="pc-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
            </div>
            <div class="pc-name">${escapeHtml(name)}</div>
            <div class="pc-title">${subtitle}</div>
            ${isOut ? `<div class="pc-badge">ELIMINATED</div>` : ``}
          </a>
        `;
      }).join("");
    }

    // ----------------------------
    // Rendering: Overview cards
    // ----------------------------
    function renderMoveCard(targetEl, moveObj) {
      if (!moveObj || !moveObj.player) { targetEl.textContent = "‚Äî"; return; }
      const id = slugify(moveObj.player);
      targetEl.innerHTML = `
        <div class="rowline">
          <div class="mini-avatar">
            <img src="assets/avatars/${id}.png" alt="${escapeHtml(moveObj.player)}"
              onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
              onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
            <span class="mini-fallback">${escapeHtml((moveObj.player||'?').slice(0,1).toUpperCase())}</span>
          </div>
          <div class="rowtext">
            <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(moveObj.player)}</b></a>
            <div class="muted">${escapeHtml(moveObj.reason || "")}</div>
          </div>
        </div>
      `;
    }

    function renderBootOdds(targetEl, bootPredictions) {
      if (!Array.isArray(bootPredictions) || bootPredictions.length === 0) {
        targetEl.textContent = "No boot predictions returned.";
        return;
      }
      targetEl.innerHTML = bootPredictions
        .slice(0, 6)
        .map((p) => {
          const name = p.player || "";
          const id = slugify(name);
          const pct = Math.round((Number(p.prob) || 0) * 100);
          return `
            <div class="bar-row">
              <div class="bar-head">
                <div class="bar-left">
                  <span class="tiny-avatar">
                    <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                      onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                    <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                  </span>
                  <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                </div>
                <div class="bar-pct">${pct}%</div>
              </div>
              <div class="bar-track"><div class="bar-fill" style="width:${pct}%"></div></div>
              <div class="bar-note">${escapeHtml(p.why || "")}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderPowerRankings(targetEl, powerRankings) {
      if (!Array.isArray(powerRankings) || powerRankings.length === 0) {
        targetEl.textContent = "No power rankings returned.";
        return;
      }
      targetEl.innerHTML = powerRankings
        .slice(0, 10)
        .map((r) => {
          const name = r.player || "";
          const id = slugify(name);
          const score = Math.round(Number(r.score) || 0);
          const tag = (r.tag || "Steady").toLowerCase();
          const tagClass = tag === "rising" ? "tag tag-up" : tag === "falling" ? "tag tag-down" : "tag tag-steady";
          return `
            <div class="bar-row">
              <div class="bar-head">
                <div class="bar-left">
                  <span class="tiny-avatar">
                    <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                      onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                    <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                  </span>
                  <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                  <span class="${tagClass}">${escapeHtml(r.tag || "Steady")}</span>
                </div>
                <div class="bar-pct">${score}/100</div>
              </div>
              <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
              <div class="bar-note">${escapeHtml(r.blurb || "")}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderAllianceStability(targetEl, allianceStability) {
      if (!Array.isArray(allianceStability) || allianceStability.length === 0) {
        targetEl.textContent = "No alliances detected (or none provided).";
        return;
      }
      targetEl.innerHTML = allianceStability.map((a) => {
        const score = Math.max(0, Math.min(100, Math.round(Number(a.score) || 0)));
        return `
          <div class="bar-row">
            <div class="bar-head">
              <div class="bar-left"><b>${escapeHtml(a.name || "Alliance")}</b></div>
              <div class="bar-pct">${score}/100</div>
            </div>
            <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
            <div class="bar-note">${escapeHtml(a.note || "")}</div>
          </div>
        `;
      }).join("");
    }

    function renderTitles(targetEl, titles) {
      if (!Array.isArray(titles) || titles.length === 0) {
        targetEl.textContent = "No titles returned.";
        return;
      }
      targetEl.innerHTML = titles.slice(0, 40).map((t) => {
        const name = t.player || "";
        const id = slugify(name);
        return `
          <div class="title-row">
            <span class="tiny-avatar">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
              <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
            </span>
            <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
            <span class="muted">‚Äî</span>
            <span>${escapeHtml(t.title || "")}</span>
          </div>
        `;
      }).join("");
    }

    function renderAllianceOverview(targetEl, analytics, summaryText) {
      // Lightweight: show top alliance stability + any named alliances in summary (best effort)
      const st = Array.isArray(analytics?.allianceStability) ? analytics.allianceStability : [];
      const top = st.slice(0, 2).map(a => `${a.name} (${Math.round(Number(a.score)||0)}/100)`).join(", ");
      const has = top ? `<b>Detected:</b> ${escapeHtml(top)}<br/>` : "";

      // Try to detect any explicit "Alliance Status" block names
      const m = (summaryText||"").match(/Alliance Status[\s\S]*?(CHALLENGES|POST-CHALLENGE|VOTING|TRIBAL)/i);
      const snippet = m ? m[0].split("\n").slice(0, 18).join("\n") : "";
      const lines = snippet.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const allianceNames = lines
        .filter(l => /^[A-Za-z0-9][A-Za-z0-9_-]{2,}\s*\(/.test(l))
        .map(l => l.split("(")[0].trim())
        .slice(0, 4);

      const extra = allianceNames.length ? `<div class="muted small">From summary: ${escapeHtml(allianceNames.join(", "))}</div>` : `<div class="muted small">No named alliances found yet.</div>`;
      targetEl.innerHTML = has + extra;
    }

    // ----------------------------
    // Rendering: Gameplay page
    // ----------------------------
    function renderCompass(analytics, castNames, eliminatedNames) {
      const eliminated = new Set((eliminatedNames||[]).map(n=>n.toLowerCase()));

      // Build a map of power scores
      const pr = Array.isArray(analytics?.powerRankings) ? analytics.powerRankings : [];
      const bm = new Map(pr.map(x => [(x.player||"").toLowerCase(), Math.max(0, Math.min(100, Number(x.score)||0))]));

      const bp = Array.isArray(analytics?.bootPredictions) ? analytics.bootPredictions : [];
      const probMap = new Map(bp.map(x => [(x.player||"").toLowerCase(), Math.max(0, Math.min(1, Number(x.prob)||0))]));

      const active = (castNames||[]).filter(n => !eliminated.has(n.toLowerCase()));
      const points = active.slice(0, 30).map((name) => {
        const key = name.toLowerCase();
        const power = bm.get(key) ?? 50;
        const prob = probMap.get(key) ?? 0.15;
        // x: power (0..100)
        // y: safety = 100 - prob*100
        const x = power;
        const y = 100 - prob*100;
        return { name, x, y };
      });

      els.compassPoints.innerHTML = points.map((p) => {
        const id = slugify(p.name);
        // convert x,y (0..100) to %
        const left = Math.max(3, Math.min(97, p.x));
        const top = Math.max(3, Math.min(97, 100 - p.y)); // invert for CSS top
        return `
          <a class="dot" href="player.html?player=${id}" style="left:${left}%;top:${top}%;">
            <span class="dot-circle">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(p.name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
              <span class="dot-fallback">${escapeHtml((p.name||'?').slice(0,1).toUpperCase())}</span>
            </span>
            <span class="dot-label">${escapeHtml(p.name)}</span>
          </a>
        `;
      }).join("");
    }

    function renderGameplayTable(analytics, castNames, eliminatedNames, titlesMap) {
      const eliminated = new Set((eliminatedNames||[]).map(n=>n.toLowerCase()));
      const pr = Array.isArray(analytics?.powerRankings) ? analytics.powerRankings : [];
      const bp = Array.isArray(analytics?.bootPredictions) ? analytics.bootPredictions : [];

      const powerMap = new Map(pr.map(x => [(x.player||"").toLowerCase(), x]));
      const probMap = new Map(bp.map(x => [(x.player||"").toLowerCase(), x]));

      const active = (castNames||[]).filter(n => !eliminated.has(n.toLowerCase()));
      const rows = active.map((name) => {
        const key = name.toLowerCase();
        const r = powerMap.get(key) || { player: name, score: 50, tag: "Steady", blurb: "" };
        const p = probMap.get(key) || { prob: 0.15, why: "" };
        const score = Math.round(Number(r.score)||0);
        const prob = Math.round((Number(p.prob)||0)*100);
        const title = titlesMap?.[key] || "";
        const role =
          prob >= 35 ? "In Danger" :
          score >= 80 ? "Power Player" :
          score >= 65 ? "Well-Positioned" :
          "Under the Radar";
        return { name, score, prob, tag: r.tag || "Steady", title, role };
      }).sort((a,b)=>b.score-a.score);

      els.gpTableBody.innerHTML = rows.map((row) => {
        const id = slugify(row.name);
        const tag = (row.tag||"Steady").toLowerCase();
        const tagClass = tag==="rising" ? "tag tag-up" : tag==="falling" ? "tag tag-down" : "tag tag-steady";
        return `
          <tr>
            <td>
              <a class="plink row-player" href="player.html?player=${id}">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(row.name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((row.name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <b>${escapeHtml(row.name)}</b>
              </a>
            </td>
            <td class="muted">${escapeHtml(row.title || "‚Äî")}</td>
            <td><span class="${tagClass}">${escapeHtml(row.tag)}</span></td>
            <td>${row.score}</td>
            <td>${row.prob}%</td>
            <td>${escapeHtml(row.role)}</td>
          </tr>
        `;
      }).join("");
    }

    // ----------------------------
    // Main render from analytics
    // ----------------------------
    function renderAll(analytics, summaryText) {
      if (!analytics || typeof analytics !== "object") return;

      // Titles map for quick lookups
      const titlesArr = Array.isArray(analytics.titles) ? analytics.titles : [];
      const titlesMap = {};
      for (const t of titlesArr) {
        if (t?.player) titlesMap[t.player.toLowerCase()] = t.title || "";
      }

      CURRENT.titlesMap = titlesMap;

      // Detect cast + eliminated from current summary input (best effort)
      const txt = (summaryText || els.summary.value || "").trim();

      // Prefer parsing from summary; fall back to saved cast state if summary isn't present.
      let cast = parseCastFromSummary(txt);
      let eliminated = parseEliminated(txt);

      const seasonNow = Number(els.season.value || 1);
      const episodeNow = Number(els.episode.value || 1);

      if ((!cast || cast.length === 0) || (eliminated && eliminated.size === 0 && !txt)) {
        const saved = loadCastState(seasonNow, episodeNow);
        if (saved) {
          if (!cast || cast.length === 0) cast = Array.isArray(saved.cast) ? saved.cast : [];
          if ((!eliminated || eliminated.size === 0) && Array.isArray(saved.eliminated)) {
            eliminated = new Set(saved.eliminated.map(s => String(s).toLowerCase()));
          }
          if (!txt && saved.title && els.uiEpName) {
            els.uiEpName.textContent = saved.title;
          }
        }
      }

      // Save for later use (tab switches, etc.)
      CURRENT.analytics = analytics;
      CURRENT.season = seasonNow;
      CURRENT.episode = episodeNow;
      CURRENT.summaryText = txt;
      CURRENT.cast = cast || [];
      CURRENT.eliminated = eliminated || new Set();

      renderPlayersGrid(cast, eliminated, titlesMap);

      // Overview cards
      renderMoveCard(els.cardBestMove, analytics.bestMove);
      renderMoveCard(els.cardBiggestRisk, analytics.biggestRisk);
      els.cardEpisodeSummary.textContent = analytics.narrativeSummary || "‚Äî";
      renderAllianceOverview(els.cardAllianceOverview, analytics, txt);
      renderBootOdds(els.cardBootOdds, analytics.bootPredictions);
      renderPowerRankings(els.cardPowerRankings, analytics.powerRankings);
      renderAllianceStability(els.cardAllianceStability, analytics.allianceStability);
      renderTitles(els.cardTitles, analytics.titles);

      // Gameplay
      renderCompass(analytics, cast, eliminated, titlesMap);
      renderGameplayTable(analytics, cast, eliminated, titlesMap);
    }

    // ----------------------------
    // Tabs
    // ----------------------------
    function showTab(which) {
      const isOverview = which === "overview";
      els.viewOverview.classList.toggle("hidden", !isOverview);
      els.viewGameplay.classList.toggle("hidden", isOverview);

      els.tabOverview.classList.toggle("active", isOverview);
      els.tabGameplay.classList.toggle("active", !isOverview);
      els.tabOverview.setAttribute("aria-selected", isOverview ? "true" : "false");
      els.tabGameplay.setAttribute("aria-selected", !isOverview ? "true" : "false");

      // Persist tab choice per episode
      const s = Number(els.season.value || 1);
      const e = Number(els.episode.value || 1);
      try { localStorage.setItem(tabKey(s, e), which); } catch {}

      // If switching to gameplay, ensure it's rendered (in case cast was synced later)
      if (!isOverview && CURRENT.analytics) {
        const cast = (CURRENT.cast && CURRENT.cast.length) ? CURRENT.cast : parseCastFromSummary(CURRENT.summaryText || "");
        const eliminated = (CURRENT.eliminated && CURRENT.eliminated.size) ? CURRENT.eliminated : parseEliminated(CURRENT.summaryText || "");
        renderCompass(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
        renderGameplayTable(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
      }
    }

    els.tabOverview.addEventListener("click", () => showTab("overview"));
    els.tabGameplay.addEventListener("click", () => showTab("gameplay"));

    // ----------------------------
    // Actions
    // ----------------------------
    els.saveUrl.addEventListener("click", () => {
      const url = normalizeWorkerUrl(els.workerUrl.value);
      if (!url) return setStatus("Enter a Worker URL first.");
      els.workerUrl.value = url;
      localStorage.setItem("AI_ENDPOINT_URL", url);
      setStatus("Saved AI endpoint.");
    });

    els.syncFromSummary.addEventListener("click", () => {
      const txt = els.summary.value || "";
      const s = Number(els.season.value || 1);

      const ep = parseEpisodeTitle(txt);
      if (ep?.num) els.episode.value = ep.num;

      const e = Number(els.episode.value || 1);
      if (ep?.title) els.uiEpName.textContent = `‚Äú${ep.title}‚Äù`;
      els.uiEpNum.textContent = `Episode ${e}`;

      // Persist summary + cast for reloads
      saveSummary(s, e, txt);

      const cast = parseCastFromSummary(txt);
      const eliminated = parseEliminated(txt);

      // Save cast state even if empty (lets us show ‚Äúno cast detected‚Äù consistently)
      saveCastState(s, e, cast, eliminated, ep?.title ? `‚Äú${ep.title}‚Äù` : els.uiEpName.textContent);

      // Update runtime state
      CURRENT.season = s;
      CURRENT.episode = e;
      CURRENT.summaryText = (txt || "").trim();
      CURRENT.cast = cast;
      CURRENT.eliminated = eliminated;

      renderPlayersGrid(cast, eliminated, {});
      // If AI already loaded, refresh gameplay view too
      if (CURRENT.analytics) {
        renderCompass(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
        renderGameplayTable(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
      }

      setStatus("Synced from summary (saved for reload).");
    });

    async function callAI(season, episode, summaryText) {
      const url = normalizeWorkerUrl(els.workerUrl.value || localStorage.getItem("AI_ENDPOINT_URL") || "");
      if (!url) throw new Error("Missing AI endpoint URL.");
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ season, episode, summaryText }),
      });
      const data = await res.json();
      if (!res.ok) {
        // Try to surface OpenAI error nicely
        const msg = data?.error?.message || data?.message || "Unknown error.";
        throw new Error(msg);
      }
      return data;
    }

    function loadCached(season, episode) {
      const key = cacheKey(season, episode);
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function summaryKey(season, episode) {
      return `AI_SUMMARY_s${season}_e${episode}`;
    }
    function castStateKey(season, episode) {
      return `AI_CAST_s${season}_e${episode}`;
    }
    function tabKey(season, episode) {
      return `AI_TAB_s${season}_e${episode}`;
    }

    function saveSummary(season, episode, text) {
      try { localStorage.setItem(summaryKey(season, episode), text || ""); } catch {}
    }
    function loadSummary(season, episode) {
      try { return localStorage.getItem(summaryKey(season, episode)) || ""; } catch { return ""; }
    }

    function saveCastState(season, episode, cast, eliminated, epTitle) {
      const payload = { cast: cast || [], eliminated: Array.from(eliminated || []), title: epTitle || "" };
      try { localStorage.setItem(castStateKey(season, episode), JSON.stringify(payload)); } catch {}
    }
    function loadCastState(season, episode) {
      try {
        const raw = localStorage.getItem(castStateKey(season, episode));
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }

    // Runtime state
    let CURRENT = {
      analytics: null,
      season: null,
      episode: null,
      summaryText: "",
      cast: [],
      eliminated: new Set(),
      titlesMap: {}
    };

    function saveCached(season, episode, analytics) {
      const key = cacheKey(season, episode);
      localStorage.setItem(key, JSON.stringify(analytics));
      saveLastSelection(season, episode);
    }

    function updateEpisodeHeaderFromInputs() {
      const epNum = Number(els.episode.value || 1);
      els.uiEpNum.textContent = `Episode ${epNum}`;
      // Keep title as-is unless we can parse one
      if (!els.uiEpName.textContent || els.uiEpName.textContent === "‚Äî") {
        const parsed = parseEpisodeTitle(els.summary.value || "");
        if (parsed?.title) els.uiEpName.textContent = `‚Äú${parsed.title}‚Äù`;
      }
    }

    els.generate.addEventListener("click", async () => {
      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);
      const summaryText = els.summary.value || "";
      if (!summaryText.trim()) return setStatus("Paste an episode summary first.");

      // Persist summary so reload keeps cast + gameplay
      saveSummary(season, episode, summaryText);

      updateEpisodeHeaderFromInputs();
      setStatus("Generating analytics...");

      try {
        const analytics = await callAI(season, episode, summaryText);
        saveCached(season, episode, analytics);

        // Save cast/elims for reloads
        const cast = parseCastFromSummary(summaryText);
        const eliminated = parseEliminated(summaryText);
        const ep = parseEpisodeTitle(summaryText);
        const epTitle = ep?.title ? `‚Äú${ep.title}‚Äù` : els.uiEpName.textContent;
        saveCastState(season, episode, cast, eliminated, epTitle);

        renderAll(analytics, summaryText);

        setStatus(`Done. Cached as ${cacheKey(season, episode)}.`);
      } catch (e) {
        setStatus("Error: " + (e?.message || String(e)));
        console.error(e);
      }
    });

    els.loadCached.addEventListener("click", () => {
      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);
      updateEpisodeHeaderFromInputs();
      const cached = loadCached(season, episode);
      if (!cached) return setStatus("No cached analytics found for this season/episode.");
      renderAll(cached, els.summary.value || "");
      setStatus("Loaded cached analytics.");
    });


    // ----------------------------
    // Season/Episode switching
    // ----------------------------
    function clearRenderedUI() {
      // Overview placeholders
      els.cardBestMove.innerHTML = "‚Äî";
      els.cardBiggestRisk.innerHTML = "‚Äî";
      els.cardEpisodeSummary.textContent = "‚Äî";
      els.cardBootOdds.innerHTML = "<div class='muted'>No boot predictions yet.</div>";
      els.cardPowerRankings.innerHTML = "<div class='muted'>No power rankings yet.</div>";
      els.cardAllianceOverview.innerHTML = "<div class='muted'>No alliance info yet.</div>";
      els.cardAllianceStability.innerHTML = "<div class='muted'>No alliance stability yet.</div>";
      els.cardTitles.innerHTML = "<div class='muted'>No titles yet.</div>";

      // Gameplay placeholders
      els.gpSvg.innerHTML = "";
      els.gpTableBody.innerHTML = "";

      // Players placeholder
      els.playersGrid.innerHTML =
        "<div class='muted'>No cast detected yet. Paste your summary and click ‚ÄúSync title/players from summary‚Äù.</div>";

      // Reset runtime
      CURRENT.analytics = null;
      CURRENT.summaryText = "";
      CURRENT.cast = [];
      CURRENT.eliminated = new Set();
      CURRENT.titlesMap = {};
    }

    function applySelection(season, episode, opts = {}) {
      const { quiet=false } = opts;

      // Persist last selection (so reload returns here)
      saveLastSelection(season, episode);

      // Update inputs (normalize)
      els.season.value = String(season);
      els.episode.value = String(episode);

      // Restore summary + cast state for this selection
      const savedSummary = loadSummary(season, episode);
      els.summary.value = savedSummary || "";

      // Restore episode title (from saved cast state) if available
      const savedCast = loadCastState(season, episode);
      if (savedCast?.title) {
        els.uiEpName.textContent = savedCast.title;
      } else {
        els.uiEpName.textContent = "‚Äî";
      }
      els.uiEpNum.textContent = `Episode ${episode}`;

      // Restore last tab for this episode
      let savedTab = "overview";
      try { savedTab = localStorage.getItem(tabKey(season, episode)) || "overview"; } catch {}
      showTab(savedTab === "gameplay" ? "gameplay" : "overview");

      // If we have cached analytics for this selection, load it (if auto-load enabled)
      const cached = loadCached(season, episode);

      if (cached && els.autoLoad.checked) {
        renderAll(cached, els.summary.value || "");
        if (!quiet) setStatus("Loaded cached analytics for this season/episode.");
        return;
      }

      // Otherwise, reset UI and show cast if we can infer it
      clearRenderedUI();

      const txt = els.summary.value || "";
      const cast = parseCastFromSummary(txt);
      const eliminated = parseEliminated(txt);

      if (cast.length) {
        renderPlayersGrid(cast, eliminated, {});
      } else if (savedCast?.cast?.length) {
        const elim = new Set((savedCast.eliminated || []).map(s => String(s).toLowerCase()));
        renderPlayersGrid(savedCast.cast, elim, {});
      }

      if (!quiet) {
        setStatus(cached ? "Cached analytics exists for this episode ‚Äî click ‚ÄúLoad Cached‚Äù (or enable auto-load)." : "No cached analytics for this season/episode yet.");
      }
    }

    // Change handlers
    function onSeasonEpisodeChange() {
      const s = Number(els.season.value || 1);
      const e = Number(els.episode.value || 1);
      applySelection(s, e);
    }
    els.season.addEventListener("change", onSeasonEpisodeChange);
    els.episode.addEventListener("change", onSeasonEpisodeChange);

    // ----------------------------
    // Init
    // ----------------------------
    (function init() {
      // Load endpoint
      const savedUrl = localStorage.getItem("AI_ENDPOINT_URL");
      if (savedUrl) els.workerUrl.value = savedUrl;

      // Restore last selection (so reload returns to the last viewed episode)
      const last = loadLastSelection();
      if (last?.season) els.season.value = last.season;
      if (last?.episode) els.episode.value = last.episode;

      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);

      // Apply selection: restores summary, cast, tab, and (optionally) cached analytics
      applySelection(season, episode, { quiet: true });

      // Friendly status
      const cached = loadCached(season, episode);
      if (cached && els.autoLoad.checked) setStatus("Auto-loaded cached analytics.");
      else if (cached) setStatus("Cached analytics found ‚Äî enable auto-load or click ‚ÄúLoad Cached‚Äù.");
      else setStatus("Ready ‚Äî paste summary and generate analytics.");
    })();
  })();
  
</script>
</div><footer class="siteFooter">
  <div class="footerInner">
    <div class="footerTitle">DC Franchise Database</div>
    <div class="footerSub">Static archive ‚Ä¢ 5 seasons ‚Ä¢ 58 players ‚Ä¢ Icons: name.png</div>
  </div>
</footer>
<!-- SITE FOOTER END -->
</body>
</html>
