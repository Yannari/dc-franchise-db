<!doctype html>
<html lang="en" data-root=".">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Current Season ‚Äî Season 5</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="live-season-tracker.css">

  <style>
    .muted{opacity:.78}
    .ai-controls{display:flex;gap:12px;align-items:flex-end;flex-wrap:wrap;margin:14px 0}
    .ai-field{flex:1;min-width:240px}
    .ai-field label{display:block;margin-bottom:6px}
    .ai-field input,.ai-field textarea{
      width:100%;
      border-radius:12px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      color:inherit;
      outline:none;
    }
    .ai-field textarea{resize:vertical}
    .ai-actions{display:flex;gap:10px;flex-wrap:wrap}
    .ai-inline{display:flex;gap:12px;flex-wrap:wrap}
    .ai-list{display:flex;flex-direction:column;gap:12px;margin-top:8px}
    .ai-row{padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.12)}
    .ai-row-top{display:flex;justify-content:space-between;gap:10px;align-items:baseline}
    .ai-row-label{font-weight:700}
    .ai-row-val{opacity:.85;font-variant-numeric:tabular-nums}
    .ai-row-sub{margin-top:6px;opacity:.78;font-size:.92rem}
    .ai-bar{height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:8px}
    .ai-bar span{display:block;height:100%;background:rgba(150,100,255,.85)}
    .ai-tag{display:inline-block;margin-left:8px;font-size:.8rem;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);opacity:.85}
    .ai-line{padding:6px 2px}
  
    /* AI: avatars + cast grid */
    .ai-player{display:flex;align-items:center;gap:10px;min-width:0}
    .ai-avatar{width:28px;height:28px;border-radius:999px;overflow:hidden;flex:0 0 28px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      display:grid;place-items:center}
    .ai-avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .ai-avatar span{font-size:16px;opacity:.9;line-height:1}
    .ai-name{font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ai-out{opacity:.45;filter:grayscale(1)}
    .ai-cast-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(170px,1fr));
      gap:12px;
      margin-top:10px
    }
    .ai-cast-card{
      display:flex;gap:12px;align-items:center;
      padding:12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.12);
      text-decoration:none;color:inherit
    }
    .ai-cast-card:hover{border-color:rgba(255,255,255,.16);background:rgba(0,0,0,.16)}
    .ai-cast-left{display:flex;align-items:center;gap:10px;min-width:0}
    .ai-cast-avatar{width:42px;height:42px;border-radius:999px;overflow:hidden;flex:0 0 42px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      display:grid;place-items:center}
    .ai-cast-avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .ai-cast-avatar span{font-size:20px;opacity:.9}
    .ai-cast-meta{min-width:0}
    .ai-cast-meta .t1{font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ai-cast-meta .t2{opacity:.72;font-size:.9rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  
/* --- AI RE-ARCH (current-season) --- */
.ai-panel{padding:18px;margin:18px 0}
.glass-card{background:rgba(24,16,34,.55);border:1px solid rgba(255,255,255,.08);border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.35);backdrop-filter: blur(10px)}
.section-title{margin:0 0 8px 0;font-size:20px}
.muted{opacity:.75}
.small{font-size:12px}
.ai-head{display:flex;justify-content:space-between;gap:12px;align-items:flex-end;flex-wrap:wrap}
.ai-status{opacity:.85;font-size:13px}
.ai-row{margin-top:12px}
.ai-label{display:block;font-size:12px;letter-spacing:.04em;text-transform:uppercase;opacity:.8;margin-bottom:8px}
.ai-endpoint{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.ai-input{width:100%;min-width:260px;background:rgba(10,8,18,.55);border:1px solid rgba(255,255,255,.10);color:#fff;border-radius:12px;padding:10px 12px;outline:none}
.ai-textarea{width:100%;min-height:170px;background:rgba(10,8,18,.55);border:1px solid rgba(255,255,255,.10);color:#fff;border-radius:12px;padding:12px;outline:none;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;line-height:1.35}
.ai-controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;align-items:flex-end}
.ai-field{flex:1;min-width:160px}
.ai-actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.ai-toggle{display:flex;gap:8px;align-items:center;font-size:13px;opacity:.9;user-select:none}
.ai-toggle input{accent-color: #9b6dff}
.btn{border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
.btn:hover{background:rgba(255,255,255,.10)}
.btn-primary{background:rgba(155,109,255,.22);border-color:rgba(155,109,255,.45)}
.btn-primary:hover{background:rgba(155,109,255,.30)}
.btn-ghost{background:rgba(255,255,255,.06)}

.episode-panel{padding:18px;margin:18px 0}
.episode-hero{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;padding:10px 6px 16px;border-bottom:1px solid rgba(255,255,255,.08);margin-bottom:14px}
.episode-kicker{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75}
.episode-title{font-size:28px;font-weight:800;line-height:1.15;margin-top:4px}
.episode-num{color:rgba(255,255,255,.95)}
.episode-name{color:rgba(155,109,255,.95);margin-left:8px}
.episode-sub{margin-top:8px;opacity:.85}
.subhead{margin:0 0 10px 0}

.players-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:14px}
.player-card{position:relative;display:flex;flex-direction:column;align-items:center;gap:8px;padding:14px;border-radius:16px;text-decoration:none;color:#fff;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.09);transition:transform .12s ease, border-color .12s ease, background .12s ease}
.player-card:hover{transform:translateY(-2px);border-color:rgba(155,109,255,.38);background:rgba(155,109,255,.08)}
.player-card.eliminated{opacity:.38;filter:grayscale(1)}
.pc-avatar{width:64px;height:64px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:flex;align-items:center;justify-content:center;overflow:hidden}
.pc-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.pc-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.75}
.pc-name{font-weight:800;text-align:center}
.pc-title{font-size:12px;opacity:.8;text-align:center;min-height:30px}
.pc-badge{position:absolute;top:10px;right:10px;font-size:10px;letter-spacing:.06em;text-transform:uppercase;background:rgba(255,120,120,.18);border:1px solid rgba(255,120,120,.35);padding:4px 8px;border-radius:999px}
.players-foot{margin-top:10px;opacity:.85;font-size:13px}

.window{padding:18px;margin:18px 0}
.window-head{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
.window-tabs{display:flex;gap:8px;flex-wrap:wrap}
.tab-btn{border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
.tab-btn.active{background:rgba(155,109,255,.22);border-color:rgba(155,109,255,.45)}
.window-body.hidden{display:none}

.cards-grid{display:grid;grid-template-columns:repeat(4, minmax(0,1fr));gap:12px}
.cards-grid.two{grid-template-columns:repeat(4, minmax(0,1fr));margin-top:12px}
@media (max-width: 1100px){
  .cards-grid{grid-template-columns:repeat(2, minmax(0,1fr))}
  .cards-grid.two{grid-template-columns:repeat(2, minmax(0,1fr))}
}
@media (max-width: 620px){
  .cards-grid{grid-template-columns:1fr}
  .cards-grid.two{grid-template-columns:1fr}
}
.mini-panel{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.09);border-radius:16px;padding:14px}
.mini-title{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75;margin-bottom:10px}
.mini-subtitle{font-size:12px;opacity:.75;margin:-4px 0 10px}
.mini-body{font-size:13px;line-height:1.4;opacity:.95}

.rowline{display:flex;gap:10px;align-items:flex-start}
.mini-avatar{width:38px;height:38px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:flex;align-items:center;justify-content:center;overflow:hidden;flex:none}
.mini-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.mini-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.75}
.rowtext{display:flex;flex-direction:column;gap:6px}
.plink{color:#fff;text-decoration:none}
.plink:hover{text-decoration:underline}

.bar-row{padding:10px 10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.14);margin-bottom:10px}
.bar-head{display:flex;justify-content:space-between;gap:10px;align-items:center}
.bar-left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.bar-pct{opacity:.85;font-variant-numeric:tabular-nums}
.bar-track{height:8px;border-radius:999px;background:rgba(255,255,255,.09);margin:8px 0 8px;overflow:hidden}
.bar-fill{height:100%;background:rgba(155,109,255,.75);border-radius:999px}
.bar-note{opacity:.82;font-size:12px;line-height:1.35}

.tiny-avatar{width:22px;height:22px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:inline-flex;align-items:center;justify-content:center;overflow:hidden}
.tiny-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.tiny-fallback{display:inline-flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;font-size:11px;opacity:.75}

.tag{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);opacity:.9}
.tag-up{background:rgba(80,255,170,.12);border-color:rgba(80,255,170,.35)}
.tag-down{background:rgba(255,90,120,.12);border-color:rgba(255,90,120,.35)}
.tag-steady{background:rgba(255,255,255,.08)}

.title-row{display:flex;gap:8px;align-items:center;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,.08)}
.title-row:last-child{border-bottom:none}

.gameplay-grid{display:grid;grid-template-columns:1.2fr .8fr;gap:12px}
@media (max-width: 980px){ .gameplay-grid{grid-template-columns:1fr} }
.compass-wrap{padding:8px}
.compass{position:relative;width:100%;aspect-ratio: 1.6/1;background:rgba(0,0,0,.14);border:1px solid rgba(255,255,255,.10);border-radius:16px;overflow:hidden}
.axis{position:absolute;background:rgba(255,255,255,.10)}
.axis-x{left:0;right:0;top:50%;height:1px}
.axis-y{top:0;bottom:0;left:50%;width:1px}
.axis-label{position:absolute;font-size:11px;opacity:.75}
.axis-label.left{left:10px;top:50%;transform:translateY(-50%)}
.axis-label.right{right:10px;top:50%;transform:translateY(-50%)}
.axis-label.top{top:10px;left:50%;transform:translateX(-50%)}
.axis-label.bottom{bottom:10px;left:50%;transform:translateX(-50%)}
.compass-points{position:absolute;inset:0}
.dot{position:absolute;transform:translate(-50%,-50%);text-decoration:none;color:#fff;transition:all .2s ease;opacity:.6}
.dot-circle{border-radius:999px;background:rgba(255,255,255,.08);border:2px solid rgba(155,109,255,.30);display:flex;align-items:center;justify-content:center;overflow:hidden;transition:all .2s ease}
.dot-circle img{width:100%;height:100%;object-fit:cover;display:none}
.dot-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.7}
.dot-label{display:block;margin-top:4px;font-size:10px;opacity:0;text-shadow:0 2px 10px rgba(0,0,0,.8);max-width:90px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;pointer-events:none;transition:opacity .2s ease}
.dot.show-label{opacity:1}
.dot.show-label .dot-label{opacity:.95}
.dot.show-label .dot-circle{background:rgba(155,109,255,.2);border-color:rgba(155,109,255,.6)}
.dot:hover{z-index:10;transform:translate(-50%,-50%) scale(1.3);opacity:1}
.dot:hover .dot-label{opacity:1}
.dot:hover .dot-circle{border-color:rgba(155,109,255,.9);background:rgba(155,109,255,.35);box-shadow:0 0 20px rgba(155,109,255,.4)}
.dot:hover .dot-fallback{opacity:1}
.table-wrap{overflow:auto;border-radius:16px;border:1px solid rgba(255,255,255,.10)}
.gp-table{width:100%;border-collapse:collapse}
.gp-table th,.gp-table td{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);font-size:13px;text-align:left}
.gp-table th{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75;background:rgba(255,255,255,.04);position:sticky;top:0}
.row-player{display:inline-flex;gap:8px;align-items:center}
</style>

</head>
<body>
<!-- SITE HEADER START -->
<header class="modern-header" id="modernHeader">
  <div class="header-container">
    <!-- Top Bar -->
    <div class="header-top">
      <a href="index.html" class="brand-section" aria-label="Go to home">
        <div class="brand-icon">
          <span class="brand-logo-text">‚ö°</span>
        </div>
        <div class="brand-content">
          <h1>DC <span class="brand-gradient">Franchise</span> Database</h1>
          <p class="brand-subtitle">Season <span id="currentSeasonNum">5</span> Live ‚Ä¢ Click to Explore</p>
        </div>
      </a>

      <div class="stats-badge">
        <div class="stats-main"><span id="totalSeasons">5</span> Seasons ‚Ä¢ <span id="totalPlayers">58</span> Players</div>
        <div class="stats-sub">Icons: <span id="iconFormat">name.png</span></div>
      </div>
    </div>

    <!-- Navigation -->
    <nav class="header-nav" aria-label="Primary navigation">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="index.html" class="nav-link" data-page="index">
            <span class="nav-icon">üè†</span>
            <span>Home</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="current-season.html" class="nav-link" data-page="current-season">
            <span class="nav-icon">üìä</span>
            <span>Current Season</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="voting-analytics.html" class="nav-link" data-page="voting-analytics">
            <span class="nav-icon">üßæ</span>
            <span>Voting Analytics</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="franchise.html" class="nav-link" data-page="franchise">
            <span class="nav-icon">üèõÔ∏è</span>
            <span>Franchise</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="rankings.html" class="nav-link" data-page="rankings">
            <span class="nav-icon">üèÜ</span>
            <span>Rankings</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="seasons.html" class="nav-link" data-page="seasons">
            <span class="nav-icon">üóÇÔ∏è</span>
            <span>Seasons</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="devotees.html" class="nav-link" data-page="devotees">
            <span class="nav-icon">üë•</span>
            <span>Players</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="awards.html" class="nav-link" data-page="awards">
            <span class="nav-icon">üèÖ</span>
            <span>Awards</span>
          </a>
        </li>
      </ul>
    </nav>
  </div>
</header>

<script>

// ===== Global render stubs (prevent "is not defined" before real tab renderers load) =====
window.__tabRenderQueue = window.__tabRenderQueue || [];
window.__queueTabRender = window.__queueTabRender || function(name, analytics){
  window.__tabRenderQueue.push({ name, analytics });
};

function renderAllAnalyticsTabs(analytics){
  if (typeof window.__realRenderAllAnalyticsTabs === "function") return window.__realRenderAllAnalyticsTabs(analytics);
  window.__queueTabRender("renderAllAnalyticsTabs", analytics);
}
function renderRankingsTab(analytics){
  if (typeof window.__realRenderRankingsTab === "function") return window.__realRenderRankingsTab(analytics);
  window.__queueTabRender("renderRankingsTab", analytics);
}
function renderRelationshipsTab(analytics){
  if (typeof window.__realRenderRelationshipsTab === "function") return window.__realRenderRelationshipsTab(analytics);
  window.__queueTabRender("renderRelationshipsTab", analytics);
}
function renderCompassTab(analytics){
  if (typeof window.__realRenderCompassTab === "function") return window.__realRenderCompassTab(analytics);
  window.__queueTabRender("renderCompassTab", analytics);
}
function renderEdgicTab(analytics){
  if (typeof window.__realRenderEdgicTab === "function") return window.__realRenderEdgicTab(analytics);
  window.__queueTabRender("renderEdgicTab", analytics);
}

function renderResumesTab(analytics){
  if (typeof window.__realRenderResumesTab === "function") return window.__realRenderResumesTab(analytics);
  window.__queueTabRender("renderResumesTab", analytics);
}

function renderTrendsTab(analytics){
  if (typeof window.__realRenderTrendsTab === "function") return window.__realRenderTrendsTab(analytics);
  window.__queueTabRender("renderTrendsTab", analytics);
}

function renderVotesTab(analytics){
  if (typeof window.__realRenderVotesTab === "function") return window.__realRenderVotesTab(analytics);
  window.__queueTabRender("renderVotesTab", analytics);
}


window.__flushTabRenderQueue = window.__flushTabRenderQueue || function(){
  const q = window.__tabRenderQueue || [];
  window.__tabRenderQueue = [];
  for (const item of q){
    try{
      const fn = window[item.name];
      if (typeof fn === "function") fn(item.analytics);
    } catch (e){
      console.warn("Queued render failed:", item.name, e);
    }
  }
};

(function() {
  // Load site config and update header stats
  if (window.SITE_CONFIG) {
    document.getElementById('totalSeasons').textContent = window.SITE_CONFIG.seasons;
    document.getElementById('totalPlayers').textContent = window.SITE_CONFIG.players;
    document.getElementById('currentSeasonNum').textContent = window.SITE_CONFIG.currentSeason;
    document.getElementById('iconFormat').textContent = window.SITE_CONFIG.iconFormat;
  }

  // Scroll behavior
  const header = document.getElementById('modernHeader');
  if (!header) return;
  
  window.addEventListener('scroll', () => {
    const currentScroll = window.pageYOffset;
    if (currentScroll > 20) {
      header.classList.add('scrolled');
    } else {
      header.classList.remove('scrolled');
    }
  }, { passive: true });

  // Active page highlighting
  const currentPage = window.location.pathname.split('/').pop() || 'index.html';
  const navLinks = document.querySelectorAll('.nav-link');
  
  navLinks.forEach(link => {
    const linkPage = link.getAttribute('href');
    if (linkPage === currentPage || (currentPage === '' && linkPage === 'index.html')) {
      link.classList.add('active');
    }
  });

  // Path resolution for nested folders
  const root = (document.documentElement.dataset.root || document.body.dataset.root || ".").replace(/\/+$/, "");
  
  if (root !== ".") {
    const allLinks = header.querySelectorAll('a[href]');
    allLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (href && !href.startsWith('http') && !href.startsWith('#')) {
        link.setAttribute('href', root + '/' + href);
      }
    });
  }
})();
</script>
<!-- SITE HEADER END -->

  <div class="container">
  <!-- 1) TOTAL DRAMA ANALYTICS (AI) -->
  <section class="ai-panel glass-card" id="aiPanel">
    <div class="ai-head">
      <h2 class="section-title">üìà Total Drama Analytics <span class="muted">(AI)</span></h2>
      <div class="ai-status" id="aiStatus">Paste your episode summary and generate analytics.</div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="aiWorkerUrl">AI Endpoint (Cloudflare Worker URL)</label>
      <div class="ai-endpoint">
        <input id="aiWorkerUrl" class="ai-input" placeholder="https://dc-analytics.yoursubdomain.workers.dev" />
        <button class="btn btn-ghost" id="aiSaveUrl">Save URL</button>
      </div>
      <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 4px;">
        Used for: Episode generation, Analytics
      </div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="seasonBuilderWorkerUrl">Season Builder Worker URL</label>
      <div class="ai-endpoint">
        <input id="seasonBuilderWorkerUrl" class="ai-input" placeholder="https://dc-analytic-seasons.yannari19.workers.dev" />
        <button class="btn btn-ghost" id="sbSaveUrl">Save URL</button>
      </div>
      <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 4px;">
        Used for: Season data extraction, Rankings, Auditions
      </div>
    </div>

    <div class="ai-controls">
      <div class="ai-field">
        <label class="ai-label" for="aiSeason">Season</label>
        <input id="aiSeason" class="ai-input" type="number" min="1" value="5" />
      </div>
      <div class="ai-field">
        <label class="ai-label" for="aiEpisode">Episode</label>
        <input id="aiEpisode" class="ai-input" type="number" min="1" value="1" />
      </div>

      <div class="ai-actions">
        <button class="btn btn-primary" id="aiGenerate">Generate Analytics</button>
        <button class="btn btn-ghost" id="aiLoadCached">Load Cached</button>
        <label class="ai-toggle">
          <input type="checkbox" id="aiAutoLoad" checked />
          <span>Auto-load on refresh</span>
        </label>
      </div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="aiSummary">Episode Summary Input</label>
      <textarea id="aiSummary" class="ai-textarea" spellcheck="false" placeholder="Paste your episode write-up here (like your Episode 1 summary)..."></textarea>
    </div>
  </section>

  <!-- 2) EPISODE HEADER + CURRENT PLAYERS (BIG) -->
  <section class="episode-panel glass-card" id="episodePanel">
    <div class="episode-hero">
      <div>
        <div class="episode-kicker">TOTAL DRAMA ‚Ä¢ Current Episode</div>
        <div class="episode-title">
          <span class="episode-num" id="uiEpisodeNum">Episode 1</span>
          <span class="episode-name" id="uiEpisodeName">‚Äî</span>
        </div>
        <div class="episode-sub">
          <span id="uiPlayersRemaining">‚Äî</span> remaining ‚Ä¢ Click any player to open their profile
        </div>
      </div>

      <div class="episode-hero-actions">
        <button class="btn btn-ghost" id="btnSyncFromSummary">Sync title/players from summary</button>
      </div>
    </div>

    <h3 class="subhead">Current Players</h3>
    <div class="players-grid" id="currentPlayersGrid"></div>
    <div class="players-foot">
      <span class="muted">Tip:</span> eliminated players are greyed out automatically if your summary includes an <b>ELIMINATED</b> block.
    </div>
  </section>

  <!-- 3) SWITCHABLE ANALYTICS WINDOW -->
  <section class="window glass-card" id="analyticsWindow">
    <div class="window-head">
      <h2 class="section-title">üìä Season Analytics</h2>
      <div class="window-tabs" role="tablist" aria-label="Analytics tabs">
        <button class="tab-btn active" id="tabRankings" role="tab" aria-selected="true">üìä Rankings</button>
        <button class="tab-btn" id="tabRelationships" role="tab" aria-selected="false">üíï Relationships</button>
        <button class="tab-btn" id="tabCompass" role="tab" aria-selected="false">üß≠ Compass</button>
        <button class="tab-btn" id="tabResumes" role="tab" aria-selected="false">üìÑ Resumes</button>
        <button class="tab-btn" id="tabTrends" role="tab" aria-selected="false">üìà Trends</button>
        <button class="tab-btn" id="tabVotes" role="tab" aria-selected="false">üó≥Ô∏è Votes</button>
        <button class="tab-btn" id="tabEdgic" role="tab" aria-selected="false">üìã Edgic</button>
        <button class="tab-btn" id="tabEpisode" role="tab" aria-selected="false">üì∫ Episode</button>
        <button class="tab-btn" id="tabSeasonSetup" role="tab" aria-selected="false">‚≠ê Season Setup</button>
      </div>
    </div>

    <!-- ========================================
     LIVE SEASON TRACKER - 7 NEW TAB VIEWS
     Replace viewOverview and viewGameplay with these
     ======================================== -->

<!-- RANKINGS TAB -->
<div class="window-body" id="viewRankings">
  <div class="rankings-grid">
    <!-- Audience Popularity -->
    <div class="ranking-section">
      <h3 class="ranking-title">üî• Audience Popularity</h3>
      <div class="ranking-list" id="audiencePopularityList">
        <p class="muted">Generate analytics to see audience popularity rankings.</p>
      </div>
    </div>

    <!-- Island Influence -->
    <div class="ranking-section">
      <h3 class="ranking-title">‚õ∞Ô∏è Island Influence</h3>
      <div class="ranking-list" id="islandInfluenceList">
        <p class="muted">Generate analytics to see island influence rankings.</p>
      </div>
    </div>
  </div>

  <!-- Alliance Network -->
  <div class="ranking-section" style="margin-top: 20px;">
    <h3 class="ranking-title">ü§ù Alliance Network</h3>
    <div class="alliance-list" id="allianceNetworkList">
      <p class="muted">No active alliances detected yet.</p>
    </div>
  </div>
</div>

<!-- RELATIONSHIPS TAB -->
<div class="window-body hidden" id="viewRelationships">
  <h3 style="margin-bottom: 16px;">üíï Relationship Heat Map</h3>
  <p class="muted" style="margin-bottom: 20px;">Live relationship values from -10 (enemies) to +10 (alliance)</p>
  
  <div class="heatmap-container" id="relationshipHeatmapContainer">
    <p class="muted">Generate analytics to see relationship heat map.</p>
  </div>
</div>

<!-- COMPASS TAB -->
<div class="window-body hidden" id="viewCompass">
  <h3 style="margin-bottom: 16px;">üß≠ Gameplay Compass</h3>
  <p class="muted" style="margin-bottom: 20px;">Players positioned by their actual in-game performance and strategic positioning</p>
  
  <div class="compass-container">
    <div class="compass-canvas" id="compassCanvas">
      <p class="muted" style="text-align: center; padding-top: 230px;">Generate analytics to see compass positioning.</p>
    </div>
  </div>

  <!-- Individual Analysis -->
  <div class="compass-analysis" id="compassAnalysis">
    <!-- Populated by JS -->
  </div>
</div>

<!-- RESUMES TAB -->
<div class="window-body hidden" id="viewResumes">
  <h3 style="margin-bottom: 16px;">üìÑ Player Resumes</h3>
  <p class="muted" style="margin-bottom: 20px;">Track strategic moves, voting patterns, and gameplay metrics</p>
  
  <div class="resume-grid" id="resumeGrid">
    <p class="muted">Generate analytics to see player resumes.</p>
  </div>
</div>

<!-- TRENDS TAB -->
<div class="window-body hidden" id="viewTrends">
  <h3 style="margin-bottom: 16px;">üìà Relationship Trends</h3>
  <p class="muted" style="margin-bottom: 20px;">Click a player to view all their relationships over time</p>
  
  <div class="trends-selector">
    <label for="trendPlayerSelect" style="display: block; margin-bottom: 8px; font-weight: 600;">Select Player:</label>
    <select id="trendPlayerSelect">
      <option value="">-- Select a player --</option>
    </select>
  </div>

  <div class="trends-grid" id="trendsGrid">
    <p class="muted">Select a player to see their relationship trends.</p>
  </div>
</div>

<!-- VOTES TAB -->
<div class="window-body hidden" id="viewVotes">
  <h3 style="margin-bottom: 16px;">üó≥Ô∏è Vote Analysis</h3>
  <p class="muted" style="margin-bottom: 20px;">Understand voting blocs and individual vote reasoning</p>
  
  <div class="vote-episode-selector">
    <label for="voteEpisodeSelect" style="display: block; margin-bottom: 8px; font-weight: 600;">Episode:</label>
    <select id="voteEpisodeSelect">
      <option value="">-- Select episode --</option>
    </select>
  </div>

  <div id="voteAnalysisContainer">
    <p class="muted">Select an episode to see vote analysis.</p>
  </div>
</div>

<!-- EDGIC TAB -->
<div class="window-body hidden" id="viewEdgic">
  <div class="edgic-header">
    <h3>üìã Edgic Chart</h3>
    <details class="edgic-explainer">
      <summary>‚ñ∂ How Edgic Works</summary>
      <div class="edgic-explainer-content">
        <p><strong>Edgic (Editor + Logic)</strong> rates each contestant's visibility and tone per episode based on actual game events.</p>
        <p><strong>Visibility:</strong> INV (Invisible) ‚Üí UTR (Under the Radar) ‚Üí MOR (Middle of Road) ‚Üí CP (Complex) ‚Üí OTT (Over the Top)</p>
        <p><strong>Tone:</strong> P (Positive) | N (Negative) | M (Mixed) | None (Neutral)</p>
        <p>Ratings are generated from confessionals, tribal councils, challenges, and vote outcomes.</p>
      </div>
    </details>
  </div>

  <div class="edgic-table-container" id="edgicTableContainer">
    <p class="muted">Generate analytics to see Edgic ratings.</p>
  </div>

  <!-- Winner Contenders -->
  <div class="edgic-contenders">
    <h4 class="edgic-contenders-title">üèÜ Winner Contenders</h4>
    <div class="edgic-contenders-grid" id="edgicContenders">
      <p class="muted">Generate analytics to see contenders.</p>
    </div>
  </div>
</div>


    <!-- EPISODE TAB -->
    <div class="window-body hidden" id="viewEpisode">
      <div class="episode-viewer">
        
        <!-- Summary Input for AI Generation -->
        <div class="glass-card" style="padding: 20px; margin-bottom: 20px;">
          <h3 style="margin-top: 0;">ü§ñ AI Episode Generation</h3>
          <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
            Paste your BrantSteele episode summary here, then click "Generate Episode" to create a full Total Drama episode transcript.
          </p>
          <textarea 
            id="episode-summary-input" 
            class="episode-input" 
            placeholder="Paste your BrantSteele episode summary here...

Example:
Episode 2: Tribal swap! Belo won immunity. At Reba, Ella was voted out 2-1..."
            style="width: 100%; min-height: 150px; margin-bottom: 12px;"></textarea>
          
          <!-- Auditions for Episode 1 Only -->
          <div id="episode-1-auditions" style="margin-top: 16px; padding: 12px; background: rgba(147,51,234,0.1); border: 1px solid rgba(147,51,234,0.3); border-radius: 8px; display: none;">
            <h4 style="margin: 0 0 8px 0; color: #c4b5fd; font-size: 14px;">üé¨ Episode 1 Special: Audition Tapes (Optional)</h4>
            <p style="opacity: 0.7; font-size: 12px; margin-bottom: 8px;">
              If this is Episode 1, paste audition tapes here. They'll be used as the cold open.
            </p>
            <textarea 
              id="episode-auditions-input" 
              class="episode-input" 
              placeholder="Audition 1/16 ‚Äî Carrie (Hopeless Romantic)
Carrie: I know every season by heart. I've analyzed every vote, every alliance, every blindside. This time, I'm not just watching‚ÄîI'm playing.

Audition 2/16 ‚Äî Devin (The Jock)
Devin: [flexes] They call me the golden boy. I'm here to prove nice guys can win..."
              style="width: 100%; min-height: 120px; background: rgba(147,51,234,0.05);"></textarea>
          </div>
          
          <button onclick="generateEpisodeAI()" id="generate-episode-btn" class="btn btn-primary" style="margin-top: 12px;">
            üé¨ Generate Episode with AI
          </button>
        </div>

        <!-- Manual Transcript Input -->
        <div class="glass-card" style="padding: 20px; margin-bottom: 20px;">
          <h3 style="margin-top: 0;">üìù Episode Transcript</h3>
          <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
            Or paste a manually written episode transcript here.
          </p>
          <textarea 
            id="episode-input" 
            class="episode-input" 
            placeholder="Paste or generate your episode transcript here...

Format:
[Scene: Beach. Morning.]

Chris: Welcome to Total Drama!

Owen: I'm so excited!

[Confessional: Owen]
Owen: This is going to be amazing!"
            style="width: 100%; min-height: 300px;"></textarea>
        </div>
        
        <!-- Controls -->
        <div class="episode-controls">
          <button onclick="renderEpisode()" class="btn btn-primary">üé¨ Render Episode</button>
          <button onclick="saveEpisode()" class="btn">üíæ Save Episode</button>
          <button onclick="loadEpisode()" class="btn">üìÇ Load Saved</button>
          <button onclick="clearEpisode()" class="btn btn-ghost">üóëÔ∏è Clear</button>
        </div>
        
        <!-- Rendered Episode -->
        <div id="episode-rendered"></div>
      </div>
    </div>

    <!-- SEASON SETUP TAB -->
    <div class="window-body hidden" id="viewSeasonSetup">
      <div class="glass-card" style="padding: 24px; margin-bottom: 20px;">
        <h3 style="margin-top: 0;">üé¨ Season Initialization</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 20px;">
          Start a new season by creating player profiles from your Episode 1 summary. 
          The system will detect new players vs returning players automatically.
        </p>
        
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">
            üìã Episode 1 Summary (with cast list)
          </label>
          <textarea 
            id="season-setup-summary" 
            style="width: 100%; min-height: 300px; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--text); font-family: monospace; font-size: 13px;"
            placeholder="Paste your Episode 1 summary here...

Must include:
=== CAST (ALL) ===
Amy
Beardo
Blaineley
..."></textarea>
        </div>
        
        <button id="analyze-cast-btn" class="btn btn-primary">
          üîç Analyze Cast
        </button>
        
        <div id="cast-analysis-result" style="margin-top: 20px; padding: 16px; background: rgba(125,76,255,0.1); border: 1px solid rgba(125,76,255,0.3); border-radius: 12px; display: none;">
          <!-- Analysis results will appear here -->
        </div>
        
        <div id="create-profiles-section" style="margin-top: 20px; display: none;">
          <button id="create-profiles-btn" class="btn" style="background: linear-gradient(135deg, #4ade80, #22c55e); font-weight: 700;">
            üé≠ Create Player Profiles
          </button>
        </div>
      </div>
      
      <!-- COMPLETE SEASON BUILDER -->
      <div class="glass-card" style="padding: 24px; margin-top: 20px; background: linear-gradient(135deg, rgba(155,109,255,0.15), rgba(76,255,179,0.05)); border: 2px solid rgba(155,109,255,0.3);">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 32px;">‚ö°</span>
            <div>
              <h3 style="margin: 0;">Complete Season Builder</h3>
              <p style="margin: 4px 0 0; opacity: 0.8; font-size: 13px;">
                Build entire season database from episode summaries (generates all JSON files)
              </p>
            </div>
          </div>
          
          <!-- Save Indicator & Clear Button -->
          <div style="display: flex; align-items: center; gap: 12px;">
            <div id="sb-save-indicator" style="display: none; padding: 8px 12px; background: rgba(76,255,179,0.2); border: 1px solid rgba(76,255,179,0.4); border-radius: 8px; font-size: 13px;">
              ‚úÖ Auto-saved
            </div>
            <button onclick="clearCurrentSeasonData()" style="padding: 8px 16px; background: rgba(255,76,76,0.2); border: 1px solid rgba(255,76,76,0.4); border-radius: 8px; color: #fff; cursor: pointer; font-size: 13px;">
              üóëÔ∏è Clear Season
            </button>
          </div>
        </div>
        
        <!-- SEASON METADATA -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
            <span>üìù</span> Season Metadata
          </h4>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Season Number</label>
              <input type="number" id="sb-season-number" value="6" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Episode Count</label>
              <input type="number" id="sb-episode-count" value="14" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Cast Size</label>
              <input type="number" id="sb-cast-size" value="16" min="10" max="30"
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Emoji</label>
              <input type="text" id="sb-season-emoji" value="üéØ" maxlength="4"
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-size: 24px; text-align: center;" />
            </div>
          </div>
          
          <div style="margin-top: 16px;">
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Season Title</label>
            <input type="text" id="sb-season-title" placeholder="Total Drama [Theme Name]" 
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
          </div>
          
          <div style="margin-top: 12px;">
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Subtitle</label>
            <input type="text" id="sb-season-subtitle" placeholder="Season tagline or description" 
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
          </div>
          
          <div style="margin-top: 12px;">
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Theme</label>
            <input type="text" id="sb-season-theme" placeholder="E.g., '3 tribes + swaps + redemption island'" 
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
          </div>
        </div>
        
        <!-- BRANTSTEELE STATS -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
            <span>üìä</span> Brantsteele Stats (Optional but Recommended)
          </h4>
          
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">
              Paste Brantsteele Summary Stats
              <span style="opacity: 0.6;">(Placements, Challenge Wins, Votes Received, Idols, etc.)</span>
            </label>
            <textarea id="sb-brantsteele-stats" rows="8" placeholder="Optional: Paste the full Brantsteele season summary here for accurate stats...

Example format:
Place | Player | Phase | Notes
1 | Jacques | Winner | 7 votes to win
2 | Mickey | Finalist | 1 vote
...

Challenge Performance:
Jacques: 4 wins
Mickey: 1 win
...

Votes Received:
Brody: 26
Kitty: 15
..."
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px;"></textarea>
          </div>
          
          <div style="margin-top: 12px; padding: 12px; background: rgba(76,255,179,0.1); border: 1px solid rgba(76,255,179,0.3); border-radius: 8px;">
            <p style="margin: 0; font-size: 12px; opacity: 0.85;">
              üí° <strong>Tip:</strong> Including Brantsteele stats ensures 100% accuracy for challenge wins, idol counts, and votes received. AI will merge this data with episode narratives.
            </p>
          </div>
        </div>
        
        <!-- EPISODE SUMMARIES -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h4 style="margin: 0; display: flex; align-items: center; gap: 8px;">
              <span>üìö</span> Episode Summaries
            </h4>
            <button id="sb-toggle-episodes" class="btn" style="font-size: 12px; padding: 6px 12px;">
              Show All Episodes
            </button>
          </div>
          
          <div id="sb-episodes-container">
            <!-- Episode inputs will be dynamically generated by JavaScript -->
          </div>
          
          <div style="margin-top: 16px; padding: 12px; background: rgba(255,179,71,0.1); border: 1px solid rgba(255,179,71,0.3); border-radius: 8px;">
            <p style="margin: 0 0 8px 0; font-size: 12px; opacity: 0.85;">
              üí° <strong>Required:</strong> Episode 1 must include the cast list in format:<br/>
              <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">=== CAST (ALL) ===</code>
            </p>
            <p style="margin: 0; font-size: 12px; opacity: 0.85;">
              üí° <strong>Optional:</strong> Include tribe assignments for tribe tracking:<br/>
              <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">=== TRIBE: Galang ===</code><br/>
              <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">Mickey, Jacques, Ryan...</code>
            </p>
          </div>
        </div>
        
        <!-- FINALE & AWARDS -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
            <span>üèÜ</span> Finale Results & Awards
          </h4>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 16px;">
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Winner</label>
              <input type="text" id="sb-finale-winner" placeholder="Winner name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Runner-Up(s)</label>
              <input type="text" id="sb-finale-runnerup" placeholder="Name1, Name2" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Final Vote</label>
              <input type="text" id="sb-finale-vote" placeholder="5-4 or 4-3-2" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
          </div>
          
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Jury Votes (one per line: Juror voted for Finalist)</label>
            <textarea id="sb-jury-votes" rows="6" placeholder="Scarlett voted for Mickey
Sugar voted for Sky
Dave voted for Mickey
..."
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px;"></textarea>
          </div>
          
          <h5 style="margin: 20px 0 12px 0; opacity: 0.9;">Season Awards</h5>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Fan Favorite</label>
              <input type="text" id="sb-award-fan" placeholder="Player name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Best Strategic</label>
              <input type="text" id="sb-award-strategic" placeholder="Player name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Most Challenge Wins</label>
              <input type="text" id="sb-award-challenges" placeholder="Player name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
          </div>
        </div>
        
        <!-- GENERATE BUTTON -->
        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
          <button id="sb-generate-all" class="btn btn-primary" style="flex: 1; font-size: 16px; padding: 14px; background: linear-gradient(135deg, #9b6dff, #4cffb3); font-weight: 700;">
            ‚ö° Generate Complete Season Database
          </button>
          
          <button id="sb-preview-data" class="btn" style="padding: 14px 20px;">
            üëÅÔ∏è Preview Data
          </button>
        </div>
        
        <!-- PROGRESS/RESULTS -->
        <div id="sb-progress" style="margin-top: 20px; display: none;">
          <!-- Progress updates will appear here -->
        </div>
      </div>
      
      <div class="glass-card" style="padding: 24px;">
        <h3 style="margin-top: 0;">üìä Season Progress Tracking</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
          Track eliminations throughout the season. Placement data updates automatically when you generate analytics.
        </p>
        
        <div id="season-progress-info" style="padding: 16px; background: rgba(255,179,71,0.1); border: 1px solid rgba(255,179,71,0.3); border-radius: 12px;">
          <p style="margin: 0; opacity: 0.7;">No season data loaded. Create profiles first.</p>
        </div>
      </div>
      
      <div class="glass-card" style="padding: 24px; margin-top: 20px;">
        <h3 style="margin-top: 0;">üèÜ End-of-Season Finalization</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
          After the finale, manually edit the player database JSON to add:
        </p>
        <ul style="opacity: 0.8; font-size: 14px; line-height: 1.8;">
          <li><strong>Challenge wins</strong> - Individual immunity/reward wins</li>
          <li><strong>Strategic rank</strong> - Your assessment of their gameplay</li>
          <li><strong>Alliance history</strong> - Key alliances they were part of</li>
          <li><strong>Bonds & rivalries</strong> - Important relationships</li>
          <li><strong>Jury votes</strong> - How many jury votes they received (finalists only)</li>
          <li><strong>Tier ranking</strong> - Calculate based on performance</li>
          <li><strong>Badges</strong> - Awards like "Challenge Beast", "Strategic Mastermind"</li>
        </ul>
        
        <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
          <p style="margin: 0; font-size: 13px; opacity: 0.7;">
            üí° <strong>Tip:</strong> The system auto-creates profiles and tracks eliminations. 
            You focus on the rich gameplay data at season's end!
          </p>
        </div>
      </div>
      
      <div class="glass-card" style="padding: 24px; margin-top: 20px;">
        <h3 style="margin-top: 0;">üíæ Database Management</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
          Export, import, or sync your player database.
        </p>
        
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button id="export-database-btn" class="btn" style="background: linear-gradient(135deg, #22c55e, #16a34a);">
            üì• Export Database to JSON
          </button>
          
          <button id="import-database-btn" class="btn" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">
            üì§ Import Database from JSON
          </button>
          
          <button onclick="manageDatabaseSync()" class="btn" style="background: linear-gradient(135deg, #ec4899, #db2777);">
            üîÑ Manage Sync
          </button>
          
          <button id="sync-devotees-btn" class="btn" style="background: linear-gradient(135deg, #a855f7, #9333ea);">
            üîÑ Sync to devotees.html
          </button>
          
          <button id="rebuild-rankings-btn" class="btn" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
            üîÑ Rebuild All Rankings
          </button>
        </div>
        
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
        
        <div id="database-status" style="margin-top: 16px; padding: 12px; background: rgba(125,76,255,0.1); border: 1px solid rgba(125,76,255,0.3); border-radius: 8px; display: none;">
          <!-- Status messages appear here -->
        </div>
      </div>
    </div>
  </section>

  <!-- SCRIPT: AI + RENDERING -->
  <script>

  (function() {
    const $ = (id) => document.getElementById(id);

    const els = {
      workerUrl: $("aiWorkerUrl"),
      saveUrl: $("aiSaveUrl"),
      season: $("aiSeason"),
      episode: $("aiEpisode"),
      generate: $("aiGenerate"),
      loadCached: $("aiLoadCached"),
      autoLoad: $("aiAutoLoad"),
      summary: $("aiSummary"),
      status: $("aiStatus"),

      uiEpNum: $("uiEpisodeNum"),
      uiEpName: $("uiEpisodeName"),
      uiRemain: $("uiPlayersRemaining"),
      syncFromSummary: $("btnSyncFromSummary"),
      playersGrid: $("currentPlayersGrid"),

      tabRankings: $("tabRankings"),
      tabRelationships: $("tabRelationships"),
      tabCompass: $("tabCompass"),
      tabResumes: $("tabResumes"),
      tabTrends: $("tabTrends"),
      tabVotes: $("tabVotes"),
      tabEdgic: $("tabEdgic"),

      tabEpisode: $("tabEpisode"),
      tabSeasonSetup: $("tabSeasonSetup"),
      
      viewRankings: $("viewRankings"),
      viewRelationships: $("viewRelationships"),
      viewCompass: $("viewCompass"),
      viewResumes: $("viewResumes"),
      viewTrends: $("viewTrends"),
      viewVotes: $("viewVotes"),
      viewEdgic: $("viewEdgic"),
      viewEpisode: $("viewEpisode"),
      viewSeasonSetup: $("viewSeasonSetup"),

      cardBestMove: $("cardBestMove"),
      cardBiggestRisk: $("cardBiggestRisk"),
      cardEpisodeSummary: $("cardEpisodeSummary"),
      cardVotingBlocs: $("cardVotingBlocs"),
      cardBootOdds: $("cardBootOdds"),
      cardPowerRankings: $("cardPowerRankings"),
      cardAllianceStability: $("cardAllianceStability"),
      cardTitles: $("cardTitles"),
      cardSocialNetwork: $("cardSocialNetwork"),
      cardJuryManagement: $("cardJuryManagement"),
      cardThreatBreakdown: $("cardThreatBreakdown"),
      cardPathToVictory: $("cardPathToVictory"),

      compassPoints: $("compassPoints"),
      gpTableBody: $("gpTableBody"),
    };

    // ----------------------------
    // Helpers
    // ----------------------------
    function normalizeWorkerUrl(raw) {
      let url = (raw || "").trim();
      if (!url) return "";
      if (!/^https?:\/\//i.test(url)) url = "https://" + url;
      return url.replace(/\/+$/, "");
    }

    function slugify(name) {
      return (name || "")
        .toLowerCase()
        .trim()
        .replace(/['".]/g, "")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");
    }

    function escapeHtml(s) {
      return String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function setStatus(msg) {
      if (els.status) els.status.textContent = msg;
    }

    function cacheKey(season, episode) {
      return `AI_ANALYTICS_s${season}_e${episode}`;
    }

    function saveLastSelection(season, episode) {
      localStorage.setItem("AI_LAST_SELECTION", JSON.stringify({ season, episode }));
    }

    function loadLastSelection() {
      try { return JSON.parse(localStorage.getItem("AI_LAST_SELECTION") || "null"); } catch { return null; }
    }

    // Extract cast list from summary (best effort)
        function parseBlock(text, headerRegex) {
      const lines = (text || "").split(/\r?\n/);
      let start = -1;
      for (let i = 0; i < lines.length; i++) {
        if (headerRegex.test(lines[i].trim())) { start = i; break; }
      }
      if (start === -1) return [];
      const out = [];
      for (let i = start + 1; i < lines.length; i++) {
        const raw = lines[i];
        const l = (raw || "").trim();
        if (!l) continue;
        if (/^===\s*/.test(l)) break;
        // stop if next major section starts (fallback)
        if (/^(PRE-CHALLENGE|CHALLENGES|POST-CHALLENGE|TRIBAL|VOTING|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
        out.push(l);
      }
      return out;
    }

    function cleanNameLine(l) {
      let s = (l || "").trim();
      if (!s) return "";
      s = s.replace(/^[-‚Ä¢]\s*/, "");
      // strip numbering like "18. Leonard" or "18th Leonard"
      s = s.replace(/^\d+\s*(?:[.)]|(?:st|nd|rd|th)\b)\s*/i, "");
      // strip "Name:18th" or "Name - 18th"
      s = s.replace(/:\s*\d+(?:st|nd|rd|th)\b.*$/i, "").trim();
      s = s.replace(/[‚Äî‚Äì].*$/, "").trim();
      return s;
    }

    function isProbablyName(s) {
      return /^[A-Za-z][A-Za-z0-9' -]*$/.test(s) && s.length <= 30;
    }

    function parseCastFromSummary(text) {
      const lines = (text || "").split(/\r?\n/).map(l => l.trim());
      let names = [];

      // META block: === CAST (ALL) ===
      const castBlock = parseBlock(text, /^===\s*CAST\b/i);
      if (castBlock.length) {
        castBlock.forEach(l => {
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        });
      }

      // TRIBES block: === TRIBES (ACTIVE) === with # Tribe headings
      const tribesBlock = parseBlock(text, /^===\s*TRIBES\b/i);
      if (tribesBlock.length) {
        tribesBlock.forEach(l => {
          if (/^#\s*/.test(l)) return; // header
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        });
      }

      // Pattern 1: after "The Cast arrives"
      const idx = lines.findIndex(l => /the\s+cast\s+arrives/i.test(l));
      if (idx !== -1) {
        for (let i = idx + 1; i < lines.length; i++) {
          const l = lines[i];
          if (!l) break;
          if (/^(PRE-CHALLENGE|CHALLENGES|POST-CHALLENGE|VOTING|TRIBAL|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        }
      }

      // Pattern 2: Active Players lines like "Belo Tribe (6): Amy, Rodney..."
      const tribeLines = lines.filter(l => /tribe\s*\(\d+\)\s*:/i.test(l));
      for (const tl of tribeLines) {
        const after = tl.split(":")[1] || "";
        after.split(",").map(x => x.trim()).filter(Boolean).forEach(n => {
          const cn = cleanNameLine(n);
          if (isProbablyName(cn)) names.push(cn);
        });
      }

      // De-dup while preserving order
      const seen = new Set();
      names = names
        .map(n => n.trim())
        .filter(Boolean)
        .filter(n => {
          const k = n.toLowerCase();
          if (seen.has(k)) return false;
          seen.add(k);
          return true;
        });

      return names;
    }

    function parseEpisodeTitle(text) {
      // Episode 2: "Shadows of Doubt"
      const m = (text || "").match(/Episode\s+(\d+)\s*[:\-]\s*["‚Äú]?([^"\n‚Äù]+)["‚Äù]?/i);
      if (m) return { num: parseInt(m[1], 10), title: m[2].trim() };
      // EPISODE 1 SUMMARY (no title)
      const m2 = (text || "").match(/EPISODE\s+(\d+)/i);
      if (m2) return { num: parseInt(m2[1], 10), title: "" };
      return null;
    }

     function parseEliminated(text) {
  const rawLines = (text || "").split(/\r?\n/);
  const lines = rawLines.map(l => (l || "").trim());

  const out = [];
  const pushName = (l) => {
    const n = cleanNameLine(l);
    if (isProbablyName(n)) out.push(n);
  };

  // META block: === ELIMINATED === (ONLY this specific block, not CAST)
  const elimRegex = /^===\s*ELIMINATED\s*===/i;
  let inElimBlock = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Start of ELIMINATED block
    if (elimRegex.test(line)) {
      inElimBlock = true;
      continue;
    }
    
    // End of block (hit another === header or ----)
    if (inElimBlock && (/^===/.test(line) || /^---/.test(line))) {
      break;
    }
    
    // Collect names while in ELIMINATED block
    if (inElimBlock) {
      pushName(line);
    }
  }

  // De-dup
  const seen = new Set();
  return out.filter(n => {
    const k = n.toLowerCase();
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });
}

    function getProbForPlayer(bootPredictions, player) {
      if (!Array.isArray(bootPredictions)) return 0;
      const found = bootPredictions.find(x => (x?.player || "").toLowerCase() === (player || "").toLowerCase());
      return found ? Number(found.prob) || 0 : 0;
    }

    // ----------------------------
    // Rendering: Current Players grid
    // ----------------------------
    function renderPlayersGrid(castNames, eliminatedNames, titlesMap) {
      const eliminated = new Set((eliminatedNames || []).map(n => n.toLowerCase()));
      const cast = (castNames || []).slice(0, 60);

      if (!cast.length) {
        els.playersGrid.innerHTML = `<div class="muted">No cast detected yet. Click ‚ÄúSync title/players from summary‚Äù.</div>`;
        els.uiRemain.textContent = "‚Äî";
        return;
      }

      const remainingCount = cast.filter(n => !eliminated.has(n.toLowerCase())).length;
      els.uiRemain.textContent = `${remainingCount} players`;

      els.playersGrid.innerHTML = cast.map((name) => {
        const id = slugify(name);
        const isOut = eliminated.has(name.toLowerCase());
        const title = titlesMap?.[name.toLowerCase()] || "";
        const subtitle = title ? escapeHtml(title) : "‚Äî";
        const classes = "player-card" + (isOut ? " eliminated" : "");
        return `
          <a class="${classes}" href="player.html?player=${id}" data-player="${id}">
            <div class="pc-avatar">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
              <span class="pc-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
            </div>
            <div class="pc-name">${escapeHtml(name)}</div>
            <div class="pc-title">${subtitle}</div>
            ${isOut ? `<div class="pc-badge">ELIMINATED</div>` : ``}
          </a>
        `;
      }).join("");
    }

    // ----------------------------
    // Rendering: Overview cards
    // ----------------------------
    function renderMoveCard(targetEl, moveObj) {
      if (!moveObj || !moveObj.player) { targetEl.textContent = "‚Äî"; return; }
      const id = slugify(moveObj.player);
      targetEl.innerHTML = `
        <div class="rowline">
          <div class="mini-avatar">
            <img src="assets/avatars/${id}.png" alt="${escapeHtml(moveObj.player)}"
              onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
              onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
            <span class="mini-fallback">${escapeHtml((moveObj.player||'?').slice(0,1).toUpperCase())}</span>
          </div>
          <div class="rowtext">
            <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(moveObj.player)}</b></a>
            <div class="muted">${escapeHtml(moveObj.reason || "")}</div>
          </div>
        </div>
      `;
    }

    function renderBootOdds(targetEl, bootPredictions) {
      if (!Array.isArray(bootPredictions) || bootPredictions.length === 0) {
        targetEl.textContent = "No boot predictions returned.";
        return;
      }
      
      // Sort by probability descending (highest risk first)
      const sorted = [...bootPredictions].sort((a, b) => (Number(b.prob) || 0) - (Number(a.prob) || 0));
      
      targetEl.innerHTML = sorted
        .map((p) => {
          const name = p.player || "";
          const id = slugify(name);
          const rawProb = Number(p.prob) || 0;
          
          // Handle both formats: 0-1 decimal OR 0-100 percentage
          // If value is <= 1, it's a decimal (multiply by 100)
          // If value is > 1, it's already a percentage
          const pct = rawProb <= 1 ? Math.round(rawProb * 100) : Math.round(rawProb);
          
          return `
            <div class="bar-row">
              <div class="bar-head">
                <div class="bar-left">
                  <span class="tiny-avatar">
                    <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                      onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                    <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                  </span>
                  <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                </div>
                <div class="bar-pct">${pct}%</div>
              </div>
              <div class="bar-track"><div class="bar-fill" style="width:${pct}%"></div></div>
              <div class="bar-note">${escapeHtml(p.why || "")}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderPowerRankings(targetEl, powerRankings) {
      if (!Array.isArray(powerRankings) || powerRankings.length === 0) {
        targetEl.textContent = "No power rankings returned.";
        return;
      }
      targetEl.innerHTML = powerRankings
        .map((r) => {
          const name = r.player || "";
          const id = slugify(name);
          const score = Math.round(Number(r.score) || 0);
          const tag = (r.tag || "Steady").toLowerCase();
          const tagClass = tag === "rising" ? "tag tag-up" : tag === "falling" ? "tag tag-down" : "tag tag-steady";
          return `
            <div class="bar-row">
              <div class="bar-head">
                <div class="bar-left">
                  <span class="tiny-avatar">
                    <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                      onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                    <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                  </span>
                  <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                  <span class="${tagClass}">${escapeHtml(r.tag || "Steady")}</span>
                </div>
                <div class="bar-pct">${score}/100</div>
              </div>
              <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
              <div class="bar-note">${escapeHtml(r.blurb || "")}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderAllianceStability(targetEl, allianceStability) {
      if (!Array.isArray(allianceStability) || allianceStability.length === 0) {
        targetEl.textContent = "No alliances detected (or none provided).";
        return;
      }
      targetEl.innerHTML = allianceStability.map((a) => {
        const score = Math.max(0, Math.min(100, Math.round(Number(a.score) || 0)));
        return `
          <div class="bar-row">
            <div class="bar-head">
              <div class="bar-left"><b>${escapeHtml(a.name || "Alliance")}</b></div>
              <div class="bar-pct">${score}/100</div>
            </div>
            <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
            <div class="bar-note">${escapeHtml(a.note || "")}</div>
          </div>
        `;
      }).join("");
    }

    function renderTitles(targetEl, titles) {
      if (!Array.isArray(titles) || titles.length === 0) {
        targetEl.textContent = "No titles returned.";
        return;
      }
      targetEl.innerHTML = titles.map((t) => {
        const name = t.player || "";
        const id = slugify(name);
        return `
          <div class="title-row">
            <span class="tiny-avatar">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
              <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
            </span>
            <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
            <span class="muted">‚Äî</span>
            <span>${escapeHtml(t.title || "")}</span>
          </div>
        `;
      }).join("");
    }

    function renderSocialNetwork(targetEl, socialNetwork) {
      if (!Array.isArray(socialNetwork) || socialNetwork.length === 0) {
        targetEl.textContent = "No social network data returned.";
        return;
      }
      targetEl.innerHTML = socialNetwork.map((s) => {
        const name = s.player || "";
        const id = slugify(name);
        const likes = s.strongLikes || [];
        const dislikes = s.strongDislikes || [];
        const centrality = Math.round(Number(s.centralityScore) || 0);
        const isolated = s.isolated ? 'üî¥ Isolated' : '';
        
        return `
          <div class="bar-row">
            <div class="bar-head" style="flex-direction: column; align-items: flex-start; gap: 6px;">
              <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                <span class="muted" style="margin-left: auto; font-size: 11px;">Centrality: ${centrality}/100 ${isolated}</span>
              </div>
              <div style="font-size: 12px; opacity: 0.8;">
                ${likes.length > 0 ? `üíö Likes: ${escapeHtml(likes.join(', '))}` : ''}
                ${likes.length > 0 && dislikes.length > 0 ? '<br/>' : ''}
                ${dislikes.length > 0 ? `‚ù§Ô∏è‚Äçüî• Dislikes: ${escapeHtml(dislikes.join(', '))}` : ''}
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderJuryManagement(targetEl, juryManagement) {
      if (!Array.isArray(juryManagement) || juryManagement.length === 0) {
        targetEl.textContent = "No jury management data returned.";
        return;
      }
      
      const sorted = [...juryManagement].sort((a, b) => (Number(b.score) || 0) - (Number(a.score) || 0));
      
      targetEl.innerHTML = sorted.map((j) => {
        const name = j.player || "";
        const id = slugify(name);
        const score = Math.round(Number(j.score) || 0);
        const note = j.note || "";
        
        return `
          <div class="bar-row">
            <div class="bar-head">
              <div class="bar-left">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
              </div>
              <div class="bar-pct">${score}/100</div>
            </div>
            <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
            <div class="bar-note">${escapeHtml(note)}</div>
          </div>
        `;
      }).join("");
    }

    function renderThreatBreakdown(targetEl, threatBreakdown) {
      if (!Array.isArray(threatBreakdown) || threatBreakdown.length === 0) {
        targetEl.textContent = "No threat breakdown data returned.";
        return;
      }
      
      // Calculate totals and sort by total threat (highest to lowest)
      const withTotals = threatBreakdown.map((t) => {
        const physical = Math.round(Number(t.physical) || 0);
        const strategic = Math.round(Number(t.strategic) || 0);
        const social = Math.round(Number(t.social) || 0);
        const advantage = Math.round(Number(t.advantage) || 0);
        const total = Math.round((physical + strategic + social + advantage) / 4);
        return { ...t, physical, strategic, social, advantage, total };
      });
      
      const sorted = withTotals.sort((a, b) => b.total - a.total);
      
      targetEl.innerHTML = sorted.map((t) => {
        const name = t.player || "";
        const id = slugify(name);
        
        return `
          <div class="bar-row">
            <div class="bar-head" style="flex-direction: column; align-items: flex-start; gap: 8px;">
              <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                <span class="muted" style="margin-left: auto;">Total: ${t.total}/100</span>
              </div>
              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; width: 100%; font-size: 11px;">
                <div>üí™ Phys: ${t.physical}</div>
                <div>üß† Strat: ${t.strategic}</div>
                <div>ü§ù Social: ${t.social}</div>
                <div>üéÅ Adv: ${t.advantage}</div>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderPathToVictory(targetEl, pathToVictory) {
      if (!Array.isArray(pathToVictory) || pathToVictory.length === 0) {
        targetEl.textContent = "No path to victory data returned.";
        return;
      }
      
      const viabilityOrder = { 'High': 1, 'Medium': 2, 'Low': 3, 'None': 4 };
      const sorted = [...pathToVictory].sort((a, b) => 
        (viabilityOrder[a.viability] || 99) - (viabilityOrder[b.viability] || 99)
      );
      
      targetEl.innerHTML = sorted.map((p) => {
        const name = p.player || "";
        const id = slugify(name);
        const viability = p.viability || "Unknown";
        const winCondition = p.winCondition || "";
        const obstacles = p.obstacles || "";
        
        const viabilityColor = {
          'High': '#4ade80',
          'Medium': '#fbbf24',
          'Low': '#fb923c',
          'None': '#ef4444'
        }[viability] || '#9ca3af';
        
        return `
          <div class="bar-row">
            <div class="bar-head" style="flex-direction: column; align-items: flex-start; gap: 8px;">
              <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                <span style="margin-left: auto; padding: 2px 8px; border-radius: 6px; font-size: 11px; font-weight: 700; background: ${viabilityColor}22; color: ${viabilityColor}; border: 1px solid ${viabilityColor};">
                  ${escapeHtml(viability)}
                </span>
              </div>
              <div style="font-size: 12px; opacity: 0.9;">
                <div><b>Win Condition:</b> ${escapeHtml(winCondition)}</div>
                <div style="margin-top: 4px;"><b>Obstacles:</b> ${escapeHtml(obstacles)}</div>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderVotingBlocs(targetEl, analytics) {
      const blocs = Array.isArray(analytics?.votingBlocs) ? analytics.votingBlocs : [];
      
      if (blocs.length === 0) {
        targetEl.innerHTML = `<div class="muted">No voting blocs detected yet.</div>`;
        return;
      }
      
      const html = blocs.slice(0, 4).map(bloc => {
        const members = (bloc.members || []).join(", ");
        const strength = Math.round(Number(bloc.strength) || 0);
        const strengthBar = `<div style="background: rgba(76,255,179,0.2); border-radius: 4px; height: 6px; margin: 4px 0;"><div style="background: #4cffb3; width: ${strength}%; height: 100%; border-radius: 4px;"></div></div>`;
        
        return `
          <div style="margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px;">
            <div style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(bloc.name || "Unnamed Bloc")}</div>
            <div style="font-size: 11px; opacity: 0.7; margin-bottom: 2px;">Members: ${escapeHtml(members)}</div>
            <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">Target: ${escapeHtml(bloc.target || "Unknown")}</div>
            ${strengthBar}
            <div style="font-size: 11px; opacity: 0.8; margin-top: 4px;">${escapeHtml(bloc.notes || "")}</div>
          </div>
        `;
      }).join('');
      
      targetEl.innerHTML = html;
    }

    // ----------------------------
    // Rendering: Gameplay page
    // ----------------------------
    function renderCompass(analytics, castNames, eliminatedNames) {
      const eliminated = new Set((eliminatedNames||[]).map(n=>n.toLowerCase()));

      // Build a map of power scores
      const pr = Array.isArray(analytics?.powerRankings) ? analytics.powerRankings : [];
      const bm = new Map(pr.map(x => [(x.player||"").toLowerCase(), Math.max(0, Math.min(100, Number(x.score)||0))]));

      const bp = Array.isArray(analytics?.bootPredictions) ? analytics.bootPredictions : [];
      // Normalize prob to 0-1 range (handle both 0-1 decimal and 0-100 percentage)
      const probMap = new Map(bp.map(x => {
        const rawProb = Number(x.prob) || 0;
        const prob01 = rawProb <= 1 ? rawProb : rawProb / 100; // Convert 0-100 to 0-1 if needed
        return [(x.player||"").toLowerCase(), Math.max(0, Math.min(1, prob01))];
      }));

      const active = (castNames||[]).filter(n => !eliminated.has(n.toLowerCase()));
      const points = active.slice(0, 30).map((name) => {
        const key = name.toLowerCase();
        const power = bm.get(key) ?? 50;
        
        // Use boot prediction from AI if available (now in 0-1 range)
        let prob = probMap.get(key);
        if (prob === undefined) {
          // Fallback: If AI didn't include this player, assume moderate-low risk
          prob = Math.max(0.10, Math.min(0.40, 0.50 - (power / 100) * 0.40));
        }
        
        // CAP boot risk at 70% maximum to spread players more vertically
        const cappedProb = Math.min(prob * 100, 70); // Convert to percentage and cap at 70
        
        // x: power (0..100) - use actual power score
        // y: safety = 100 - cappedProb (now ranges from 30-90 instead of 0-100)
        const x = power;
        const y = 100 - cappedProb;
        return { name, x, y, prob, power };
      });
      
      // Use actual data ranges with minimal normalization
      // Only apply a gentle spread if data is too clustered (within 20 points)
      const xValues = points.map(p => p.x);
      const yValues = points.map(p => p.y);
      const xMin = Math.min(...xValues);
      const xMax = Math.max(...xValues);
      const yMin = Math.min(...yValues);
      const yMax = Math.max(...yValues);
      
      const xRange = xMax - xMin;
      const yRange = yMax - yMin;
      
      // Don't sort - keep original order to maintain data accuracy
      // Apply minimal normalization - use actual values with just padding
      const normalizedPoints = points.map((p, idx) => {
        // Use actual power score directly (0-100 maps to 5-95%)
        const xNorm = 5 + (p.x / 100) * 90;
        
        // Use actual safety score directly (30-100 after capping maps to 5-95%)
        // But remap from 30-100 range to 5-95% range for better use of space
        const yMin = 30; // Minimum y after 70% risk cap
        const yMax = 100; // Maximum y (0% risk)
        const yNormalized = ((p.y - yMin) / (yMax - yMin)); // 0-1 range
        const yNorm = 5 + yNormalized * 90; // 5-95% range
        
        // Add small jitter only to prevent exact pixel overlaps (not for spreading)
        const jitterScale = 3; // Small fixed jitter
        const jitterX = ((idx % 5) - 2) * jitterScale; // -6 to +6
        const jitterY = (Math.floor(idx / 5) % 5 - 2) * jitterScale; // -6 to +6
        
        return { 
          name: p.name,
          power: p.power, // Keep for label logic
          x: Math.max(5, Math.min(95, xNorm + jitterX)), 
          y: Math.max(5, Math.min(95, yNorm + jitterY))
        };
      });

      // Sort by power to identify top players for labels
      const sortedByPower = [...normalizedPoints].sort((a, b) => (b.power || 0) - (a.power || 0));
      const top3Names = new Set(sortedByPower.slice(0, 3).map(p => p.name.toLowerCase()));

      els.compassPoints.innerHTML = normalizedPoints.map((p, index) => {
        const id = slugify(p.name);
        // convert x,y (0..100) to %
        const left = Math.max(3, Math.min(97, p.x));
        const top = Math.max(3, Math.min(97, 100 - p.y)); // invert for CSS top
        
        // Get power score and boot risk from analytics
        const playerData = analytics?.powerRankings?.find(pr => 
          pr.player.toLowerCase() === p.name.toLowerCase()
        );
        const bootData = analytics?.bootPredictions?.find(bp => 
          bp.player.toLowerCase() === p.name.toLowerCase()
        );
        
        const power = playerData?.score || 50;
        const risk = bootData?.prob || 15;
        
        // Calculate dot size based on combined threat (power + inverse risk)
        const threat = (power + (100 - risk)) / 2;
        const size = 20 + (threat / 100) * 15; // 20-35px range (smaller)
        const fontSize = Math.round(size * 0.4); // Scale font with size
        
        // Show label for top 3 players by power score
        const showLabel = top3Names.has(p.name.toLowerCase());
        
        return `
          <a class="dot ${showLabel ? 'show-label' : ''}" href="player.html?player=${id}" style="left:${left}%;top:${top}%;">
            <span class="dot-circle" style="width:${size}px;height:${size}px;">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(p.name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
              <span class="dot-fallback" style="font-size:${fontSize}px;">${escapeHtml((p.name||'?').slice(0,1).toUpperCase())}</span>
            </span>
            <span class="dot-label">${escapeHtml(p.name)}</span>
          </a>
        `;
      }).join("");
    }

    function renderGameplayTable(analytics, castNames, eliminatedNames, titlesMap) {
      const eliminated = new Set((eliminatedNames||[]).map(n=>n.toLowerCase()));
      const pr = Array.isArray(analytics?.powerRankings) ? analytics.powerRankings : [];
      const bp = Array.isArray(analytics?.bootPredictions) ? analytics.bootPredictions : [];
      const rolesArr = Array.isArray(analytics?.roles) ? analytics.roles : [];

      const powerMap = new Map(pr.map(x => [(x.player||"").toLowerCase(), x]));
      const probMap = new Map(bp.map(x => [(x.player||"").toLowerCase(), x]));
      const rolesMap = new Map(rolesArr.map(x => [(x.player||"").toLowerCase(), x.role||""]));

      const active = (castNames||[]).filter(n => !eliminated.has(n.toLowerCase()));
      const rows = active.map((name) => {
        const key = name.toLowerCase();
        const r = powerMap.get(key) || { player: name, score: 50, tag: "Steady", blurb: "" };
        const p = probMap.get(key) || { prob: 0.15, why: "" };
        const score = Math.round(Number(r.score)||0);
        
        // Handle both prob formats: 0-1 decimal OR 0-100 percentage
        const rawProb = Number(p.prob) || 0;
        const prob = rawProb <= 1 ? Math.round(rawProb * 100) : Math.round(rawProb);
        
        const title = titlesMap?.[key] || "";
        
        // Use AI-generated role from analytics, fallback to calculated role
        const role = rolesMap.get(key) || (
          prob >= 35 ? "In Danger" :
          score >= 80 ? "Power Player" :
          score >= 65 ? "Well-Positioned" :
          "Under the Radar"
        );
        
        return { name, score, prob, tag: r.tag || "Steady", title, role };
      }).sort((a,b)=>b.score-a.score);

      els.gpTableBody.innerHTML = rows.map((row) => {
        const id = slugify(row.name);
        const tag = (row.tag||"Steady").toLowerCase();
        const tagClass = tag==="rising" ? "tag tag-up" : tag==="falling" ? "tag tag-down" : "tag tag-steady";
        return `
          <tr>
            <td>
              <a class="plink row-player" href="player.html?player=${id}">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(row.name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((row.name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <b>${escapeHtml(row.name)}</b>
              </a>
            </td>
            <td class="muted">${escapeHtml(row.title || "‚Äî")}</td>
            <td><span class="${tagClass}">${escapeHtml(row.tag)}</span></td>
            <td>${row.score}</td>
            <td>${row.prob}%</td>
            <td>${escapeHtml(row.role)}</td>
          </tr>
        `;
      }).join("");
    }

    // ----------------------------
    // Main render from analytics
    // ----------------------------
    function renderAll(analytics, summaryText) {
      if (!analytics || typeof analytics !== "object") return;

      // Titles map for quick lookups
      const titlesArr = Array.isArray(analytics.titles) ? analytics.titles : [];
      const titlesMap = {};
      for (const t of titlesArr) {
        if (t?.player) titlesMap[t.player.toLowerCase()] = t.title || "";
      }

      CURRENT.titlesMap = titlesMap;

      // Detect cast + eliminated from current summary input (best effort)
      const txt = (summaryText || els.summary.value || "").trim();

      // Prefer parsing from summary; fall back to saved cast state if summary isn't present.
      let cast = parseCastFromSummary(txt);
      let eliminated = parseEliminated(txt);

      const seasonNow = Number(els.season.value || 1);
      const episodeNow = Number(els.episode.value || 1);

      if ((!cast || cast.length === 0) || (eliminated && eliminated.size === 0 && !txt)) {
        const saved = loadCastState(seasonNow, episodeNow);
        if (saved) {
          if (!cast || cast.length === 0) cast = Array.isArray(saved.cast) ? saved.cast : [];
          if ((!eliminated || eliminated.size === 0) && Array.isArray(saved.eliminated)) {
            eliminated = new Set(saved.eliminated.map(s => String(s).toLowerCase()));
          }
          if (!txt && saved.title && els.uiEpName) {
            els.uiEpName.textContent = saved.title;
          }
        }
      }

      // Save for later use (tab switches, etc.)
      CURRENT.analytics = analytics;
      CURRENT.season = seasonNow;
      CURRENT.episode = episodeNow;
      CURRENT.summaryText = txt;
      CURRENT.cast = cast || [];
      CURRENT.eliminated = eliminated || new Set();

      renderPlayersGrid(cast, eliminated, titlesMap);

      // OLD Overview cards - only render if elements still exist (backwards compatibility)
      if (els.cardBestMove) renderMoveCard(els.cardBestMove, analytics.bestMove);
      if (els.cardBiggestRisk) renderMoveCard(els.cardBiggestRisk, analytics.biggestRisk);
      if (els.cardEpisodeSummary) els.cardEpisodeSummary.textContent = analytics.narrativeSummary || "‚Äî";
      if (els.cardVotingBlocs) renderVotingBlocs(els.cardVotingBlocs, analytics);
      if (els.cardBootOdds) renderBootOdds(els.cardBootOdds, analytics.bootPredictions);
      if (els.cardPowerRankings) renderPowerRankings(els.cardPowerRankings, analytics.powerRankings);
      if (els.cardAllianceStability) renderAllianceStability(els.cardAllianceStability, analytics.allianceStability);
      if (els.cardTitles) renderTitles(els.cardTitles, analytics.titles);
      if (els.cardSocialNetwork) renderSocialNetwork(els.cardSocialNetwork, analytics.socialNetwork);
      if (els.cardJuryManagement) renderJuryManagement(els.cardJuryManagement, analytics.juryManagement);
      if (els.cardThreatBreakdown) renderThreatBreakdown(els.cardThreatBreakdown, analytics.threatBreakdown);
      if (els.cardPathToVictory) renderPathToVictory(els.cardPathToVictory, analytics.pathToVictory);

      // OLD Gameplay compass/table - only render if elements still exist
      if (els.compassPoints) renderCompass(analytics, cast, eliminated, titlesMap);
      if (els.gpTableBody) renderGameplayTable(analytics, cast, eliminated, titlesMap);
      
      // NEW Analytics tabs - render all 7 new tabs
      renderAllAnalyticsTabs(analytics);
    }

    // ----------------------------
    // Tabs
    // ----------------------------
    function showTab(which) {
      const tabs = {
        rankings: { btn: els.tabRankings, view: els.viewRankings },
        relationships: { btn: els.tabRelationships, view: els.viewRelationships },
        compass: { btn: els.tabCompass, view: els.viewCompass },
        resumes: { btn: els.tabResumes, view: els.viewResumes },
        trends: { btn: els.tabTrends, view: els.viewTrends },
        votes: { btn: els.tabVotes, view: els.viewVotes },
        edgic: { btn: els.tabEdgic, view: els.viewEdgic },
        episode: { btn: els.tabEpisode, view: els.viewEpisode },
        seasonsetup: { btn: els.tabSeasonSetup, view: els.viewSeasonSetup },
      };

      // Hide all views and deactivate all buttons
      Object.values(tabs).forEach(tab => {
        if (tab.view) tab.view.classList.add("hidden");
        if (tab.btn) {
          tab.btn.classList.remove("active");
          tab.btn.setAttribute("aria-selected", "false");
        }
      });

      // Show selected tab
      const selected = tabs[which];
      if (selected) {
        if (selected.view) selected.view.classList.remove("hidden");
        if (selected.btn) {
          selected.btn.classList.add("active");
          selected.btn.setAttribute("aria-selected", "true");
        }
      }

      // Render tab-specific content when switching
      if (which === "rankings" && CURRENT.analytics) {
        renderRankingsTab(CURRENT.analytics);
      } else if (which === "relationships" && CURRENT.analytics) {
        renderRelationshipsTab(CURRENT.analytics);
      } else if (which === "compass" && CURRENT.analytics) {
        renderCompassTab(CURRENT.analytics);
      } else if (which === "resumes" && CURRENT.analytics) {
        renderResumesTab(CURRENT.analytics);
      } else if (which === "trends" && CURRENT.analytics) {
        renderTrendsTab(CURRENT.analytics);
      } else if (which === "votes" && CURRENT.analytics) {
        renderVotesTab(CURRENT.analytics);
      } else if (which === "edgic" && CURRENT.analytics) {
        renderEdgicTab(CURRENT.analytics);
      }

      // Persist tab choice per episode
      const s = Number(els.season.value || 1);
      const e = Number(els.episode.value || 1);
      try { localStorage.setItem(tabKey(s, e), which); } catch {}
    }


    els.tabRankings.addEventListener("click", () => showTab("rankings"));
    els.tabRelationships.addEventListener("click", () => showTab("relationships"));
    els.tabCompass.addEventListener("click", () => showTab("compass"));
    els.tabResumes.addEventListener("click", () => showTab("resumes"));
    els.tabTrends.addEventListener("click", () => showTab("trends"));
    els.tabVotes.addEventListener("click", () => showTab("votes"));
    els.tabEdgic.addEventListener("click", () => showTab("edgic"));
    els.tabEpisode.addEventListener("click", () => {
      showTab("episode");
      // Try to auto-load saved episode
      if (typeof loadEpisode === 'function') loadEpisode();
    });
    els.tabSeasonSetup.addEventListener("click", () => showTab("seasonsetup"));

    // ----------------------------
    // Actions
    // ----------------------------
    els.saveUrl.addEventListener("click", () => {
      const url = normalizeWorkerUrl(els.workerUrl.value);
      if (!url) return setStatus("Enter a Worker URL first.");
      els.workerUrl.value = url;
      localStorage.setItem("AI_ENDPOINT_URL", url);
      setStatus("Saved AI endpoint.");
    });

    // Save Season Builder Worker URL
    const sbSaveUrlBtn = document.getElementById("sbSaveUrl");
    const sbWorkerUrlInput = document.getElementById("seasonBuilderWorkerUrl");
    if (sbSaveUrlBtn && sbWorkerUrlInput) {
      sbSaveUrlBtn.addEventListener("click", () => {
        const url = normalizeWorkerUrl(sbWorkerUrlInput.value);
        if (!url) return setStatus("Enter a Season Builder Worker URL first.");
        sbWorkerUrlInput.value = url;
        localStorage.setItem("SEASON_BUILDER_WORKER_URL", url);
        setStatus("Saved Season Builder endpoint.");
      });
      
      // Load saved URL on page load
      const savedSbUrl = localStorage.getItem("SEASON_BUILDER_WORKER_URL");
      if (savedSbUrl) sbWorkerUrlInput.value = savedSbUrl;
    }

    els.syncFromSummary.addEventListener("click", () => {
      const txt = els.summary.value || "";
      const s = Number(els.season.value || 1);

      const ep = parseEpisodeTitle(txt);
      if (ep?.num) els.episode.value = ep.num;

      const e = Number(els.episode.value || 1);
      if (ep?.title) els.uiEpName.textContent = `‚Äú${ep.title}‚Äù`;
      els.uiEpNum.textContent = `Episode ${e}`;

      // Persist summary + cast for reloads
      saveSummary(s, e, txt);

      const cast = parseCastFromSummary(txt);
      const eliminated = parseEliminated(txt);

      // Save cast state even if empty (lets us show ‚Äúno cast detected‚Äù consistently)
      saveCastState(s, e, cast, eliminated, ep?.title ? `‚Äú${ep.title}‚Äù` : els.uiEpName.textContent);

      // Update runtime state
      CURRENT.season = s;
      CURRENT.episode = e;
      CURRENT.summaryText = (txt || "").trim();
      CURRENT.cast = cast;
      CURRENT.eliminated = eliminated;

      renderPlayersGrid(cast, eliminated, {});
      // If AI already loaded, refresh gameplay view too
      if (CURRENT.analytics) {
        renderCompass(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
        renderGameplayTable(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
      }

      setStatus("Synced from summary (saved for reload).");
    });

    async function callAI(season, episode, summaryText) {
      const url = normalizeWorkerUrl(els.workerUrl.value || localStorage.getItem("AI_ENDPOINT_URL") || "");
      if (!url) throw new Error("Missing AI endpoint URL.");
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ season, episode, summaryText }),
      });
      const data = await res.json();
      if (!res.ok) {
        // Try to surface OpenAI error nicely
        const msg = data?.error?.message || data?.message || "Unknown error.";
        throw new Error(msg);
      }
      
      // VALIDATION: Auto-fill missing players
      const cast = parseCastFromSummary(summaryText);
      const eliminated = parseEliminated(summaryText);
      const active = cast.filter(name => !eliminated.some(e => e.toLowerCase() === name.toLowerCase()));
      
      // Ensure all active players are in bootPredictions
      if (Array.isArray(data.bootPredictions)) {
        const bootMap = new Map(data.bootPredictions.map(x => [x.player.toLowerCase(), x]));
        active.forEach(player => {
          const key = player.toLowerCase();
          if (!bootMap.has(key)) {
            // Missing player - add with default low risk
            console.warn(`Missing in bootPredictions: ${player} - auto-adding with 10% risk`);
            data.bootPredictions.push({
              player: player,
              prob: 0.10,
              why: "Not in AI's top predictions; assumed moderate safety."
            });
          }
        });
      }
      
      // Ensure all active players are in powerRankings
      if (Array.isArray(data.powerRankings)) {
        const powerMap = new Map(data.powerRankings.map(x => [x.player.toLowerCase(), x]));
        active.forEach(player => {
          const key = player.toLowerCase();
          if (!powerMap.has(key)) {
            // Missing player - add with default middle score
            console.warn(`Missing in powerRankings: ${player} - auto-adding with score 50`);
            data.powerRankings.push({
              player: player,
              score: 50,
              tag: "Steady",
              blurb: "Not in AI's detailed rankings; neutral position."
            });
          }
        });
      }
      
      return data;
    }

    function loadCached(season, episode) {
      const key = cacheKey(season, episode);
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function summaryKey(season, episode) {
      return `AI_SUMMARY_s${season}_e${episode}`;
    }
    function castStateKey(season, episode) {
      return `AI_CAST_s${season}_e${episode}`;
    }
    function tabKey(season, episode) {
      return `AI_TAB_s${season}_e${episode}`;
    }

    function saveSummary(season, episode, text) {
      try { localStorage.setItem(summaryKey(season, episode), text || ""); } catch {}
    }
    function loadSummary(season, episode) {
      try { return localStorage.getItem(summaryKey(season, episode)) || ""; } catch { return ""; }
    }

    function saveCastState(season, episode, cast, eliminated, epTitle) {
      const payload = { cast: cast || [], eliminated: Array.from(eliminated || []), title: epTitle || "" };
      try { localStorage.setItem(castStateKey(season, episode), JSON.stringify(payload)); } catch {}
    }
    function loadCastState(season, episode) {
      try {
        const raw = localStorage.getItem(castStateKey(season, episode));
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }

    // Runtime state
    let CURRENT = {
      analytics: null,
      season: null,
      episode: null,
      summaryText: "",
      cast: [],
      eliminated: new Set(),
      titlesMap: {}
    };

    function saveCached(season, episode, analytics) {
      const key = cacheKey(season, episode);
      localStorage.setItem(key, JSON.stringify(analytics));
      saveLastSelection(season, episode);
    }

    function updateEpisodeHeaderFromInputs() {
      const epNum = Number(els.episode.value || 1);
      els.uiEpNum.textContent = `Episode ${epNum}`;
      // Keep title as-is unless we can parse one
      if (!els.uiEpName.textContent || els.uiEpName.textContent === "‚Äî") {
        const parsed = parseEpisodeTitle(els.summary.value || "");
        if (parsed?.title) els.uiEpName.textContent = `‚Äú${parsed.title}‚Äù`;
      }
    }

    els.generate.addEventListener("click", async () => {
      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);
      const summaryText = els.summary.value || "";
      if (!summaryText.trim()) return setStatus("Paste an episode summary first.");

      // Persist summary so reload keeps cast + gameplay
      saveSummary(season, episode, summaryText);

      updateEpisodeHeaderFromInputs();
      setStatus("Generating analytics...");

      try {
        const analytics = await callAI(season, episode, summaryText);
        saveCached(season, episode, analytics);

        // Save cast/elims for reloads
        const cast = parseCastFromSummary(summaryText);
        const eliminated = parseEliminated(summaryText);
        const ep = parseEpisodeTitle(summaryText);
        const epTitle = ep?.title ? `‚Äú${ep.title}‚Äù` : els.uiEpName.textContent;
        saveCastState(season, episode, cast, eliminated, epTitle);

        // üÜï AUTO-UPDATE PLAYER DATABASE WITH ELIMINATIONS
        if (typeof updatePlayerEliminationsFromEpisode === 'function') {
          updatePlayerEliminationsFromEpisode(season, episode, cast, eliminated);
        }

        renderAll(analytics, summaryText);

        setStatus(`Done. Cached as ${cacheKey(season, episode)}.`);
      } catch (e) {
        setStatus("Error: " + (e?.message || String(e)));
        console.error(e);
      }
    });

    els.loadCached.addEventListener("click", () => {
      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);
      updateEpisodeHeaderFromInputs();
      const cached = loadCached(season, episode);
      if (!cached) return setStatus("No cached analytics found for this season/episode.");
      renderAll(cached, els.summary.value || "");
      setStatus("Loaded cached analytics.");
    });


    // ----------------------------
    // Season/Episode switching
    // ----------------------------
    function clearRenderedUI() {
      // Overview placeholders
      els.cardBestMove.innerHTML = "‚Äî";
      els.cardBiggestRisk.innerHTML = "‚Äî";
      els.cardEpisodeSummary.textContent = "‚Äî";
      els.cardBootOdds.innerHTML = "<div class='muted'>No boot predictions yet.</div>";
      els.cardPowerRankings.innerHTML = "<div class='muted'>No power rankings yet.</div>";
      els.cardVotingBlocs.innerHTML = "<div class='muted'>No voting blocs detected yet.</div>";
      els.cardAllianceStability.innerHTML = "<div class='muted'>No alliance stability yet.</div>";
      els.cardTitles.innerHTML = "<div class='muted'>No titles yet.</div>";
      els.cardSocialNetwork.innerHTML = "<div class='muted'>No social network data yet.</div>";
      els.cardJuryManagement.innerHTML = "<div class='muted'>No jury management data yet.</div>";
      els.cardThreatBreakdown.innerHTML = "<div class='muted'>No threat breakdown yet.</div>";
      els.cardPathToVictory.innerHTML = "<div class='muted'>No path to victory data yet.</div>";

      // Gameplay placeholders
      // els.gpSvg.innerHTML = ""; // REMOVED - element doesnt exist
      els.gpTableBody.innerHTML = "";

      // Players placeholder
      els.playersGrid.innerHTML =
        "<div class='muted'>No cast detected yet. Paste your summary and click ‚ÄúSync title/players from summary‚Äù.</div>";

      // Reset runtime
      CURRENT.analytics = null;
      CURRENT.summaryText = "";
      CURRENT.cast = [];
      CURRENT.eliminated = new Set();
      CURRENT.titlesMap = {};
    }

    function applySelection(season, episode, opts = {}) {
      const { quiet=false } = opts;

      // Persist last selection (so reload returns here)
      saveLastSelection(season, episode);

      // Update inputs (normalize)
      els.season.value = String(season);
      els.episode.value = String(episode);

      // Restore summary + cast state for this selection
      const savedSummary = loadSummary(season, episode);
      els.summary.value = savedSummary || "";

      // Restore episode title (from saved cast state) if available
      const savedCast = loadCastState(season, episode);
      if (savedCast?.title) {
        els.uiEpName.textContent = savedCast.title;
      } else {
        els.uiEpName.textContent = "‚Äî";
      }
      els.uiEpNum.textContent = `Episode ${episode}`;

      // Restore last tab for this episode
      let savedTab = "rankings";
      try { savedTab = localStorage.getItem(tabKey(season, episode)) || "rankings"; } catch {}
      showTab(savedTab);

      // If we have cached analytics for this selection, load it (if auto-load enabled)
      const cached = loadCached(season, episode);

      if (cached && els.autoLoad.checked) {
        renderAll(cached, els.summary.value || "");
        if (!quiet) setStatus("Loaded cached analytics for this season/episode.");
        return;
      }

      // Otherwise, reset UI and show cast if we can infer it
      clearRenderedUI();

      const txt = els.summary.value || "";
      const cast = parseCastFromSummary(txt);
      const eliminated = parseEliminated(txt);

      if (cast.length) {
        renderPlayersGrid(cast, eliminated, {});
      } else if (savedCast?.cast?.length) {
        const elim = new Set((savedCast.eliminated || []).map(s => String(s).toLowerCase()));
        renderPlayersGrid(savedCast.cast, elim, {});
      }

      if (!quiet) {
        setStatus(cached ? "Cached analytics exists for this episode ‚Äî click ‚ÄúLoad Cached‚Äù (or enable auto-load)." : "No cached analytics for this season/episode yet.");
      }
    }

    // Change handlers
    function onSeasonEpisodeChange() {
      const s = Number(els.season.value || 1);
      const e = Number(els.episode.value || 1);
      applySelection(s, e);
    }
    els.season.addEventListener("change", onSeasonEpisodeChange);
    els.episode.addEventListener("change", onSeasonEpisodeChange);

    // ----------------------------
    // Init
    // ----------------------------
    (function init() {
      // Load endpoint
      const savedUrl = localStorage.getItem("AI_ENDPOINT_URL");
      if (savedUrl) els.workerUrl.value = savedUrl;

      // Restore last selection (so reload returns to the last viewed episode)
      const last = loadLastSelection();
      if (last?.season) els.season.value = last.season;
      if (last?.episode) els.episode.value = last.episode;

      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);

      // Apply selection: restores summary, cast, tab, and (optionally) cached analytics
      applySelection(season, episode, { quiet: true });

      // Friendly status
      const cached = loadCached(season, episode);
      if (cached && els.autoLoad.checked) setStatus("Auto-loaded cached analytics.");
      else if (cached) setStatus("Cached analytics found ‚Äî enable auto-load or click ‚ÄúLoad Cached‚Äù.");
      else setStatus("Ready ‚Äî paste summary and generate analytics.");
    })();
  })();
  
  // ========================================
  // EPISODE TAB FUNCTIONALITY (Global scope for onclick handlers)
  // ========================================
  
  // Configuration
  const EPISODE_WORKER_URL = 'https://dc-analytics.yannari19.workers.dev'; // Update with your worker URL
  
  // Character avatar mapping
  const CHARACTER_AVATARS = {
    'chris': 'üòè', 'chef': 'üë®‚Äçüç≥', 'owen': 'üçî', 'gwen': 'üé®', 'duncan': 'üíÄ',
    'courtney': 'üìã', 'heather': 'üíÖ', 'lindsay': 'üíÅ', 'alejandro': 'üëë',
    'sierra': 'üì±', 'noah': 'üìö', 'cody': 'üò¨', 'izzy': 'ü§™', 'eva': 'üò†',
    'tyler': 'üèÄ', 'trent': 'üé∏', 'bridgette': 'üèÑ', 'geoff': 'üéâ', 'beth': 'üå∏',
    'justin': 'üòé', 'katie': 'üíñ', 'sadie': 'üíñ', 'ezekiel': 'üèîÔ∏è', 'leshawna': 'üíÅ',
    'harold': 'ü§ì', 'amy': 'üòà', 'samey': 'üòä', 'scarlett': 'üß™', 'max': 'ü¶π',
    'ella': 'üé∂', 'topher': 'üì∫', 'jasmine': 'üåø', 'shawn': 'üßü', 'dave': 'üò§',
    'sky': 'ü•ã', 'sugar': 'üç≠', 'rodney': 'üíò', 'beardo': 'üéµ', 'leonard': 'ü™Ñ',
    'josee': '‚õ∑Ô∏è', 'mickey': 'üê≠', 'ryan': 'üèãÔ∏è', 'blaineley': 'üé§'
  };
  
  // Storage key generator
  function getEpisodeStorageKey() {
    const seasonEl = document.getElementById('aiSeason');
    const episodeEl = document.getElementById('aiEpisode');
    const season = seasonEl ? seasonEl.value : '5';
    const episode = episodeEl ? episodeEl.value : '1';
    return `td_episode_s${season}_e${episode}`;
  }
  
  // Save episode to localStorage
  function saveEpisode() {
    const transcript = document.getElementById('episode-input').value;
    if (!transcript.trim()) {
      alert('‚ö†Ô∏è Please paste or generate an episode transcript first!');
      return;
    }
    
    localStorage.setItem(getEpisodeStorageKey(), transcript);
    alert('‚úÖ Episode saved successfully!');
    renderEpisode();
  }
  
  // Load episode from localStorage
  function loadEpisode() {
    const saved = localStorage.getItem(getEpisodeStorageKey());
    if (saved) {
      document.getElementById('episode-input').value = saved;
      renderEpisode();
      return true;
    }
    return false;
  }
  
  // Clear episode
  function clearEpisode() {
    if (confirm('‚ö†Ô∏è Clear the current episode? This cannot be undone.')) {
      document.getElementById('episode-input').value = '';
      document.getElementById('episode-rendered').innerHTML = '';
      localStorage.removeItem(getEpisodeStorageKey());
      alert('üóëÔ∏è Episode cleared!');
    }
  }
  
  // Generate episode using AI
// Replace the existing generateEpisodeAI function with this updated version:

async function generateEpisodeAI() {
  // Safety check: ensure EPISODE_WORKER_URL is defined
  if (typeof EPISODE_WORKER_URL === 'undefined') {
    console.error('EPISODE_WORKER_URL not initialized yet. Please refresh the page.');
    alert('‚ö†Ô∏è Page not fully loaded. Please refresh and try again.');
    return;
  }
  
  const summaryInput = document.getElementById('episode-summary-input');
  const summary = summaryInput ? summaryInput.value.trim() : '';
  
  if (!summary) {
    alert('‚ö†Ô∏è Please paste your BrantSteele episode summary first!');
    return;
  }
  
  const seasonEl = document.getElementById('aiSeason');
  const episodeEl = document.getElementById('aiEpisode');
  const season = seasonEl ? seasonEl.value : '5';
  const episode = episodeEl ? episodeEl.value : '1';
  const episodeNum = parseInt(episode);
  
  // Get auditions if Episode 1
  let auditionsText = '';
  if (episode === '1' || episode === 1) {
    const auditionsInput = document.getElementById('episode-auditions-input');
    if (auditionsInput) {
      auditionsText = auditionsInput.value.trim();
    }
  }
  
  // üÜï GATHER PREVIOUS EPISODES FOR CONTEXT
  const previousEpisodes = [];
  for (let i = 1; i < episodeNum; i++) {
    const key = `td_episode_s${season}_e${i}`;
    const savedEpisode = localStorage.getItem(key);
    if (savedEpisode) {
      previousEpisodes.push({
        episode: i,
        transcript: savedEpisode
      });
    }
  }
  
  const generateBtn = document.getElementById('generate-episode-btn');
  const originalText = generateBtn.innerHTML;
  generateBtn.innerHTML = '‚è≥ Generating Episode...';
  generateBtn.disabled = true;
  
  try {
    const response = await fetch(EPISODE_WORKER_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        mode: 'episode',
        season: season,
        episode: episode,
        summaryText: summary,
        auditionsText: auditionsText,
        previousEpisodes: previousEpisodes  // üÜï Include previous episodes
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    const transcript = data.episodeTranscript || data.output_text || '';
    
    if (!transcript) {
      throw new Error('No episode transcript returned from AI');
    }
    
    document.getElementById('episode-input').value = transcript;
    saveEpisode();
    alert('‚úÖ Episode generated successfully!');
    
  } catch (error) {
    console.error('Error generating episode:', error);
    alert('‚ùå Error generating episode: ' + error.message);
  } finally {
    generateBtn.innerHTML = originalText;
    generateBtn.disabled = false;
  }
}
  
  // Render episode from transcript
  function renderEpisode() {
    const transcript = document.getElementById('episode-input').value;
    const container = document.getElementById('episode-rendered');
    
    if (!transcript.trim()) {
      container.innerHTML = `
        <div class="episode-empty">
          <div class="episode-empty-icon">üì∫</div>
          <div class="episode-empty-text">No episode to display.</div>
          <div style="margin-top: 16px; opacity: 0.7; font-size: 14px;">
            Paste a transcript and click "Render Episode" or generate one with AI!
          </div>
        </div>
      `;
      return;
    }
    
    const html = parseTranscript(transcript);
    container.innerHTML = html;
    container.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Parse transcript into beautiful HTML with animations
  function parseTranscript(text) {
    let html = '<div class="episode-content">';
    const lines = text.split('\n');
    let currentScene = '';
    let inConfessional = false;
    let inTribal = false;
    let lineIndex = 0; // For staggered animations
    
    lines.forEach((line) => {
      line = line.trim();
      if (!line) return;
      
      // Scene headers: [Scene: ...] or [Location...]
      if (line.match(/^\[.*\]$/)) {
        const sceneText = line.replace(/[\[\]]/g, '');
        
        // Check if this is a confessional
        const isConfessional = sceneText.toLowerCase().includes('confessional');
        
        // Close previous confessional if we're starting a new scene (confessional or not)
        if (inConfessional && (isConfessional || !sceneText.toLowerCase().includes('confessional'))) {
          html += '</div>';
          inConfessional = false;
        }
        
        // Start new confessional
        if (isConfessional) {
          html += '<div class="confessional" style="animation-delay: ' + (lineIndex * 0.05) + 's">';
          html += '<div class="confessional-label">üé• ' + escapeHtml(sceneText).toUpperCase() + '</div>';
          inConfessional = true;
          lineIndex++;
          return;
        }
        
        // Tribal Council detection with suspense
        if (sceneText.toLowerCase().includes('tribal') || sceneText.toLowerCase().includes('campfire ceremony')) {
          if (!inTribal) {
            html += '<div class="tribal-council" style="animation-delay: ' + (lineIndex * 0.05) + 's">';
            html += '<div class="tribal-header">üî• ' + escapeHtml(sceneText).toUpperCase() + ' üî•</div>';
            html += '<div class="tribal-suspense">‚è≥ The tension is palpable...</div>';
            inTribal = true;
            lineIndex++;
          }
          return;
        }
        
        // Close tribal if new scene
        if (inTribal && !sceneText.toLowerCase().includes('tribal') && !sceneText.toLowerCase().includes('vote') && !sceneText.toLowerCase().includes('campfire')) {
          html += '</div>';
          inTribal = false;
        }
        
        // Regular scene with sticky header
        if (currentScene) html += '</div>';
        html += '<div class="scene">';
        html += '<div class="scene-header scene-sticky" style="animation-delay: ' + (lineIndex * 0.05) + 's">üìç ' + escapeHtml(sceneText) + '</div>';
        currentScene = sceneText;
        lineIndex++;
        return;
      }
      
      // Dialogue: "Name: Text" - rendered as chat bubbles
      const dialogueMatch = line.match(/^([A-Z][a-zA-Z\s']+):\s*(.+)$/);
      if (dialogueMatch) {
        let [, character, dialogue] = dialogueMatch;
        character = character.trim();
        const charKey = character.toLowerCase();
        const avatar = getCharacterAvatar(charKey);
        
        html += '<div class="dialogue-line chat-bubble" style="animation-delay: ' + (lineIndex * 0.05) + 's">';
        html += `<div class="character-avatar">${avatar}</div>`;
        html += '<div class="dialogue-bubble">';
        html += `<div class="character-name">${escapeHtml(character)}</div>`;
        html += `<div class="dialogue-text">${escapeHtml(dialogue)}</div>`;
        html += '</div>';
        html += '</div>';
        lineIndex++;
        return;
      }
      
      // Elimination announcement - special styling in Tribal
      if (line.toLowerCase().includes('eliminated') || line.toLowerCase().includes('voted out')) {
        html += `<div class="eliminated-player" style="animation-delay: ' + (lineIndex * 0.05) + 's">`;
        html += `<div class="eliminated-message">${escapeHtml(line)}</div>`;
        html += `</div>`;
        lineIndex++;
        return;
      }
      
      // Vote reveals in Tribal Council with suspense animation
      if (inTribal && (line.toLowerCase().includes('vote') || line.toLowerCase().includes('marshmallow'))) {
        html += `<div class="vote-reveal suspense-reveal" style="animation-delay: ${lineIndex * 0.1}s">${escapeHtml(line)}</div>`;
        lineIndex++;
        return;
      }
      
      // Stage directions or other text
      html += `<div class="stage-direction" style="animation-delay: ${lineIndex * 0.05}s">${escapeHtml(line)}</div>`;
      lineIndex++;
    });
    
    // Close any open sections
    if (currentScene) html += '</div>';
    if (inConfessional) html += '</div>';
    if (inTribal) html += '</div>';
    
    html += '</div>';
    return html;
  }
  
  // Get character avatar (image or emoji)
  function getCharacterAvatar(characterName) {
    const key = characterName.toLowerCase().replace(/\s+/g, '-');
    const keySimple = characterName.toLowerCase().replace(/\s+/g, '');
    
    const paths = [
      `assets/avatars/${key}.png`,
      `assets/avatars/${keySimple}.png`,
      `assets/avatars/${characterName.toLowerCase()}.png`
    ];
    
    const emoji = CHARACTER_AVATARS[keySimple] || CHARACTER_AVATARS[key] || 'üë§';
    
    return `
      <img src="${paths[0]}" alt="${escapeHtml(characterName)}" 
        onerror="this.onerror=null; this.style.display='none'; this.nextElementSibling.style.display='flex';">
      <span class="character-avatar-fallback" style="display:none;">
        ${emoji}
      </span>
    `;
  }
  
  // Escape HTML to prevent XSS
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // Clear episode when season/episode changes
  let lastEpisodeKey = getEpisodeStorageKey();
  setInterval(() => {
    const currentKey = getEpisodeStorageKey();
    if (currentKey !== lastEpisodeKey) {
      const rendered = document.getElementById('episode-rendered');
      const input = document.getElementById('episode-input');
      if (rendered) rendered.innerHTML = '';
      if (input) input.value = '';
      lastEpisodeKey = currentKey;
      loadEpisode();
    }
  }, 1000);

// ========================================
// SEASON SETUP FUNCTIONS - FIXED VERSION (STANDALONE)
// Insert this code BEFORE the closing 
// This version includes all necessary functions
// ========================================

console.log("üöÄ Season Setup script tag reached!");

// Auto-load database from JSON if localStorage is empty
(function() {
  const existingDB = localStorage.getItem('players_database');
  if (!existingDB) {
    console.log("üì• No database in localStorage, attempting to load from players_database.json...");
    fetch('players_database.json')
      .then(r => r.json())
      .then(db => {
        localStorage.setItem('players_database', JSON.stringify(db, null, 2));
        console.log(`‚úÖ Database auto-loaded! ${db.players.length} players, ${db.franchise.totalSeasons} seasons`);
      })
      .catch(e => {
        console.warn("‚ö†Ô∏è Could not auto-load database:", e.message);
        console.log("Database will be empty until you import it manually or create profiles");
      });
  } else {
    const db = JSON.parse(existingDB);
    console.log(`‚úÖ Database already in localStorage (${db.players.length} players, ${db.franchise.totalSeasons} seasons)`);
  }
})();

// Use setTimeout to ensure ALL DOM elements are fully rendered AND database is loaded
setTimeout(function() {
(function() {
  console.log("üîß Season Setup: Initializing...");
  
  // Get Season Setup elements
  const seasonSetupSummary = document.getElementById("season-setup-summary");
  const analyzeCastBtn = document.getElementById("analyze-cast-btn");
  const castAnalysisResult = document.getElementById("cast-analysis-result");
  const createProfilesSection = document.getElementById("create-profiles-section");
  const createProfilesBtn = document.getElementById("create-profiles-btn");
  const exportDatabaseBtn = document.getElementById("export-database-btn");
  const importDatabaseBtn = document.getElementById("import-database-btn");
  const syncDevoteesBtn = document.getElementById("sync-devotees-btn");
  const rebuildRankingsBtn = document.getElementById("rebuild-rankings-btn");
  const importFileInput = document.getElementById("import-file-input");
  const databaseStatus = document.getElementById("database-status");

  console.log("üîß Elements check:");
  console.log("  - Button:", analyzeCastBtn ? "‚úÖ Found" : "‚ùå NOT FOUND");
  console.log("  - Textarea:", seasonSetupSummary ? "‚úÖ Found" : "‚ùå NOT FOUND");

  let analyzedCastData = null;

  // ========================================
  // HELPER: FORMAT PLAYER STORY
  // ========================================
  
  function formatPlayerStory(player, newSeasonStory, seasonNumber, seasonTheme) {
    // Count total seasons INCLUDING the current one being added
    const seasonDetails = player.seasonDetails || [];
    const isReturning = player.seasons && player.seasons.length > 0;
    const totalSeasons = isReturning ? seasonDetails.length + 1 : 1;
    
    // If player only has 1 season total (first time playing), use simple format
    if (totalSeasons === 1) {
      return newSeasonStory;
    }
    
    // Multi-season player: use structured format
    const existingStory = player.story || '';
    
    // Build new season section with proper formatting
    const newSection = `SEASON ${seasonNumber} ‚Äî ${seasonTheme}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nSEASON ${seasonNumber} ‚Äî ${seasonTheme}\n${newSeasonStory}`;
    
    // If no existing story, start fresh with structured format
    if (!existingStory) {
      return newSection;
    }
    
    // Check if this season already exists in the story (regeneration case)
    const seasonPattern = new RegExp(`SEASON\\s+${seasonNumber}\\s+[‚Äî\\-‚Äì]`, 'i');
    
    if (seasonPattern.test(existingStory)) {
      // Replace existing season section
      const sectionRegex = new RegExp(
        `SEASON\\s+${seasonNumber}\\s+[‚Äî\\-‚Äì][^\\n]*\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n[\\s\\S]*?(?=(?:\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\nSEASON|$))`,
        'gi'
      );
      return existingStory.replace(sectionRegex, newSection);
    } else {
      // Append new season
      return existingStory + '\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n' + newSection;
    }
  }

  // ========================================
  // HELPER: EXTRACT TRIBE INFORMATION
  // ========================================
  
  function extractPlayerTribes(episodes) {
    const playerTribes = {};
    
    if (!episodes || episodes.length === 0) return playerTribes;
    
    // Look for tribe assignments in early episodes (usually Episode 1)
    for (const ep of episodes.slice(0, 3)) { // Check first 3 episodes
      const summary = ep.summary || '';
      
      // Pattern 1: "=== TRIBE: TribeName ===" followed by player names
      const tribeMatches = summary.matchAll(/===\s*TRIBE[:\s]+([A-Za-z]+)\s*===\s*([\s\S]*?)(?=\n===|$)/gi);
      
      for (const match of tribeMatches) {
        const tribeName = match[1].trim();
        const memberBlock = match[2];
        
        // Extract player names from the block
        const lines = memberBlock.split('\n')
          .map(l => l.trim())
          .filter(l => l && !l.startsWith('===') && !l.startsWith('---'));
        
        for (const line of lines) {
          // Remove bullets, numbers, etc
          const cleanName = line.replace(/^[-*\d.)\s]+/, '').trim();
          if (cleanName.length > 2) {
            const playerId = slugify(cleanName);
            playerTribes[playerId] = tribeName;
          }
        }
      }
      
      // Pattern 2: Look for tribe mentions like "Galang members:", "Tadhana tribe:"
      const tribeLineMatches = summary.matchAll(/([A-Za-z]+)\s+(?:tribe|members?):\s*([^\n]+)/gi);
      
      for (const match of tribeLineMatches) {
        const tribeName = match[1].trim();
        const members = match[2];
        
        // Split by commas or "and"
        const names = members.split(/,|\sand\s/i).map(n => n.trim());
        
        for (const name of names) {
          const cleanName = name.replace(/^[-*\d.)\s]+/, '').trim();
          if (cleanName.length > 2 && !cleanName.toLowerCase().includes('member')) {
            const playerId = slugify(cleanName);
            playerTribes[playerId] = tribeName;
          }
        }
      }
      
      // Pattern 3: Inline mentions like "Mickey (Galang)" or "Ryan from Tadhana"
      const inlineMatches = summary.matchAll(/([A-Z][a-z]+)\s+(?:\(([A-Z][a-z]+)\)|from\s+([A-Z][a-z]+))/g);
      
      for (const match of inlineMatches) {
        const playerName = match[1];
        const tribeName = match[2] || match[3];
        
        if (playerName && tribeName) {
          const playerId = slugify(playerName);
          playerTribes[playerId] = tribeName;
        }
      }
    }
    
    console.log('üìã Extracted tribe assignments:', playerTribes);
    return playerTribes;
  }

  // ========================================
  // HELPER FUNCTIONS (copied from main script)
  // ========================================
  
  function slugify(name) {
    return name.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
  
  function parseCastFromSummary(text) {
    const castMatch = text.match(/===\s*CAST\s*\(ALL\)\s*===\s*([\s\S]*?)(?=\n===|$)/i);
    if (!castMatch) return [];
    
    const lines = castMatch[1].split('\n');
    const names = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('===') && !trimmed.startsWith('---')) {
        names.push(trimmed);
      }
    }
    return names;
  }

  // ========================================
  // AUTO-SAVE / AUTO-LOAD FOR SEASON BUILDER
  // ========================================
  
  let autoSaveTimeout = null;
  
  function getSeasonStorageKey(seasonNumber) {
    return `season_builder_s${seasonNumber}`;
  }
  
  function autoSaveSeasonBuilder() {
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(() => {
      try {
        const seasonNumber = parseInt(document.getElementById("sb-season-number").value) || 0;
        if (!seasonNumber) return;
        
        const data = {
          metadata: {
            title: document.getElementById("sb-season-title").value.trim(),
            subtitle: document.getElementById("sb-season-subtitle").value.trim(),
            theme: document.getElementById("sb-season-theme").value.trim(),
            emoji: document.getElementById("sb-season-emoji").value.trim(),
            episodeCount: parseInt(document.getElementById("sb-episode-count").value) || 17,
            castSize: parseInt(document.getElementById("sb-cast-size").value) || 16,
          },
          brantsteeleStats: document.getElementById("sb-brantsteele-stats").value.trim(),
          episodes: {},
          finale: {
            winner: document.getElementById("sb-finale-winner").value.trim(),
            runnerUp: document.getElementById("sb-finale-runnerup").value.trim(),
            finalVote: document.getElementById("sb-finale-vote").value.trim(),
            juryVotesText: document.getElementById("sb-jury-votes").value.trim(),
          },
          awards: {
            fanFavorite: document.getElementById("sb-award-fan").value.trim(),
            bestStrategic: document.getElementById("sb-award-strategic").value.trim(),
            mostChallengeWins: document.getElementById("sb-award-challenges").value.trim(),
          },
          savedAt: new Date().toISOString()
        };
        
        // Save episode summaries
        const episodeCount = data.metadata.episodeCount;
        for (let i = 1; i <= episodeCount; i++) {
          const textarea = document.getElementById(`sb-ep${i}-summary`);
          if (textarea) {
            data.episodes[i] = textarea.value.trim();
          }
        }
        
        // Save audition summaries
        const castSize = parseInt(document.getElementById("sb-cast-size").value) || 16;
        for (let i = 1; i <= castSize; i++) {
          const textarea = document.getElementById(`sb-audition${i}`);
          if (textarea) {
            data.auditions[i] = textarea.value.trim();
          }
        }
        
        const storageKey = getSeasonStorageKey(seasonNumber);
        localStorage.setItem(storageKey, JSON.stringify(data));
        
        // Show save indicator
        const indicator = document.getElementById("sb-save-indicator");
        if (indicator) {
          const savedDate = new Date().toLocaleTimeString();
          indicator.textContent = `‚úÖ Saved ${savedDate}`;
          indicator.style.display = 'block';
          setTimeout(() => {
            indicator.style.display = 'none';
          }, 2000);
        }
        
        console.log(`‚úÖ Auto-saved Season ${seasonNumber}`);
      } catch (e) {
        console.error('Auto-save error:', e);
      }
    }, 1000); // Debounce: save 1 second after last change
  }
  
  // Some older builds referenced this helper but didn't include it.
  // It (re)generates the episode textarea inputs used by the Season Builder.
  function generateSeasonBuilderEpisodeTextareas(count) {
    const countEl = document.getElementById('sb-episode-count');
    if (countEl && Number.isFinite(parseInt(count))) {
      countEl.value = String(parseInt(count));
    }

    // initializeEpisodeInputs() is the canonical implementation in this file.
    // It's a function declaration, so it's hoisted even if defined later.
    if (typeof initializeEpisodeInputs === 'function') {
      initializeEpisodeInputs();
    }
  }

  function loadSeasonBuilderData(seasonNumber) {
    try {
      const storageKey = getSeasonStorageKey(seasonNumber);
      const saved = localStorage.getItem(storageKey);
      
      if (!saved) {
        console.log(`No saved data for Season ${seasonNumber}`);
        return false;
      }
      
      const data = JSON.parse(saved);
      
      // Load metadata
      document.getElementById("sb-season-title").value = data.metadata.title || '';
      document.getElementById("sb-season-subtitle").value = data.metadata.subtitle || '';
      document.getElementById("sb-season-theme").value = data.metadata.theme || '';
      document.getElementById("sb-season-emoji").value = data.metadata.emoji || 'üéØ';
      document.getElementById("sb-episode-count").value = data.metadata.episodeCount || 17;
      document.getElementById("sb-cast-size").value = data.metadata.castSize || 16;
      
      // Load Brantsteele stats
      document.getElementById("sb-brantsteele-stats").value = data.brantsteeleStats || '';
      
      // Regenerate episode textareas if count changed
      const currentCount = parseInt(document.getElementById("sb-episode-count").value);
      generateSeasonBuilderEpisodeTextareas(currentCount);
      
      // Load episode summaries (use setTimeout to ensure textareas are rendered)
      setTimeout(() => {
        for (let i = 1; i <= currentCount; i++) {
          const textarea = document.getElementById(`sb-ep${i}-summary`);
          if (textarea && data.episodes[i]) {
            textarea.value = data.episodes[i];
          }
        }
      }, 100);
      
      // Load finale
      document.getElementById("sb-finale-winner").value = data.finale?.winner || '';
      document.getElementById("sb-finale-runnerup").value = data.finale?.runnerUp || '';
      document.getElementById("sb-finale-vote").value = data.finale?.finalVote || '';
      document.getElementById("sb-jury-votes").value = data.finale?.juryVotesText || '';
      
      // Load awards
      document.getElementById("sb-award-fan").value = data.awards?.fanFavorite || '';
      document.getElementById("sb-award-strategic").value = data.awards?.bestStrategic || '';
      document.getElementById("sb-award-challenges").value = data.awards?.mostChallengeWins || '';
      
      console.log(`‚úÖ Loaded Season ${seasonNumber} (saved ${data.savedAt})`);
      
      // Show load indicator
      const indicator = document.getElementById("sb-save-indicator");
      if (indicator) {
        indicator.textContent = `‚úÖ Loaded Season ${seasonNumber}`;
        indicator.style.display = 'block';
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 3000);
      }
      
      return true;
    } catch (e) {
      console.error('Load error:', e);
      return false;
    }
  }
  
  function clearCurrentSeasonData() {
    const seasonNumber = parseInt(document.getElementById("sb-season-number").value) || 0;
    if (!seasonNumber) {
      alert('Please enter a season number first');
      return;
    }
    
    if (!confirm(`Clear ALL saved data for Season ${seasonNumber}?\n\nThis will delete all episode summaries, metadata, and finale data.`)) {
      return;
    }
    
    const storageKey = getSeasonStorageKey(seasonNumber);
    localStorage.removeItem(storageKey);
    
    // Clear all fields
    document.getElementById("sb-season-title").value = '';
    document.getElementById("sb-season-subtitle").value = '';
    document.getElementById("sb-season-theme").value = '';
    document.getElementById("sb-season-emoji").value = 'üéØ';
    document.getElementById("sb-brantsteele-stats").value = '';
    document.getElementById("sb-finale-winner").value = '';
    document.getElementById("sb-finale-runnerup").value = '';
    document.getElementById("sb-finale-vote").value = '';
    document.getElementById("sb-jury-votes").value = '';
    document.getElementById("sb-award-fan").value = '';
    document.getElementById("sb-award-strategic").value = '';
    document.getElementById("sb-award-challenges").value = '';
    
    const episodeCount = parseInt(document.getElementById("sb-episode-count").value) || 17;
    for (let i = 1; i <= episodeCount; i++) {
      const textarea = document.getElementById(`sb-ep${i}-summary`);
      if (textarea) {
        textarea.value = '';
      }
    }
    
    alert(`‚úÖ Cleared Season ${seasonNumber} data`);
  }
  
  // Setup auto-save listeners
  function setupSeasonBuilderAutoSave() {
    const fields = [
      'sb-season-title', 'sb-season-subtitle', 'sb-season-theme', 'sb-season-emoji',
      'sb-episode-count', 'sb-cast-size', 'sb-brantsteele-stats', 
      'sb-finale-winner', 'sb-finale-runnerup', 'sb-finale-vote', 'sb-jury-votes', 
      'sb-award-fan', 'sb-award-strategic', 'sb-award-challenges'
    ];
    
    fields.forEach(id => {
      const field = document.getElementById(id);
      if (field) {
        field.addEventListener('input', autoSaveSeasonBuilder);
        field.addEventListener('change', autoSaveSeasonBuilder);
      }
    });
    
    // Episode textareas are added dynamically, so use event delegation
    document.addEventListener('input', (e) => {
      if (e.target.id && e.target.id.startsWith('sb-ep') && e.target.id.endsWith('-summary')) {
        autoSaveSeasonBuilder();
      }
      // Audition textareas
      if (e.target.id && e.target.id.startsWith('sb-audition')) {
        autoSaveSeasonBuilder();
      }
    });
    
    // Load data when season number changes
    const seasonNumberField = document.getElementById('sb-season-number');
    if (seasonNumberField) {
      seasonNumberField.addEventListener('change', (e) => {
        const seasonNumber = parseInt(e.target.value);
        if (seasonNumber) {
          loadSeasonBuilderData(seasonNumber);
        }
      });
    }
    
    // Try to load current season on page load
    const currentSeason = parseInt(seasonNumberField?.value);
    if (currentSeason) {
      setTimeout(() => {
        loadSeasonBuilderData(currentSeason);
      }, 500);
    }
  }

  // ========================================
  // FEATURE 0: COMPLETE SEASON BUILDER
  // ========================================
  
  const sbEpisodesContainer = document.getElementById("sb-episodes-container");
  const sbToggleEpisodesBtn = document.getElementById("sb-toggle-episodes");
  const sbGenerateAllBtn = document.getElementById("sb-generate-all");
  const sbPreviewDataBtn = document.getElementById("sb-preview-data");
  const sbProgress = document.getElementById("sb-progress");
  
  let episodesExpanded = false;
  
  // Initialize audition textareas (based on cast size)
  // Initialize episode textareas
  function initializeEpisodeInputs() {
    const seasonNumber = parseInt(document.getElementById("sb-season-number").value) || 0;
    const episodeCount = parseInt(document.getElementById("sb-episode-count").value) || 14;
    let html = '';
    
    for (let i = 1; i <= episodeCount; i++) {
      const isFirst = i === 1;
      const display = (isFirst || episodesExpanded) ? 'block' : 'none';
      const rows = isFirst ? 10 : 6;
      
      html += `
        <div class="sb-episode-input" data-episode="${i}" style="display: ${display}; margin-bottom: 16px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: 600; font-size: 14px;">
              Episode ${i}${isFirst ? ' (Must include CAST list)' : ''}
            </label>
            <span class="sb-episode-status" data-episode="${i}" style="font-size: 12px; opacity: 0.7;">
              Empty
            </span>
          </div>
          <textarea id="sb-ep${i}-summary" rows="${rows}" placeholder="Paste Episode ${i} summary here...${isFirst ? '\n\nMust include:\n=== CAST (ALL) ===\nName1\nName2\n...' : ''}"
            style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px;"></textarea>
        </div>
      `;
    }
    
    if (sbEpisodesContainer) {
      sbEpisodesContainer.innerHTML = html;
      
      // Load saved data if exists
      if (seasonNumber) {
        const storageKey = getSeasonStorageKey(seasonNumber);
        const saved = localStorage.getItem(storageKey);
        if (saved) {
          try {
            const data = JSON.parse(saved);
            // Populate episode textareas with saved content
            if (data.episodes) {
              for (let i = 1; i <= episodeCount; i++) {
                const textarea = document.getElementById(`sb-ep${i}-summary`);
                if (textarea && data.episodes[i]) {
                  textarea.value = data.episodes[i];
                  // Trigger status update
                  textarea.dispatchEvent(new Event('input'));
                }
              }
            }
          } catch (e) {
            console.error('Error loading saved episodes:', e);
          }
        }
      }
      
      // Add change listeners to update status
      for (let i = 1; i <= episodeCount; i++) {
        const textarea = document.getElementById(`sb-ep${i}-summary`);
        const status = document.querySelector(`.sb-episode-status[data-episode="${i}"]`);
        if (textarea && status) {
          textarea.addEventListener('input', () => {
            const charCount = textarea.value.trim().length;
            if (charCount === 0) {
              status.textContent = 'Empty';
              status.style.color = '#ff6464';
            } else if (charCount < 200) {
              status.textContent = `${charCount} chars (needs more)`;
              status.style.color = '#ffb347';
            } else {
              status.textContent = `‚úÖ ${charCount} chars`;
              status.style.color = '#4cffb3';
            }
          });
          
          // Trigger initial status update
          textarea.dispatchEvent(new Event('input'));
        }
      }
    }
  }
  
  // Toggle episodes visibility
  if (sbToggleEpisodesBtn) {
    sbToggleEpisodesBtn.addEventListener('click', () => {
      episodesExpanded = !episodesExpanded;
      const episodes = document.querySelectorAll('.sb-episode-input');
      episodes.forEach((ep, i) => {
        if (i === 0) return; // Always show Episode 1
        ep.style.display = episodesExpanded ? 'block' : 'none';
      });
      sbToggleEpisodesBtn.textContent = episodesExpanded ? 'Hide Episodes 2-14' : 'Show All Episodes';
    });
  }
  
  // Episode count change handler
  const episodeCountInput = document.getElementById("sb-episode-count");
  if (episodeCountInput) {
    episodeCountInput.addEventListener('change', initializeEpisodeInputs);
  }
  
  // Initialize on load
  initializeEpisodeInputs();
  setupSeasonBuilderAutoSave(); // Enable auto-save
  
  // Preview Data Button
  if (sbPreviewDataBtn) {
    sbPreviewDataBtn.addEventListener('click', () => {
      try {
        const data = collectSeasonBuilderData();
        const preview = JSON.stringify(data, null, 2);
        
        // Show in modal/alert
        const previewWindow = window.open('', 'Season Data Preview', 'width=800,height=600');
        previewWindow.document.write(`
          <html>
          <head>
            <title>Season ${data.metadata.seasonNumber} Preview</title>
            <style>
              body { 
                font-family: monospace; 
                padding: 20px; 
                background: #1a1a1a; 
                color: #fff; 
              }
              pre { 
                background: #000; 
                padding: 20px; 
                border-radius: 8px; 
                overflow: auto; 
                max-height: 80vh;
              }
              h2 { color: #4cffb3; }
            </style>
          </head>
          <body>
            <h2>Season ${data.metadata.seasonNumber} Data Preview</h2>
            <p>Episodes collected: ${data.episodes.length}</p>
            <p>Cast size: ${data.cast.length}</p>
            <pre>${escapeHtml(preview)}</pre>
          </body>
          </html>
        `);
      } catch (error) {
        alert(`‚ùå Preview error: ${error.message}`);
      }
    });
  }
  
  // Generate All Button (Main function - will be implemented in next steps)
  if (sbGenerateAllBtn) {
    sbGenerateAllBtn.addEventListener('click', () => {
      if (!confirm('Generate complete Season database?\n\nThis will:\n‚Ä¢ Parse all episode summaries\n‚Ä¢ Create seasonX-data.json\n‚Ä¢ Update all databases\n‚Ä¢ Generate voting analytics\n\nContinue?')) {
        return;
      }
      
      sbGenerateAllBtn.disabled = true;
      sbGenerateAllBtn.innerHTML = '‚è≥ Generating...';
      
      setTimeout(() => {
        try {
          generateCompleteSeasonDatabase();
        } catch (error) {
          console.error('Generation error:', error);
          showProgress(`
            <div style="padding: 20px; background: rgba(255,100,100,0.2); border: 2px solid #ff6464; border-radius: 16px;">
              <h3 style="color: #ff6464;">‚ùå Generation Failed</h3>
              <p>${error.message}</p>
            </div>
          `);
        } finally {
          sbGenerateAllBtn.disabled = false;
          sbGenerateAllBtn.innerHTML = '‚ö° Generate Complete Season Database';
        }
      }, 100);
    });
  }
  
  // Helper: Collect all Season Builder data
  function collectSeasonBuilderData() {
    const seasonNumber = parseInt(document.getElementById("sb-season-number").value);
    const episodeCount = parseInt(document.getElementById("sb-episode-count").value);
    
    // Collect metadata
    const metadata = {
      seasonNumber,
      title: document.getElementById("sb-season-title").value.trim() || `Total Drama Season ${seasonNumber}`,
      subtitle: document.getElementById("sb-season-subtitle").value.trim() || "",
      theme: document.getElementById("sb-season-theme").value.trim() || "",
      emoji: document.getElementById("sb-season-emoji").value.trim() || "üéØ",
      episodeCount,
      castSize: 0, // Will be determined from Episode 1 or Brantsteele stats
      jurySize: 0  // Will be calculated
    };
    
    // Collect Brantsteele stats (optional)
    const brantsteeleStats = document.getElementById("sb-brantsteele-stats").value.trim();
    
    // Collect episode summaries
    const episodes = [];
    for (let i = 1; i <= episodeCount; i++) {
      const textarea = document.getElementById(`sb-ep${i}-summary`);
      if (!textarea) {
        throw new Error(`Episode ${i} textarea not found`);
      }
      const summary = textarea.value.trim();
      if (!summary) {
        throw new Error(`Episode ${i} is empty! Please fill in all episodes.`);
      }
      episodes.push({
        episode: i,
        summary: summary
      });
    }
    
    // Get cast from Episode 1
    const cast = parseCastFromSummary(episodes[0].summary);
    if (cast.length === 0 && !brantsteeleStats) {
      throw new Error('No cast found in Episode 1! Make sure it has "=== CAST (ALL) ===" section, or provide Brantsteele stats.');
    }
    if (cast.length > 0) {
      metadata.castSize = cast.length;
    }
    
    // Collect finale data
    const finale = {
      winner: document.getElementById("sb-finale-winner").value.trim(),
      runnerUp: document.getElementById("sb-finale-runnerup").value.trim(),
      finalVote: document.getElementById("sb-finale-vote").value.trim(),
      juryVotesText: document.getElementById("sb-jury-votes").value.trim()
    };
    
    if (!finale.winner) throw new Error('Winner name is required!');
    if (!finale.runnerUp) throw new Error('Runner-up name(s) required!');
    if (!finale.finalVote) throw new Error('Final vote count is required!');
    
    // Parse jury votes
    const juryVotes = [];
    const juryLines = finale.juryVotesText.split('\n');
    for (const line of juryLines) {
      const match = line.match(/([A-Za-z]+)\s+voted\s+for\s+([A-Za-z]+)/i);
      if (match) {
        juryVotes.push({
          juror: match[1].trim(),
          votedFor: match[2].trim()
        });
      }
    }
    metadata.jurySize = juryVotes.length;
    
    // Collect awards
    const awards = {
      fanFavorite: document.getElementById("sb-award-fan").value.trim(),
      bestStrategic: document.getElementById("sb-award-strategic").value.trim(),
      mostChallengeWins: document.getElementById("sb-award-challenges").value.trim()
    };
    
    return {
      metadata,
      cast,
      episodes,
      finale: {
        ...finale,
        juryVotes
      },
      awards,
      brantsteeleStats // Include Brantsteele stats
    };
  }
  
  // Helper: Show progress messages
  function showProgress(html) {
    if (sbProgress) {
      sbProgress.style.display = 'block';
      sbProgress.innerHTML = html;
      sbProgress.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }
  
  // Main generation function (placeholder - will be fully implemented in next steps)
  function generateCompleteSeasonDatabase() {
    showProgress('<h3>‚ö° Starting generation...</h3>');
    
    // Step 1: Collect data
    showProgress('<h3>‚ö° Starting generation...</h3><p>üìù Collecting data...</p>');
    const data = collectSeasonBuilderData();
    
    // Step 2: Validation
    showProgress('<h3>‚ö° Starting generation...</h3><p>üìù Collecting data... ‚úÖ</p><p>‚úÖ Validating...</p>');
    console.log('Season Builder Data:', data);
    
    // TODO: Next steps will implement:
    // - Parse episode data (eliminations, votes, challenges)
    // - Generate season6-data.json
    // - Update seasons_database.json
    // - Update franchise_database.json
    // - Update players_database.json
    // - Update rankings_database.json
    // - Generate voting-analytics HTML
    
    // Call AI-first implementation
    generateCompleteSeasonDatabaseAI(data);
  }
  
  // AI-FIRST IMPLEMENTATION - Let AI do ALL the parsing
  async function generateCompleteSeasonDatabaseAI(data) {
    try {
      // Step 1: AI extracts ALL data from episodes
      showProgress('<h3>‚ö° Step 1/5: AI Data Extraction</h3><p>ü§ñ Having AI analyze all episodes and extract structured data...</p>');
      await sleep(500);
      
      const aiSeasonData = await getAISeasonData(data);
      
      if (!aiSeasonData) {
        throw new Error('AI data extraction failed. Check worker URL and try again.');
      }
      
      console.log('AI Extracted Data:', aiSeasonData);
      
      // Step 2: Generate season data file from AI output
      showProgress('<h3>‚ö° Step 2/5: Building Season File</h3><p>üìÑ Creating season' + data.metadata.seasonNumber + '-data.json from AI data...</p>');
      await sleep(500);
      
      const seasonData = buildSeasonDataFromAI(data, aiSeasonData);
      downloadJSON(seasonData, `season${data.metadata.seasonNumber}-data.json`);
      
      // Step 3: Update seasons_database
      showProgress('<h3>‚ö° Step 3/5: Updating Seasons Database</h3><p>üìö Adding Season ' + data.metadata.seasonNumber + ' to seasons_database.json...</p>');
      await sleep(500);
      
      updateSeasonsDatabase(seasonData);
      
      // Step 4: Update franchise_database
      showProgress('<h3>‚ö° Step 4/5: Updating Franchise Database</h3><p>üèõÔ∏è Adding records, milestones, and trends...</p>');
      await sleep(500);
      
      updateFranchiseDatabase(seasonData);
      
      // Step 5: Update players_database with AI-enhanced data
      showProgress('<h3>‚ö° Step 5/5: Updating Players Database</h3><p>üë• Creating/updating player profiles with AI narratives...</p>');
      await sleep(500);
      
      updatePlayersDatabase(seasonData);
      
      // Step 6: Recalculate rankings
      showProgress('<h3>‚ö° Bonus: Recalculating Rankings</h3><p>üèÜ Calculating scores for all players...</p>');
      await sleep(500);
      
      // Load current players database
      const playersDB = loadPlayerDatabase();
      
      if (!playersDB || !playersDB.players || playersDB.players.length === 0) {
        console.log('‚ö†Ô∏è No players in database, skipping rankings');
        showProgress('<h3>‚ö†Ô∏è Rankings Skipped</h3><p>No players in database</p>');
      } else {
        console.log(`‚úì Loaded ${playersDB.players.length} players for rankings`);
      }
      
      // Load old rankings from project file
      let oldRankingsData = null;
      try {
        console.log('üìÇ Attempting to load rankings_database.json from project...');
        const rankingsResponse = await fetch('rankings_database.json');
        if (rankingsResponse.ok) {
          oldRankingsData = await rankingsResponse.json();
          console.log(`‚úÖ Loaded old rankings from project file`);
        } else {
          console.log('‚ÑπÔ∏è rankings_database.json not found in project - will calculate fresh rankings');
        }
      } catch (e) {
        console.log('‚ÑπÔ∏è Could not load rankings file from project:', e.message);
      }
      
      // Load ranking overrides (if available)
      let overrides = null;
      try {
        const overridesResp = await fetch('ranking-overrides.json');
        if (overridesResp.ok) {
          overrides = await overridesResp.json();
          console.log(`‚úì Loaded ${Object.keys(overrides.overrides || {}).length} ranking overrides`);
        }
      } catch (e) {
        console.log('‚ÑπÔ∏è No ranking overrides found, using AI scores only');
      }
      
      // Get worker URL
      const workerUrl = getSeasonBuilderWorkerUrl();
      
      if (!workerUrl) {
        console.log('‚ö†Ô∏è Worker URL not set, skipping rankings update');
        showProgress('<h3>‚ö†Ô∏è Rankings Skipped</h3><p>Worker URL not set in settings. Rankings database not updated.</p>');
      } else if (!playersDB || !playersDB.players || playersDB.players.length === 0) {
        console.log('‚ö†Ô∏è No players in database, skipping rankings');
        showProgress('<h3>‚ö†Ô∏è Rankings Skipped</h3><p>No players in database</p>');
      } else {
        try {
          console.log('üì§ Sending rankings update request...');
          console.log('   - Mode: rankings-update');
          console.log('   - Players:', playersDB.players.length);
          console.log('   - Season:', seasonData.metadata?.seasonNumber);
          console.log('   - Old rankings:', oldRankingsData ? 'Found' : 'Not found');
          console.log('   - Placements:', aiSeasonData.placements?.length || 0);
          
          // Build proper season data structure for rankings
          const rankingsSeasonData = {
            seasonNumber: data.metadata.seasonNumber,
            seasonTitle: data.metadata.seasonTitle,
            placements: aiSeasonData.placements || []
          };
          
          // IMPORTANT: Use 'rankings-update' to preserve non-returnees
          // Use 'rankings-rebuild' once to recalculate everyone from scratch
          const rankingsResp = await fetch(workerUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              mode: "rankings-update",  // Preserves non-returnees
              playersDB,
              seasonData: rankingsSeasonData,  // Use properly structured data
              oldRankingsDB: oldRankingsData,
              overrides: overrides  // ‚Üê Pass overrides here
            })
          });
          
          console.log('üì• Rankings response status:', rankingsResp.status);
          
          if (!rankingsResp.ok) {
            // Try to get error details
            let errorDetails = '';
            try {
              const errorData = await rankingsResp.json();
              errorDetails = errorData.error || errorData.details || JSON.stringify(errorData);
              console.error('Rankings error details:', errorData);
            } catch (e) {
              errorDetails = await rankingsResp.text();
              console.error('Rankings error text:', errorDetails);
            }
            throw new Error(`Rankings update failed (${rankingsResp.status}): ${errorDetails}`);
          }
          
          const rankingsDB = await rankingsResp.json();
          
          if (rankingsDB.error) {
            throw new Error(rankingsDB.error);
          }
          
          console.log('‚úÖ Rankings response received:', rankingsDB);
          console.log(`   - Total players ranked: ${rankingsDB.rankings?.length || 0}`);
          
          // Save rankings to localStorage and download
          localStorage.setItem('rankings_database', JSON.stringify(rankingsDB, null, 2));
          console.log('‚úÖ Saved to localStorage');
          
          downloadJSON(rankingsDB, 'rankings_database.json');
          console.log('‚úÖ Download triggered for rankings_database.json');
          
          console.log('‚úÖ Rankings updated successfully');
        } catch (rankingsError) {
          console.error('Rankings update error:', rankingsError);
          showProgress('<h3>‚ö†Ô∏è Rankings Update Failed</h3><p>' + rankingsError.message + '</p>');
          // Continue anyway - don't fail the whole generation
        }
      }
      
      // Step 7: Generate voting analytics HTML
      showProgress('<h3>‚ö° Bonus: Generating Voting Analytics</h3><p>üó≥Ô∏è Creating HTML table...</p>');
      await sleep(500);
      
      const votingHTML = generateVotingAnalyticsHTML(seasonData);
      downloadText(votingHTML, `season${data.metadata.seasonNumber}-voting-table.html`);
      
      // SUCCESS!
      showProgress(`
        <div style="padding: 30px; background: linear-gradient(135deg, rgba(76,255,179,0.3), rgba(76,255,179,0.1)); border: 3px solid #4cffb3; border-radius: 20px; text-align: center;">
          <div style="font-size: 72px; margin-bottom: 16px;">üéâ</div>
          <h2 style="margin: 0 0 12px; color: #4cffb3;">Season ${data.metadata.seasonNumber} Complete!</h2>
          <div style="font-size: 16px; opacity: 0.95; margin-bottom: 24px;">
            All data extracted by AI and databases updated successfully
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin: 24px 0;">
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">season${data.metadata.seasonNumber}-data.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">seasons_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">franchise_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">players_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">rankings_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #ffb347;">üìã</div>
              <div style="font-size: 14px; opacity: 0.9;">voting-analytics.html<br/>(downloaded)</div>
            </div>
          </div>
          
          <div style="padding: 16px; background: rgba(76,255,179,0.15); border-radius: 12px; margin-top: 24px; font-size: 14px;">
            <strong>ü§ñ AI-Generated:</strong> All player data, placements, votes, and narratives extracted by AI
          </div>
          
          <div style="display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin-top: 24px;">
            <button onclick="location.reload()" class="btn btn-primary">
              ‚ú® Start Season ${data.metadata.seasonNumber + 1}
            </button>
            <button onclick="window.open('franchise.html', '_blank')" class="btn">
              üèõÔ∏è View Franchise
            </button>
            <button onclick="window.open('rankings.html', '_blank')" class="btn">
              üèÜ View Rankings
            </button>
          </div>
        </div>
      `);
      
    } catch (error) {
      console.error('Generation error:', error);
      showProgress(`
        <div style="padding: 20px; background: rgba(255,100,100,0.2); border: 2px solid #ff6464; border-radius: 16px;">
          <h3 style="color: #ff6464;">‚ùå Generation Failed</h3>
          <p><strong>Error:</strong> ${error.message}</p>
          <details style="margin-top: 12px;">
            <summary style="cursor: pointer;">Show Stack Trace</summary>
            <pre style="margin-top: 8px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px; font-size: 11px; overflow: auto;">${error.stack}</pre>
          </details>
        </div>
      `);
    }
  }
  
  // ========================================
  // HELPER FUNCTIONS
  // ========================================
  
  function normalizeWorkerUrl(raw) {
    let url = (raw || "").trim();
    if (!url) return "";
    if (!/^https?:\/\//i.test(url)) url = "https://" + url;
    return url.replace(/\/+$/, "");
  }
  
  function getWorkerUrl() {
    // Try to get from the analytics section (aiWorkerUrl)
    const workerUrlInput = document.getElementById("aiWorkerUrl");
    if (workerUrlInput && workerUrlInput.value.trim()) {
      return normalizeWorkerUrl(workerUrlInput.value.trim());
    }
    
    // Try to get from localStorage
    const stored = localStorage.getItem('workerUrl');
    if (stored) {
      return normalizeWorkerUrl(stored);
    }
    
    return '';
  }
  
  function getSeasonBuilderWorkerUrl() {
    // Try to get from Season Builder input
    const sbWorkerUrlInput = document.getElementById("seasonBuilderWorkerUrl");
    if (sbWorkerUrlInput && sbWorkerUrlInput.value.trim()) {
      return normalizeWorkerUrl(sbWorkerUrlInput.value.trim());
    }
    
    // Try to get from localStorage
    const stored = localStorage.getItem('SEASON_BUILDER_WORKER_URL');
    if (stored) {
      return normalizeWorkerUrl(stored);
    }
    
    return '';
  }
  
  function slugify(name) {
    return (name || "")
      .toLowerCase()
      .trim()
      .replace(/['".]/g, "")
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }
  
  // ========================================
  // AI DATA EXTRACTION
  // ========================================
  
  async function getAISeasonData(data) {
    const workerUrl = getSeasonBuilderWorkerUrl();
    
    if (!workerUrl) {
      throw new Error('Season Builder Worker URL not set! Please enter your Season Builder Worker URL in the Settings.');
    }
    
    try {
      // Build episode summaries
      const episodeSummaries = data.episodes.map(ep => ({
        episode: ep.episode,
        summary: ep.summary
      }));
      
      // Call AI Worker with full season data extraction mode
      const response = await fetch(workerUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          mode: 'season-data-extraction',
          season: data.metadata.seasonNumber,
          seasonTitle: data.metadata.title,
          episodes: episodeSummaries,
          finale: data.finale,
          awards: data.awards,
          metadata: data.metadata,
          brantsteeleStats: data.brantsteeleStats || null // Include Brantsteele stats
        })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`AI Worker failed (${response.status}): ${errorText}`);
      }
      
      const result = await response.json();
      return result;
      
    } catch (error) {
      console.error('AI data extraction error:', error);
      throw error;
    }
  }
  
  function buildSeasonDataFromAI(inputData, aiData) {
    const { metadata, finale } = inputData;
    
    // Use AI-extracted data to build complete season file
    const seasonData = {
      seasonNumber: metadata.seasonNumber,
      title: metadata.title,
      subtitle: metadata.subtitle,
      castSize: aiData.cast.length,
      episodeCount: metadata.episodeCount,
      jurySize: aiData.jury.length,
      
      winner: {
        name: aiData.winner.name,
        playerSlug: slugify(aiData.winner.name),
        vote: finale.finalVote,
        runnerUp: aiData.finalists.filter(f => f.placement > 1).map(f => f.name).join(' & '),
        keyStats: aiData.winner.keyStats,
        strategy: aiData.winner.strategy,
        legacy: aiData.winner.legacy
      },
      
      finalists: aiData.finalists.map(f => ({
        name: f.name,
        playerSlug: slugify(f.name),
        placement: f.placement,
        votes: f.juryVotes
      })),
      
      placements: aiData.placements.map(p => ({
        placement: p.placement,
        name: p.name,
        playerSlug: slugify(p.name),
        phase: p.phase,
        notes: p.notes,
        strategicRank: p.strategicRank,
        story: p.story,
        gameplayStyle: p.gameplayStyle,
        keyMoments: p.keyMoments || [],
        challengeWins: p.challengeWins || 0,
        immunityWins: p.immunityWins || 0,
        idolsFound: p.idolsFound || 0,
        votesReceived: p.votesReceived || 0,
        alliances: p.alliances || [],
        rivalries: p.rivalries || []
      })),
      
      votingHistory: aiData.votingHistory.map(vh => ({
        episode: vh.episode,
        eliminated: vh.eliminated,
        eliminatedSlug: vh.eliminated ? slugify(vh.eliminated) : null,
        votes: vh.votes.map(v => ({
          voter: v.voter,
          voterSlug: slugify(v.voter),
          target: v.target,
          targetSlug: slugify(v.target)
        }))
      })),
      
      finalTribalCouncil: {
        votes: finale.juryVotes.map(jv => ({
          juror: jv.juror,
          jurorSlug: slugify(jv.juror),
          votedFor: jv.votedFor,
          votedForSlug: slugify(jv.votedFor)
        }))
      },
      
      awards: {
        fanFavorite: {
          name: inputData.awards.fanFavorite,
          playerSlug: slugify(inputData.awards.fanFavorite)
        },
        bestStrategic: {
          name: inputData.awards.bestStrategic,
          playerSlug: slugify(inputData.awards.bestStrategic)
        },
        mostChallengeWins: {
          name: inputData.awards.mostChallengeWins,
          playerSlug: slugify(inputData.awards.mostChallengeWins),
          detail: `${aiData.placements.find(p => p.name.toLowerCase() === inputData.awards.mostChallengeWins.toLowerCase())?.challengeWins || 0} total`
        }
      },
      
      seasonNarrative: aiData.seasonNarrative,
      theme: metadata.theme,
      status: "Complete",
      castPhotoPath: `assets/cast/s${metadata.seasonNumber}-cast.png`,
      emoji: metadata.emoji
    };
    
    return seasonData;
  }
  
  // ========================================
  // PARSERS
  // ========================================
  
  function parseAllEpisodes(episodes, cast) {
    const parsedEpisodes = [];
    const activePlayers = new Set(cast);
    
    for (const ep of episodes) {
      const parsed = parseEpisodeSummary(ep.summary, ep.episode, activePlayers);
      parsedEpisodes.push(parsed);
      
      // Remove eliminated players from active set
      if (parsed.eliminated) {
        activePlayers.delete(parsed.eliminated);
      }
    }
    
    return parsedEpisodes;
  }
  
  function parseEpisodeSummary(text, episodeNum, activePlayers) {
    const result = {
      episode: episodeNum,
      title: null,
      eliminated: null,
      eliminatedSlug: null,
      votes: [],
      challengeWinners: [],
      immunityWinners: [],
      idolPlays: []
    };
    
    // Parse episode title from META block
    // Format: "EPISODE 2-Serpent Turf" or "EPISODE: 2-Serpent Turf"
    const titleMatch = text.match(/EPISODE[\s:]*\d+[-‚Äì‚Äî]\s*(.+?)(?:\n|$)/i);
    if (titleMatch) {
      result.title = titleMatch[1].trim();
    }
    
    // Parse eliminated player
    // Look for patterns like: "X was voted out", "X was eliminated", "Boot: X"
    const bootPatterns = [
      /(?:voted out|eliminated|boot):\s*([A-Z][a-z]+)/i,
      /([A-Z][a-z]+)\s+(?:was voted out|was eliminated|got voted out)/i,
      /Eliminated:\s*([A-Z][a-z]+)/i
    ];
    
    for (const pattern of bootPatterns) {
      const match = text.match(pattern);
      if (match) {
        result.eliminated = match[1].trim();
        result.eliminatedSlug = slugify(match[1].trim());
        break;
      }
    }
    
    // Parse voting chart
    // Format: "Player1 voted Player2" or "Votes: Player1->Player2, ..."
    const votePattern = /([A-Z][a-z]+)\s+voted\s+(?:for\s+)?([A-Z][a-z]+)/gi;
    let voteMatch;
    while ((voteMatch = votePattern.exec(text)) !== null) {
      const voter = voteMatch[1].trim();
      const target = voteMatch[2].trim();
      
      // Only add if both are active players or in cast
      if (activePlayers.has(voter)) {
        result.votes.push({
          voter: voter,
          voterSlug: slugify(voter),
          target: target,
          targetSlug: slugify(target)
        });
      }
    }
    
    // Parse challenge winners
    const challengePattern = /(?:Challenge Winner|won (?:the )?challenge):\s*([A-Z][a-z]+)/gi;
    let challengeMatch;
    while ((challengeMatch = challengePattern.exec(text)) !== null) {
      result.challengeWinners.push(challengeMatch[1].trim());
    }
    
    // Parse immunity winners
    const immunityPattern = /(?:Immunity Winner|won (?:individual )?immunity):\s*([A-Z][a-z]+)/gi;
    let immunityMatch;
    while ((immunityMatch = immunityPattern.exec(text)) !== null) {
      result.immunityWinners.push(immunityMatch[1].trim());
    }
    
    // Parse idol plays
    const idolPattern = /([A-Z][a-z]+)\s+played\s+(?:an?\s+)?(?:hidden\s+)?idol/gi;
    let idolMatch;
    while ((idolMatch = idolPattern.exec(text)) !== null) {
      result.idolPlays.push(idolMatch[1].trim());
    }
    
    return result;
  }
  
  // ========================================
  // SEASON DATA GENERATION
  // ========================================
  
  function generateSeasonDataJSON(data, parsedEpisodes) {
    const { metadata, cast, episodes, finale, awards } = data;
    
    // Calculate placements
    const placements = calculatePlacements(cast, parsedEpisodes, finale);
    
    // Build finale finalists
    const finalists = [];
    const runnerUps = finale.runnerUp.split(',').map(s => s.trim());
    const allFinalists = [finale.winner, ...runnerUps];
    const voteCounts = finale.finalVote.split('-').map(Number);
    
    allFinalists.forEach((name, i) => {
      finalists.push({
        name: name,
        playerSlug: slugify(name),
        placement: i + 1,
        votes: voteCounts[i] || 0
      });
    });
    
    // Build season data JSON
    const seasonData = {
      seasonNumber: metadata.seasonNumber,
      title: metadata.title,
      subtitle: metadata.subtitle,
      castSize: metadata.castSize,
      episodeCount: metadata.episodeCount,
      jurySize: metadata.jurySize,
      winner: {
        name: finale.winner,
        playerSlug: slugify(finale.winner),
        vote: finale.finalVote,
        runnerUp: runnerUps.join(' & '),
        keyStats: `${voteCounts[0]} jury votes to win`,
        strategy: "TBD - Update manually",
        legacy: "TBD - Update manually"
      },
      finalists: finalists,
      placements: placements,
      votingHistory: parsedEpisodes.map(ep => ({
        episode: ep.episode,
        eliminated: ep.eliminated,
        eliminatedSlug: ep.eliminatedSlug,
        votes: ep.votes
      })),
      finalTribalCouncil: {
        votes: finale.juryVotes.map(jv => ({
          juror: jv.juror,
          jurorSlug: slugify(jv.juror),
          votedFor: jv.votedFor,
          votedForSlug: slugify(jv.votedFor)
        }))
      },
      awards: {
        fanFavorite: {
          name: awards.fanFavorite,
          playerSlug: slugify(awards.fanFavorite)
        },
        bestStrategic: {
          name: awards.bestStrategic,
          playerSlug: slugify(awards.bestStrategic)
        },
        mostChallengeWins: {
          name: awards.mostChallengeWins,
          playerSlug: slugify(awards.mostChallengeWins),
          detail: "TBD - count from episodes"
        }
      },
      theme: metadata.theme,
      status: "Complete",
      castPhotoPath: `assets/cast/s${metadata.seasonNumber}-cast.png`,
      emoji: metadata.emoji
    };
    
    return seasonData;
  }
  
  function calculatePlacements(cast, parsedEpisodes, finale) {
    const placements = [];
    const eliminated = [];
    
    // Track eliminations in order
    parsedEpisodes.forEach((ep, i) => {
      if (ep.eliminated) {
        eliminated.push({
          episode: ep.episode,
          name: ep.eliminated,
          placement: cast.length - eliminated.length
        });
      }
    });
    
    // Add finalists
    const runnerUps = finale.runnerUp.split(',').map(s => s.trim());
    const allFinalists = [finale.winner, ...runnerUps];
    const voteCounts = finale.finalVote.split('-').map(Number);
    
    allFinalists.forEach((name, i) => {
      placements.push({
        placement: i + 1,
        name: name,
        playerSlug: slugify(name),
        phase: i === 0 ? "Winner" : "Finalist",
        notes: `${i === 0 ? 'Winner' : 'Finalist'} - ${voteCounts[i] || 0} jury votes`
      });
    });
    
    // Add eliminated players (reverse order = highest placement first)
    eliminated.reverse().forEach((elim, i) => {
      const placement = allFinalists.length + i + 1;
      placements.push({
        placement: placement,
        name: elim.name,
        playerSlug: slugify(elim.name),
        phase: placement <= cast.length / 2 ? "Juror" : "Pre-Merge",
        notes: `Eliminated Episode ${elim.episode}`
      });
    });
    
    return placements;
  }
  
  // ========================================
  // DATABASE UPDATES
  // ========================================
  
  function updateSeasonsDatabase(seasonData) {
    let seasonsDB;
    try {
      const raw = localStorage.getItem('seasons_database');
      seasonsDB = raw ? JSON.parse(raw) : { franchise: {}, seasons: [] };
    } catch (e) {
      seasonsDB = { franchise: {}, seasons: [] };
    }
    
    // Check if season already exists
    const existingIndex = seasonsDB.seasons.findIndex(s => s.seasonNumber === seasonData.seasonNumber);
    
    const newSeasonEntry = {
      seasonNumber: seasonData.seasonNumber,
      title: seasonData.title,
      subtitle: seasonData.subtitle,
      castSize: seasonData.castSize,
      episodeCount: seasonData.episodeCount,
      winner: seasonData.winner,
      awards: seasonData.awards,
      theme: seasonData.theme,
      status: seasonData.status,
      castPhotoPath: seasonData.castPhotoPath,
      emoji: seasonData.emoji
    };
    
    if (existingIndex >= 0) {
      // Update existing season
      seasonsDB.seasons[existingIndex] = newSeasonEntry;
      console.log(`‚úÖ Updated existing Season ${seasonData.seasonNumber}`);
    } else {
      // Add new season
      seasonsDB.seasons.push(newSeasonEntry);
      console.log(`‚úÖ Added new Season ${seasonData.seasonNumber}`);
    }
    
    // Update franchise metadata
    seasonsDB.franchise.totalSeasons = seasonsDB.seasons.length;
    seasonsDB.franchise.name = "DC Franchise Database";
    seasonsDB.franchise.description = "Total Drama franchise statistics and season data";
    
    // Save
    localStorage.setItem('seasons_database', JSON.stringify(seasonsDB, null, 2));
    downloadJSON(seasonsDB, 'seasons_database.json');
    
    console.log('‚úÖ seasons_database.json updated');
  }
  
  function updateFranchiseDatabase(seasonData) {
    let franchiseDB;
    try {
      const raw = localStorage.getItem('franchise_database');
      franchiseDB = raw ? JSON.parse(raw) : createEmptyFranchiseDB();
    } catch (e) {
      franchiseDB = createEmptyFranchiseDB();
    }
    
    // Check if this season already exists in the database
    const seasonExists = franchiseDB.champions.some(c => c.season === seasonData.seasonNumber);
    
    if (seasonExists) {
      // Remove existing entries for this season
      franchiseDB.champions = franchiseDB.champions.filter(c => c.season !== seasonData.seasonNumber);
      franchiseDB.trends.winningStrategies = franchiseDB.trends.winningStrategies.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.trends.castComposition = franchiseDB.trends.castComposition.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.trends.finaleVoteMargins = franchiseDB.trends.finaleVoteMargins.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.trends.majorTwists = franchiseDB.trends.majorTwists.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.fanFavorites = franchiseDB.fanFavorites.filter(s => s.season !== seasonData.seasonNumber);
      
      console.log(`üîÑ Replacing existing Season ${seasonData.seasonNumber} data in franchise database`);
    }
    
    // Update stats (recalculate from scratch)
    const uniqueSeasons = new Set(franchiseDB.champions.map(c => c.season));
    uniqueSeasons.add(seasonData.seasonNumber);
    franchiseDB.franchiseStats.totalSeasons = uniqueSeasons.size;
    
    // Add champion
    franchiseDB.champions.push({
      season: seasonData.seasonNumber,
      winner: seasonData.winner.name,
      playerSlug: seasonData.winner.playerSlug,
      strategy: seasonData.winner.strategy,
      finalVote: seasonData.winner.vote,
      runnerUp: seasonData.winner.runnerUp,
      keyStats: seasonData.winner.keyStats,
      legacy: seasonData.winner.legacy,
      votesAgainst: 0 // Calculate manually later
    });
    
    // Add to trends
    franchiseDB.trends.winningStrategies.push({
      season: seasonData.seasonNumber,
      strategy: seasonData.winner.strategy,
      winner: seasonData.winner.name
    });
    
    franchiseDB.trends.castComposition.push({
      season: seasonData.seasonNumber,
      composition: `${seasonData.castSize} players`
    });
    
    franchiseDB.trends.finaleVoteMargins.push({
      season: seasonData.seasonNumber,
      vote: seasonData.winner.vote,
      winner: seasonData.winner.name
    });
    
    franchiseDB.trends.majorTwists.push({
      season: seasonData.seasonNumber,
      twist: seasonData.theme || "TBD"
    });
    
    // Add fan favorite
    franchiseDB.fanFavorites.push({
      season: seasonData.seasonNumber,
      player: seasonData.awards.fanFavorite.name,
      playerSlug: seasonData.awards.fanFavorite.playerSlug,
      description: "Fan favorite"
    });
    
    // Save
    localStorage.setItem('franchise_database', JSON.stringify(franchiseDB, null, 2));
    downloadJSON(franchiseDB, 'franchise_database.json');
    
    console.log('‚úÖ franchise_database.json updated');
  }
  
  function createEmptyFranchiseDB() {
    return {
      franchiseStats: { totalSeasons: 0, totalEpisodes: 0, uniquePlayers: 0, totalAppearances: 0 },
      champions: [],
      records: { challengeRecords: [], votingRecords: [], strategicRecords: [], socialRecords: [] },
      fanFavorites: [],
      multiSeasonPlayers: { threeSeasons: [], twoSeasons: [] },
      trends: { winningStrategies: [], castComposition: [], finaleVoteMargins: [], majorTwists: [] },
      milestones: [],
      careerLeaders: { challengeDominance: [], socialGame: [], strategicImpact: {} },
      evolution: {}
    };
  }
  
  function updatePlayersDatabase(seasonData) {
    const db = loadPlayerDatabase();
    const season = seasonData.seasonNumber;
    
    // Banned IDs for fake players
    const bannedIds = [
      'votes-to-win', 'jury-votes', 'elimination-order', 'everyone', 'eliminate',
      'winner', 'finalist', 'juror', 'pre-juror', 'voted-out', 'medevac'
    ];
    
    // Extract tribe assignments from episodes
    const playerTribes = extractPlayerTribes(seasonData.episodes || []);
    
    // Track which players we've already processed to prevent duplicates
    const processedThisSeason = new Set();
    
    // Process each player in placements
    seasonData.placements.forEach(placement => {
      const name = placement.name;
      
      // Generate clean slug from name
      const id = slugify(name);
      
      // Validate player ID - skip obvious fakes
      if (!id || id.length < 2) {
        console.warn(`‚ö†Ô∏è Skipping invalid player ID: "${id}" from name "${name}"`);
        return;
      }
      
      // Skip fake players from parsing errors
      const isFake = bannedIds.some(banned => id.includes(banned) && id !== name.toLowerCase());
      if (isFake) {
        console.warn(`‚ö†Ô∏è Skipping fake player: "${name}" (ID: "${id}")`);
        return;
      }
      
      // Prevent duplicate processing in same season
      if (processedThisSeason.has(id)) {
        console.warn(`‚ö†Ô∏è Player "${name}" already processed for Season ${season}, skipping duplicate`);
        return;
      }
      processedThisSeason.add(id);
      
      let player = db.players.find(p => p.id === id);
      
      // Get AI-generated stats from placement
      const challengeWins = placement.challengeWins || 0;
      const immunityWins = placement.immunityWins || 0;
      const idolsFound = placement.idolsFound || 0;
      const votesReceived = placement.votesReceived || 0;
      const strategicRank = placement.strategicRank || 0;
      
      // Get jury votes if finalist
      const juryVotes = placement.placement <= 3 
        ? (seasonData.finalists?.find(f => slugify(f.name) === id)?.juryVotes || 0) 
        : 0;
      
      if (!player) {
        // Create new player
        player = {
          id,
          name,
          seasons: [season],
          totalSeasons: 1,
          bestPlacement: placement.placement,
          wins: placement.placement === 1 ? 1 : 0,
          totalChallengeWins: challengeWins,
          totalImmunityWins: immunityWins,
          totalRewardWins: 0, // Not tracked yet
          totalVotesAgainst: votesReceived,
          totalIdolsFound: idolsFound,
          totalJuryVotes: juryVotes,
          tier: "Unranked",
          badges: placement.placement === 1 ? [`S${season} Winner`] : [],
          seasonDetails: [],
          story: placement.story || `Competed in Season ${season}`
        };
        db.players.push(player);
        console.log(`‚úÖ Created new player: ${name} (ID: ${id})`);
      } else {
        // Update existing player
        
        // Initialize arrays if they don't exist
        if (!Array.isArray(player.seasons)) player.seasons = [];
        if (!Array.isArray(player.seasonDetails)) player.seasonDetails = [];
        if (!Array.isArray(player.badges)) player.badges = [];
        
        // Check if this season is already in their record
        const seasonIndex = player.seasonDetails.findIndex(s => s.season === season);
        if (seasonIndex >= 0) {
          console.log(`üîÑ Updating existing Season ${season} data for ${name}`);
          // Remove old season data to prevent accumulation
          const oldDetail = player.seasonDetails[seasonIndex];
          player.totalChallengeWins -= (oldDetail.challengeWins || 0);
          player.totalImmunityWins -= (oldDetail.immunityWins || 0);
          player.totalVotesAgainst -= (oldDetail.votesReceived || 0);
          player.totalIdolsFound -= (oldDetail.idolsFound || 0);
          player.totalJuryVotes -= (oldDetail.juryVotes || 0);
          
          // Remove season from list if it's there
          player.seasons = player.seasons.filter(s => s !== season);
          player.seasonDetails = player.seasonDetails.filter(s => s.season !== season);
          player.totalSeasons = player.seasons.length;
          
          // Initialize badges array if it doesn't exist
          if (!Array.isArray(player.badges)) {
            player.badges = [];
          }
          
          // Remove duplicate win badges
          player.badges = player.badges.filter(b => b !== `S${season} Winner`);
          if (player.wins > 0 && oldDetail.placement === 1) {
            player.wins--;
          }
        }
        
        // Add season
        if (!player.seasons.includes(season)) {
          player.seasons.push(season);
          player.totalSeasons++;
        }
        
        // Update best placement
        if (placement.placement < player.bestPlacement) {
          player.bestPlacement = placement.placement;
        }
        
        // Add win if applicable
        if (placement.placement === 1) {
          player.wins++;
          const badgeText = `S${season} Winner`;
          if (!player.badges.includes(badgeText)) {
            player.badges.push(badgeText);
          }
        }
        
        // Add this season's stats
        player.totalChallengeWins += challengeWins;
        player.totalImmunityWins += immunityWins;
        player.totalVotesAgainst += votesReceived;
        player.totalIdolsFound += idolsFound;
        player.totalJuryVotes += juryVotes;
        
        // Update story with proper formatting (multi-season vs single-season)
        if (placement.story) {
          const seasonTheme = seasonData.metadata?.theme || seasonData.metadata?.title || 'Unknown';
          player.story = formatPlayerStory(player, placement.story, season, seasonTheme);
        }
        
        console.log(`‚úÖ Updated player: ${name} - Now ${player.totalSeasons} season(s), ${player.wins} win(s)`);
      }
      
      // Add/update season details with AI-generated data
      const seasonDetail = {
        season,
        placement: placement.placement,
        status: placement.phase,
        tribe: playerTribes[id] || "Unknown", // Use extracted tribe
        challengeWins: challengeWins,
        immunityWins: immunityWins,
        rewardWins: 0, // Not tracked yet
        votesReceived: votesReceived,
        idolsFound: idolsFound,
        strategicRank: strategicRank,
        juryVotes: juryVotes,
        finalVote: placement.placement === 1 ? seasonData.winner.vote : "",
        advantages: [],
        notes: [placement.notes],
        // Add AI-generated narrative data
        gameplayStyle: placement.gameplayStyle || "",
        keyMoments: placement.keyMoments || [],
        alliances: placement.alliances || [],
        rivalries: placement.rivalries || []
      };
      
      player.seasonDetails.push(seasonDetail);
    });
    
    // Remove any duplicate/fake players that slipped through
    db.players = db.players.filter(player => {
      const isFake = bannedIds.some(banned => player.id.includes(banned));
      if (isFake) {
        console.warn(`üóëÔ∏è Removing fake player from database: ${player.id}`);
        return false;
      }
      return true;
    });
    
    savePlayerDatabase(db);
    downloadJSON(db, 'players_database.json');
    
    console.log(`‚úÖ players_database.json updated (${db.players.length} total players)`);
  }
  
  function countVotesAgainst(playerName, votingHistory) {
    let count = 0;
    votingHistory.forEach(ep => {
      ep.votes.forEach(vote => {
        if (vote.target === playerName) {
          count++;
        }
      });
    });
    return count;
  }
  
  function updateRankingsDatabase(seasonData, oldRankingsData = null) {
    const db = loadPlayerDatabase();
    const currentSeason = seasonData.seasonNumber;
    
    // Load existing rankings
    // oldRankingsData can be passed in from the main generation function
    let oldRankings = {};
    
    if (oldRankingsData && oldRankingsData.rankings) {
      // Use passed-in rankings (from project file)
      oldRankingsData.rankings.forEach(r => {
        oldRankings[r.playerId] = r;
      });
      console.log(`üìã Loaded ${Object.keys(oldRankings).length} existing rankings from project file`);
    } else {
      // Fallback: Try localStorage
      try {
        const oldDB = JSON.parse(localStorage.getItem('rankings_database') || '{}');
        if (oldDB.rankings && Array.isArray(oldDB.rankings)) {
          oldDB.rankings.forEach(r => {
            oldRankings[r.playerId] = r;
          });
          console.log(`üìã Loaded ${Object.keys(oldRankings).length} existing rankings from localStorage`);
        } else {
          console.log('‚ÑπÔ∏è No previous rankings - will calculate fresh for everyone');
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Could not load old rankings:', e.message);
        console.log('‚ÑπÔ∏è Will calculate fresh rankings for all players');
      }
    }
    
    // Get list of players who competed in current season
    const currentSeasonPlayers = new Set(
      seasonData.placements.map(p => slugify(p.name))
    );
    
    const rankings = [];
    
    // Filter out duplicate/invalid players
    const validPlayers = db.players.filter(player => {
      const id = player.id.toLowerCase();
      if (id.includes('votes-to-win') || 
          id.includes('juror-voted') ||
          id.includes('finalist-') ||
          id === 'everyone' ||
          id === 'eliminate') {
        console.warn(`Skipping invalid player: ${player.id}`);
        return false;
      }
      return true;
    });
    
    // Process each valid player
    validPlayers.forEach(player => {
      const playedThisSeason = currentSeasonPlayers.has(player.id);
      
      if (playedThisSeason || !oldRankings[player.id]) {
        // RECALCULATE: New players or returnees who played this season
        const score = calculatePlayerScore(player);
        const tier = calculateTier(score);
        
        rankings.push({
          playerId: player.id,
          tier: tier,
          score: score,
          rank: 0, // Will be set after sorting
          title: generatePlayerTitle(player),
          emoji: getPlayerEmoji(player),
          reasoning: generateReasoning(player),
          strengths: generateStrengths(player),
          weaknesses: generateWeaknesses(player),
          avgPlacement: calculateAvgPlacement(player),
          winRate: Math.round((player.wins / player.totalSeasons) * 100),
          seasons: player.seasons,
          placements: player.seasonDetails.map(s => s.placement),
          challengeWins: player.totalChallengeWins,
          votesAgainst: player.totalVotesAgainst,
          juryVotes: player.totalJuryVotes,
          idolsFound: player.totalIdolsFound,
          status: `Competed in ${player.totalSeasons} season(s)`
        });
        
        console.log(`‚úÖ Recalculated: ${player.name} (played S${currentSeason})`);
      } else {
        // PRESERVE: Players who didn't compete this season
        const oldRank = oldRankings[player.id];
        rankings.push({
          ...oldRank,
          rank: 0 // Will be reassigned based on score
        });
        
        console.log(`üìã Preserved: ${player.name} (didn't play S${currentSeason})`);
      }
    });
    
    // Sort by score (descending)
    rankings.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      // Tiebreaker: better avg placement
      return a.avgPlacement - b.avgPlacement;
    });
    
    // Assign new ranks
    rankings.forEach((r, i) => {
      r.rank = i + 1;
    });
    
    // Build rankings database
    const rankingsDB = {
      metadata: {
        name: "DC Franchise Rankings Database",
        version: `${currentSeason}.0`,
        lastUpdated: new Date().toISOString().split('T')[0],
        description: `Complete player rankings after Season ${currentSeason}`,
        totalPlayers: rankings.length,
        source: `Season ${currentSeason} integration`
      },
      scoringSystem: {
        placement: "40% - Average finish position across all seasons (lower placement = higher score)",
        winRate: "20% - Championships won / appearances",
        challengePerformance: "15% - Individual immunity + reward wins (normalized per season)",
        socialGame: "15% - Votes received (lower = better), jury votes earned",
        strategicImpact: "10% - Idol plays, blindsides executed, game control"
      },
      tiers: {
        "S+": { name: "TIER S+ ‚Äì Elite Winners", description: "91+ ‚Ä¢ Franchise legends", scoreRange: [91, 100] },
        "S": { name: "TIER S ‚Äì Championship Caliber", description: "81-90 ‚Ä¢ Top-tier threats", scoreRange: [81, 90] },
        "A": { name: "TIER A ‚Äì Elite Threats", description: "72-80 ‚Ä¢ Deep runs", scoreRange: [72, 80] },
        "B": { name: "TIER B ‚Äì Above Average", description: "61-71 ‚Ä¢ Solid gameplay", scoreRange: [61, 71] },
        "C": { name: "TIER C ‚Äì Average", description: "51-60 ‚Ä¢ Mid-game players", scoreRange: [51, 60] },
        "D": { name: "TIER D ‚Äì Below Average", description: "36-50 ‚Ä¢ Early exits", scoreRange: [36, 50] }
      },
      rankings
    };
    
    localStorage.setItem('rankings_database', JSON.stringify(rankingsDB, null, 2));
    downloadJSON(rankingsDB, 'rankings_database.json');
    
    console.log(`‚úÖ rankings_database.json updated (${rankings.length} valid players)`);
  }
  
  // Helper functions for enhanced rankings
  function getPlayerEmoji(player) {
    if (player.wins >= 2) return "üëë";
    if (player.wins === 1) return "‚≠ê";
    if (player.bestPlacement === 2) return "ü•à";
    if (player.bestPlacement === 3) return "ü•â";
    if (player.totalChallengeWins >= 10) return "üí™";
    return "‚≠ê";
  }
  
  function generateStrengths(player) {
    const strengths = [];
    
    if (player.wins >= 1) strengths.push("Winner pedigree");
    if (player.totalChallengeWins / player.totalSeasons >= 3) strengths.push("Challenge prowess");
    if (player.totalVotesAgainst / player.totalSeasons < 5) strengths.push("Low target profile");
    if (player.totalIdolsFound >= 2) strengths.push("Strategic gameplay");
    if (calculateAvgPlacement(player) <= 3) strengths.push("Consistent deep runs");
    
    return strengths;
  }
  
  function generateWeaknesses(player) {
    const weaknesses = [];
    
    if (player.totalVotesAgainst / player.totalSeasons > 15) weaknesses.push("High threat perception");
    if (player.totalSeasons >= 3 && player.wins === 0) weaknesses.push("Can't close");
    if (player.totalChallengeWins / player.totalSeasons < 1) weaknesses.push("Challenge liability");
    if (player.totalIdolsFound === 0 && player.totalSeasons >= 2) weaknesses.push("Limited strategic tools");
    
    return weaknesses;
  }
  
  // Scoring functions - Proper formula matching rubric
  function calculatePlayerScore(player) {
    if (!player || !player.totalSeasons || player.totalSeasons === 0) {
      return 0;
    }
    
    let score = 0;
    
    // 1. Placement (40%) - Lower average placement = better score
    const avgPlacement = calculateAvgPlacement(player);
    const castSize = 20; // Approximate average cast size
    const placementPercentile = Math.max(0, Math.min(100, ((castSize - avgPlacement) / castSize) * 100));
    score += placementPercentile * 0.4;
    
    // 2. Win Rate (20%) - Wins / Seasons
    const winRate = (player.wins / player.totalSeasons) * 100;
    score += winRate * 0.2;
    
    // 3. Challenge Performance (15%) - Normalized per season
    const challengesPerSeason = player.totalChallengeWins / player.totalSeasons;
    const challengeScore = Math.min(100, challengesPerSeason * 20); // 5 wins/season = 100
    score += challengeScore * 0.15;
    
    // 4. Social Game (15%) - Lower votes against = better, plus jury votes
    const votesPerSeason = player.totalVotesAgainst / player.totalSeasons;
    const votesScore = Math.max(0, 100 - (votesPerSeason * 3)); // 33 votes/season = 0
    const juryScore = Math.min(100, (player.totalJuryVotes / player.totalSeasons) * 10); // 10 jury votes/season = 100
    const socialScore = (votesScore * 0.7) + (juryScore * 0.3);
    score += socialScore * 0.15;
    
    // 5. Strategic Impact (10%) - Idols, advantages
    const idolsPerSeason = player.totalIdolsFound / player.totalSeasons;
    const strategicScore = Math.min(100, idolsPerSeason * 50); // 2 idols/season = 100
    score += strategicScore * 0.1;
    
    // Ensure score is between 0-100
    return Math.round(Math.max(0, Math.min(100, score)));
  }
  
  function calculateTier(score) {
    if (score >= 91) return "S+";
    if (score >= 81) return "S";
    if (score >= 72) return "A";
    if (score >= 61) return "B";
    if (score >= 51) return "C";
    if (score >= 36) return "D";
    return "F";
  }
  
  function calculateAvgPlacement(player) {
    if (!player.seasonDetails || player.seasonDetails.length === 0) return 99;
    const total = player.seasonDetails.reduce((sum, s) => sum + (s.placement || 99), 0);
    return parseFloat((total / player.seasonDetails.length).toFixed(1));
  }
  
  function generatePlayerTitle(player) {
    if (player.wins >= 2) return "The Legend";
    if (player.wins === 1) return "The Champion";
    if (player.bestPlacement === 2) return "The Runner-Up";
    if (player.totalChallengeWins >= 10) return "The Competitor";
    if (player.bestPlacement <= 5) return "The Threat";
    return "The Survivor";
  }
  
  function generateReasoning(player) {
    let text = `Competed in ${player.totalSeasons} season(s). `;
    if (player.wins > 0) {
      text += `Won ${player.wins} time(s). `;
    }
    text += `Best placement: ${player.bestPlacement}. `;
    text += `${player.totalChallengeWins} challenge wins, ${player.totalVotesAgainst} votes against.`;
    return text;
  }
  
  // ========================================
  // VOTING ANALYTICS HTML GENERATION
  // ========================================
  
  function generateVotingAnalyticsHTML(seasonData) {
    const { seasonNumber, castSize, episodeCount, winner, votingHistory, finalTribalCouncil, finalists } = seasonData;
    
    // Generate episode headers
    let episodeHeaders = '';
    let eliminatedHeaders = '';
    
    votingHistory.forEach(ep => {
      episodeHeaders += `<th>Episode ${ep.episode}</th>`;
      eliminatedHeaders += `<th class="eliminated">${ep.eliminated || 'N/A'}</th>`;
    });
    
    // Add finale columns
    finalists.forEach(f => {
      const className = f.placement === 1 ? 'winner-col' : 'finale-col';
      const label = f.placement === 1 ? 'Winner' : `${f.placement === 2 ? '2nd' : '3rd'} Place`;
      episodeHeaders += `<th class="${className}">${f.name}</th>`;
      eliminatedHeaders += `<th class="${className}">${label}</th>`;
    });
    
    // Generate player rows
    let playerRows = '';
    seasonData.placements.forEach(player => {
      const isWinner = player.placement === 1;
      const rowClass = isWinner ? 'winner-row' : '';
      
      let voteColumns = '';
      
      // Vote columns for each episode
      votingHistory.forEach(ep => {
        const playerVote = ep.votes.find(v => v.voter === player.name);
        voteColumns += `<td>${playerVote ? playerVote.target : '‚Äî'}</td>`;
      });
      
      // Finale vote columns
      if (player.placement <= finalists.length) {
        // This player is a finalist - they don't vote
        finalists.forEach(() => {
          voteColumns += `<td>‚Äî</td>`;
        });
      } else {
        // This player is a juror
        finalists.forEach(f => {
          const juryVote = finalTribalCouncil.votes.find(v => v.juror === player.name);
          const didVoteForThisFinalist = juryVote && juryVote.votedFor === f.name;
          voteColumns += `<td>${didVoteForThisFinalist ? f.name : '‚Äî'}</td>`;
        });
      }
      
      playerRows += `
        <tr class="${rowClass}">
          <td class="rank-col">${player.placement}</td>
          <td class="player-name">${player.name}</td>
          ${voteColumns}
        </tr>
      `;
    });
    
    // Generate complete HTML section
    return `
<!-- SEASON ${seasonNumber} -->
<div id="season${seasonNumber}-table" class="voting-table">
  <h2 style="text-align:center; margin: 20px 0;">üìä Season ${seasonNumber} Voting Chart</h2>
  
  <div class="callout">
    ${castSize} players ‚Ä¢ ${episodeCount} episodes + finale ‚Ä¢ Winner: ${winner.name} (${winner.vote} jury vote)
  </div>
  
  <div class="scroll-hint">
    ‚¨ÖÔ∏è SCROLL RIGHT TO SEE ALL EPISODES + FINALE ‚û°Ô∏è
  </div>
  
  <div class="panel">
    <div class="table-wrapper">
      <table class="vote-table">
        <thead>
          <tr>
            <th rowspan="2" class="rank-col">Rank</th>
            <th rowspan="2" class="player-name">Castaway</th>
            ${episodeHeaders}
          </tr>
          <tr>
            ${eliminatedHeaders}
          </tr>
        </thead>
        <tbody>
          ${playerRows}
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Don't forget to add the button to the season toggle:
<button class="season-btn" onclick="showSeason(${seasonNumber})">Season ${seasonNumber}</button>
-->
`;
  }
  
  // ========================================
  // HELPER FUNCTIONS
  // ========================================
  
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  function downloadJSON(data, filename) {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  function downloadText(text, filename) {
    const blob = new Blob([text], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  // ========================================
  // FEATURE 1: CAST ANALYSIS & PROFILE CREATION
  // ========================================

  if (analyzeCastBtn) {
    analyzeCastBtn.addEventListener("click", () => {
      const summary = seasonSetupSummary.value.trim();
      if (!summary) {
        alert("‚ö†Ô∏è Please paste Episode 1 summary first!");
        return;
      }
      
      // Show loading state
      const originalText = analyzeCastBtn.innerHTML;
      analyzeCastBtn.innerHTML = '‚è≥ Analyzing...';
      analyzeCastBtn.disabled = true;
      
      // Hide previous results
      castAnalysisResult.style.display = 'none';
      createProfilesSection.style.display = 'none';
      
      setTimeout(() => {
        try {
          const seasonInput = document.getElementById("aiSeason");
          const season = Number(seasonInput ? seasonInput.value : 1);
          analyzedCastData = analyzeCast(summary, season);
          
          if (analyzedCastData) {
            displayCastAnalysis(analyzedCastData);
            castAnalysisResult.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        } catch (error) {
          console.error('Analysis error:', error);
          alert(`‚ùå Analysis failed: ${error.message}`);
        } finally {
          analyzeCastBtn.innerHTML = originalText;
          analyzeCastBtn.disabled = false;
        }
      }, 100);
    });
  }

  if (createProfilesBtn) {
    createProfilesBtn.addEventListener("click", () => {
      if (!analyzedCastData) {
        alert("‚ö†Ô∏è Please analyze cast first!");
        return;
      }
      
      if (!confirm(`Create/update profiles for ${analyzedCastData.total} players in Season ${analyzedCastData.season}?\n\nThis will:\n‚Ä¢ Create ${analyzedCastData.newPlayers.length} new profiles\n‚Ä¢ Update ${analyzedCastData.returningPlayers.length} returning players`)) {
        return;
      }
      
      createPlayerProfiles(analyzedCastData);
    });
  }

  function analyzeCast(summaryText, season) {
    const cast = parseCastFromSummary(summaryText);
    
    if (cast.length === 0) {
      alert("‚ö†Ô∏è No cast detected! Make sure your summary has:\n\n=== CAST (ALL) ===\nAmy\nBeardo\n...");
      return null;
    }
    
    const db = loadPlayerDatabase();
    const seasonExists = db.players.some(p => 
      p.seasonDetails && p.seasonDetails.some(s => s.season === season)
    );
    
    if (seasonExists) {
      alert(`‚ö†Ô∏è Season ${season} already has player data!\n\nProfiles were already created.`);
      return null;
    }
    
    const newPlayers = [];
    const returningPlayers = [];
    
    for (const name of cast) {
      const id = slugify(name);
      const existing = db.players.find(p => p.id === id);
      
      if (existing) {
        returningPlayers.push({
          name: name,
          id: id,
          previousSeasons: existing.seasons,
          bestPlacement: existing.bestPlacement,
          wins: existing.wins
        });
      } else {
        newPlayers.push({ name: name, id: id });
      }
    }
    
    let seasonType;
    if (newPlayers.length === cast.length) {
      seasonType = "All Newbies";
    } else if (returningPlayers.length === cast.length) {
      seasonType = "All-Stars";
    } else {
      seasonType = `Mixed (${returningPlayers.length} returnees, ${newPlayers.length} newbies)`;
    }
    
    return {
      season,
      total: cast.length,
      newPlayers,
      returningPlayers,
      seasonType,
      castNames: cast
    };
  }

  function displayCastAnalysis(data) {
    if (!data) return;
    
    let html = `
      <div style="padding: 12px; background: linear-gradient(135deg, rgba(76,255,179,0.2), rgba(76,255,179,0.1)); border: 2px solid #4cffb3; border-radius: 12px; margin-bottom: 16px;">
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 24px;">‚úÖ</span>
          <div>
            <div style="font-weight: 700; color: #4cffb3;">Analysis Complete!</div>
            <div style="font-size: 13px; opacity: 0.9;">Found ${data.total} players for Season ${data.season}</div>
          </div>
        </div>
      </div>
      
      <h4 style="margin-top: 0; color: var(--accent);">Season ${data.season} - Cast Analysis</h4>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px;">
        <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
          <div style="font-size: 24px; font-weight: 700;">${data.total}</div>
          <div style="opacity: 0.7; font-size: 13px;">Total Cast</div>
        </div>
        <div style="padding: 12px; background: rgba(76,255,179,0.15); border-radius: 8px;">
          <div style="font-size: 24px; font-weight: 700; color: #4cffb3;">‚ú® ${data.newPlayers.length}</div>
          <div style="opacity: 0.7; font-size: 13px;">New Players</div>
        </div>
        <div style="padding: 12px; background: rgba(255,179,71,0.15); border-radius: 8px;">
          <div style="font-size: 24px; font-weight: 700; color: #ffb347;">üîÑ ${data.returningPlayers.length}</div>
          <div style="opacity: 0.7; font-size: 13px;">Returning Players</div>
        </div>
      </div>
      <div style="padding: 12px; background: rgba(125,76,255,0.15); border-radius: 8px; margin-bottom: 16px;">
        <strong>Season Type:</strong> ${data.seasonType}
      </div>
    `;
    
    if (data.returningPlayers.length > 0) {
      html += `<details style="margin-top: 12px;">
        <summary style="cursor: pointer; font-weight: 600; margin-bottom: 8px;">üîÑ Returning Players (${data.returningPlayers.length})</summary>
        <div style="display: grid; gap: 6px; margin-top: 8px; font-size: 13px;">`;
      
      for (const p of data.returningPlayers) {
        const trophy = p.wins > 0 ? " üèÜ".repeat(p.wins) : "";
        html += `<div style="padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
          <strong>${p.name}</strong>${trophy} - Seasons: ${p.previousSeasons.join(", ")} | Best: ${p.bestPlacement}${p.bestPlacement === 1 ? "st" : p.bestPlacement === 2 ? "nd" : p.bestPlacement === 3 ? "rd" : "th"}
        </div>`;
      }
      html += `</div></details>`;
    }
    
    if (data.newPlayers.length > 0) {
      html += `<details style="margin-top: 12px;" open>
        <summary style="cursor: pointer; font-weight: 600; margin-bottom: 8px;">‚ú® New Players (${data.newPlayers.length})</summary>
        <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; font-size: 13px;">`;
      
      for (const p of data.newPlayers) {
        html += `<span style="padding: 4px 10px; background: rgba(76,255,179,0.2); border-radius: 6px;">${p.name}</span>`;
      }
      html += `</div></details>`;
    }
    
    castAnalysisResult.innerHTML = html;
    castAnalysisResult.style.display = "block";
    createProfilesSection.style.display = "block";
  }

  function createPlayerProfiles(data) {
    const db = loadPlayerDatabase();
    const season = data.season;
    
    const originalText = createProfilesBtn.innerHTML;
    createProfilesBtn.innerHTML = '‚è≥ Creating profiles...';
    createProfilesBtn.disabled = true;
    
    setTimeout(() => {
      try {
        for (const name of data.castNames) {
          const id = slugify(name);
          let player = db.players.find(p => p.id === id);
          
          if (!player) {
            player = {
              id,
              name,
              seasons: [season],
              totalSeasons: 1,
              bestPlacement: 99,
              wins: 0,
              totalChallengeWins: 0,
              totalImmunityWins: 0,
              totalRewardWins: 0,
              totalVotesAgainst: 0,
              totalIdolsFound: 0,
              totalJuryVotes: 0,
              tier: "Unranked",
              badges: [],
              seasonDetails: []
            };
            db.players.push(player);
          }
          
          if (!player.seasons.includes(season)) {
            player.seasons.push(season);
            player.totalSeasons++;
          }
          
          const existingDetail = player.seasonDetails.find(s => s.season === season);
          if (!existingDetail) {
            player.seasonDetails.push({
              season,
              placement: 99,
              status: "Active",
              tribe: "TBD",
              challengeWins: 0,
              immunityWins: 0,
              rewardWins: 0,
              votesReceived: 0,
              idolsFound: 0,
              strategicRank: 0,
              juryVotes: 0,
              finalVote: "",
              unbreakableBonds: [],
              rivalries: [],
              allianceHistory: []
            });
          }
        }
        
        savePlayerDatabase(db);
        
        // Auto-download database after 1 second
        setTimeout(() => {
          const downloadLink = document.getElementById('download-players-db');
          if (downloadLink) {
            console.log('üì• Auto-downloading players_database.json...');
            downloadLink.click();
          }
        }, 1000);
        
        castAnalysisResult.innerHTML = `
          <div style="padding: 20px; background: linear-gradient(135deg, rgba(76,255,179,0.2), rgba(76,255,179,0.1)); border: 2px solid #4cffb3; border-radius: 16px; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 12px;">üéâ</div>
            <h3 style="margin: 0 0 8px; color: #4cffb3;">Profiles Created!</h3>
            <div style="font-size: 15px; opacity: 0.9; margin-bottom: 16px;">
              Season ${season} is ready to track
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 400px; margin: 0 auto;">
              <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                <div style="font-size: 24px; font-weight: 700; color: #4cffb3;">${data.newPlayers.length}</div>
                <div style="font-size: 12px; opacity: 0.8;">New Profiles</div>
              </div>
              <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                <div style="font-size: 24px; font-weight: 700; color: #ffb347;">${data.returningPlayers.length}</div>
                <div style="font-size: 12px; opacity: 0.8;">Updated</div>
              </div>
            </div>
            <div style="margin-top: 16px; padding: 16px; background: rgba(255,179,71,0.15); border: 1px solid rgba(255,179,71,0.4); border-radius: 8px;">
              <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #ffb347;">‚ö†Ô∏è Important: Update Your Project File</div>
              <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px; line-height: 1.5;">
                1. Download started automatically (check downloads)<br/>
                2. Replace <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">players_database.json</code> in your project folder<br/>
                3. Refresh this page to load the updated database
              </div>
              <button onclick="document.getElementById('download-players-db').click()" class="btn" style="background: linear-gradient(135deg, #4cffb3, #3dd99d); color: #000; font-weight: 600; font-size: 13px;">
                üíæ Download Again
              </button>
            </div>
            <div style="margin-top: 12px; font-size: 11px; opacity: 0.6;">
              Also saved to localStorage (temporary - lost on browser clear)
            </div>
          </div>
        `;
        
        createProfilesSection.innerHTML = `
          <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-top: 20px;">
            <button onclick="location.reload()" class="btn btn-primary">
              ‚ú® Create Another Season
            </button>
            <button onclick="document.getElementById('tabOverview').click()" class="btn">
              üìä Go to Analytics
            </button>
          </div>
        `;
        
        seasonSetupSummary.value = "";
        analyzedCastData = null;
        castAnalysisResult.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
      } catch (error) {
        console.error('Profile creation error:', error);
        alert(`‚ùå Error creating profiles: ${error.message}`);
      } finally {
        createProfilesBtn.innerHTML = originalText;
        createProfilesBtn.disabled = false;
      }
    }, 300);
  }

  // ========================================
  // FEATURE 2: AUTO-UPDATE ELIMINATIONS (GLOBAL)
  // ========================================
  
  window.updatePlayerEliminationsFromEpisode = function(season, episode, cast, eliminated) {
    const db = loadPlayerDatabase();
    let updated = 0;
    
    // Get the ORIGINAL cast size from database (not current active count)
    const allPlayersThisSeason = db.players.filter(p => 
      p.seasons.includes(season)
    );
    const originalCastSize = allPlayersThisSeason.length;
    
    // Count how many players have ALREADY been eliminated before this episode
    const alreadyEliminatedCount = allPlayersThisSeason.filter(p => {
      const sd = p.seasonDetails.find(s => s.season === season);
      return sd && sd.status === "Eliminated";
    }).length;
    
    // New eliminations this episode
    const eliminatedArray = Array.from(eliminated);
    
    for (const eliminatedName of eliminatedArray) {
      const player = db.players.find(p => 
        p.name.toLowerCase() === eliminatedName.toLowerCase()
      );
      
      if (player) {
        const seasonDetail = player.seasonDetails.find(s => s.season === season);
        if (seasonDetail && seasonDetail.status === "Active") {
          // Calculate placement: original cast size - how many were already out
          // First boot: 20 - 0 = 20th place
          // Second boot: 20 - 1 = 19th place
          const placement = originalCastSize - alreadyEliminatedCount - updated;
          seasonDetail.placement = placement;
          seasonDetail.status = "Eliminated";
          
          if (placement < player.bestPlacement) {
            player.bestPlacement = placement;
          }
          
          updated++;
          console.log(`‚úÖ Updated ${player.name}: ${placement}${placement === 1 ? 'st' : placement === 2 ? 'nd' : placement === 3 ? 'rd' : 'th'} place`);
        }
      }
    }
    
    if (updated > 0) {
      savePlayerDatabase(db);
      console.log(`üìä Auto-updated ${updated} elimination(s) for Season ${season} Episode ${episode}`);
    }
  };

  // ========================================
  // FEATURE 3: EXPORT/IMPORT/SYNC DATABASE
  // ========================================

  if (exportDatabaseBtn) {
    exportDatabaseBtn.addEventListener("click", () => {
      const db = loadPlayerDatabase();
      
      const json = JSON.stringify(db, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `players_database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showDatabaseStatus(`‚úÖ Database exported! (${db.players.length} players, ${db.franchise.totalSeasons} seasons)`);
    });
  }

  if (importDatabaseBtn) {
    importDatabaseBtn.addEventListener("click", () => {
      importFileInput.click();
    });
  }

  if (importFileInput) {
    importFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const db = JSON.parse(event.target.result);
          
          if (!db.franchise || !Array.isArray(db.players)) {
            throw new Error("Invalid database structure");
          }
          
          if (!confirm(`Import database with ${db.players.length} players and ${db.franchise.totalSeasons} seasons?\n\nThis will REPLACE your current database!`)) {
            return;
          }
          
          localStorage.setItem('players_database', JSON.stringify(db, null, 2));
          showDatabaseStatus(`‚úÖ Database imported! (${db.players.length} players, ${db.franchise.totalSeasons} seasons)`);
          
        } catch (error) {
          alert(`‚ùå Import failed: ${error.message}`);
        }
        
        importFileInput.value = '';
      };
      
      reader.readAsText(file);
    });
  }

  if (syncDevoteesBtn) {
    syncDevoteesBtn.addEventListener("click", () => {
      const db = loadPlayerDatabase();
      
      if (db.players.length === 0) {
        alert("‚ö†Ô∏è No players in database. Create profiles first!");
        return;
      }
      
      const json = JSON.stringify(db, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        showDatabaseStatus(`‚úÖ Database copied to clipboard!\n\nNow:\n1. Open devotees.html\n2. Paste into localStorage or JSON file`);
      }).catch(() => {
        alert(`‚úÖ Copy this JSON:\n\n${json.substring(0, 200)}...\n\n(See console for full output)`);
        console.log('Database JSON:', json);
      });
    });
    
    // Rebuild Rankings Button
    if (rebuildRankingsBtn) {
      rebuildRankingsBtn.addEventListener("click", async () => {
        if (!confirm("‚ö†Ô∏è Rebuild ALL Rankings?\n\nThis will recalculate scores for ALL players using percentile-based relative scoring.\n\nUse this ONCE to establish new baseline rankings.\n\nContinue?")) {
          return;
        }
        
        rebuildRankingsBtn.disabled = true;
        rebuildRankingsBtn.textContent = "‚è≥ Rebuilding...";
        
        try {
          const db = loadPlayerDatabase();
          
          if (db.players.length === 0) {
            alert("‚ö†Ô∏è No players in database!");
            return;
          }
          
          // Get worker URL
          const workerUrl = getSeasonBuilderWorkerUrl();
          if (!workerUrl) {
            alert("‚ö†Ô∏è Please set Season Builder Worker URL in Settings first!");
            return;
          }
          
          console.log("üîÑ Rebuilding rankings for all players...");
          
          // Load ranking overrides (if available)
          let overrides = null;
          try {
            const overridesResp = await fetch('ranking-overrides.json');
            if (overridesResp.ok) {
              overrides = await overridesResp.json();
              console.log(`‚úì Loaded ${Object.keys(overrides.overrides || {}).length} ranking overrides`);
            }
          } catch (e) {
            console.log('‚ÑπÔ∏è No ranking overrides found, using AI scores only');
          }
          
          const response = await fetch(workerUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              mode: "rankings-rebuild",
              playersDB: db,
              currentSeason: db.franchise?.totalSeasons || 6,
              overrides: overrides  // ‚Üê Pass overrides here
            })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Worker failed (${response.status}): ${errorText}`);
          }
          
          const rankingsDB = await response.json();
          
          if (rankingsDB.error) {
            throw new Error(rankingsDB.error);
          }
          
          // Save to localStorage and download
          localStorage.setItem('rankings_database', JSON.stringify(rankingsDB, null, 2));
          downloadJSON(rankingsDB, 'rankings_database.json');
          
          showDatabaseStatus(`‚úÖ Rankings rebuilt!\n\n${rankingsDB.rankings.length} players ranked with percentile-based scoring.\n\nDownloaded: rankings_database.json`);
          
          console.log("‚úÖ Rankings rebuilt:", rankingsDB);
          
        } catch (error) {
          console.error("Rebuild error:", error);
          alert(`‚ùå Rebuild failed:\n\n${error.message}`);
        } finally {
          rebuildRankingsBtn.disabled = false;
          rebuildRankingsBtn.textContent = "üîÑ Rebuild All Rankings";
        }
      });
    }
  }

  function showDatabaseStatus(message) {
    if (databaseStatus) {
      databaseStatus.textContent = message;
      databaseStatus.style.display = 'block';
      setTimeout(() => {
        databaseStatus.style.display = 'none';
      }, 5000);
    }
  }

  // ========================================
  // DATABASE HELPERS
  // ========================================

  function loadPlayerDatabase() {
    try {
      // Try localStorage first (for live updates)
      const raw = localStorage.getItem("players_database");
      if (raw) {
        console.log("‚úÖ Loaded database from localStorage");
        return JSON.parse(raw);
      }
      
      // If localStorage is empty, try to load from project file
      console.log("‚ö†Ô∏è localStorage empty, attempting to load from project file...");
      fetch('/mnt/project/players_database.json')
        .then(res => res.json())
        .then(data => {
          console.log("‚úÖ Loaded database from project file, saving to localStorage");
          localStorage.setItem("players_database", JSON.stringify(data, null, 2));
          // Reload page to use the localStorage version
          if (confirm("Database loaded from project file. Reload page to start using it?")) {
            location.reload();
          }
        })
        .catch(err => {
          console.log("‚ÑπÔ∏è No project file found, starting fresh");
        });
      
    } catch (e) {
      console.error("Error loading player database:", e);
    }
    
    // Return empty database for now
    return {
      franchise: {
        name: "DC Franchise Database",
        totalSeasons: 0,
        totalPlayers: 0,
        description: "Total Drama franchise player statistics and performance data"
      },
      players: []
    };
  }

  function savePlayerDatabase(db) {
    try {
      db.franchise.totalPlayers = db.players.length;
      const allSeasons = new Set();
      db.players.forEach(p => p.seasons.forEach(s => allSeasons.add(s)));
      db.franchise.totalSeasons = allSeasons.size;
      
      const jsonString = JSON.stringify(db, null, 2);
      
      // Save to localStorage (for live updates)
      localStorage.setItem("players_database", jsonString);
      
      // Also create downloadable file blob
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      // Create/update download link
      let downloadLink = document.getElementById('download-players-db');
      if (!downloadLink) {
        downloadLink = document.createElement('a');
        downloadLink.id = 'download-players-db';
        downloadLink.style.display = 'none';
        document.body.appendChild(downloadLink);
      }
      
      downloadLink.href = url;
      downloadLink.download = 'players_database.json';
      
      console.log(`‚úÖ Database saved: ${db.franchise.totalPlayers} players, ${db.franchise.totalSeasons} seasons`);
      console.log(`üíæ Download available - use document.getElementById('download-players-db').click() to download`);
      
      return url; // Return URL in case caller wants to use it
    } catch (e) {
      console.error("Error saving player database:", e);
      alert("‚ö†Ô∏è Error saving database. Check console.");
    }
  }
  
  // Show/hide auditions section based on episode number
  const episodeInput = document.getElementById('aiEpisode');
  const auditionsSection = document.getElementById('episode-1-auditions');
  
  function toggleAuditions() {
    if (!episodeInput || !auditionsSection) return;
    const episodeNum = parseInt(episodeInput.value) || 1;
    auditionsSection.style.display = (episodeNum === 1) ? 'block' : 'none';
  }
  
  if (episodeInput && auditionsSection) {
    episodeInput.addEventListener('input', toggleAuditions);
    episodeInput.addEventListener('change', toggleAuditions);
    toggleAuditions(); // Initial check on page load
  }
  
  // ========================================
  // DATABASE SYNC MANAGEMENT
  // ========================================
  // Manage database sync
  window.manageDatabaseSync = function() {
    const hasLocalStorage = !!localStorage.getItem("players_database");
    const localStorageSize = hasLocalStorage ? (localStorage.getItem("players_database").length / 1024).toFixed(2) : 0;
    
    let db = null;
    try {
      db = loadPlayerDatabase();
    } catch (e) {}
    
    const message = `
üìä Database Sync Status

${hasLocalStorage ? '‚úÖ' : '‚ùå'} localStorage: ${hasLocalStorage ? `${localStorageSize} KB` : 'Empty'}
${db?.players?.length || 0} players loaded
${db?.franchise?.totalSeasons || 0} seasons

üîÑ How Sync Works:
1. All changes save to localStorage automatically ‚úÖ
2. Use "Export Database" to download .json file
3. Edit file externally if needed
4. Use "Import Database" to upload changes back
5. Changes sync immediately!

üí° Workflow:
‚Ä¢ Play episodes ‚Üí Auto-saves to localStorage ‚úÖ
‚Ä¢ Generate season ‚Üí Updates profiles ‚úÖ
‚Ä¢ Export ‚Üí Download latest version ‚úÖ
‚Ä¢ Import ‚Üí Upload edited version ‚úÖ

üìç Find buttons in:
Database Management tab (bottom of page)

Would you like to:
[OK] Close
[Clear localStorage] Start fresh (WARNING: Deletes data)
    `.trim();
    
    if (confirm(message + "\n\nClick OK to close, Cancel to CLEAR localStorage")) {
      // User clicked Cancel = wants to clear
      if (confirm("‚ö†Ô∏è Are you SURE? This will delete all player data from localStorage!")) {
        localStorage.removeItem("players_database");
        alert("‚úÖ localStorage cleared. Reload page to start fresh.");
        location.reload();
      }
    }
  };
  
    function renderRankingsTab(analytics) {
      if (!analytics || !analytics.rankings) {
        document.getElementById("audiencePopularityList").innerHTML = 
          '<p class="muted">No rankings data available yet.</p>';
        document.getElementById("islandInfluenceList").innerHTML = 
          '<p class="muted">No influence data available yet.</p>';
        document.getElementById("allianceNetworkList").innerHTML = 
          '<p class="muted">No active alliances detected yet.</p>';
        return;
      }
    
      // Render Audience Popularity
      const popList = document.getElementById("audiencePopularityList");
      if (analytics.rankings.audiencePopularity && analytics.rankings.audiencePopularity.length > 0) {
        popList.innerHTML = analytics.rankings.audiencePopularity.map((player, idx) => {
          const trendIcon = player.change > 0 ? '‚¨ÜÔ∏è' : player.change < 0 ? '‚¨áÔ∏è' : '‚û°Ô∏è';
          const trendClass = player.change > 0 ? 'trend-up' : player.change < 0 ? 'trend-down' : 'trend-neutral';
          return `
            <div class="ranking-item">
              <div class="ranking-rank">${idx + 1}.</div>
              <div class="ranking-player">
                <div class="ranking-player-name">${player.name}</div>
                <div class="ranking-stat ${trendClass}">
                  ${trendIcon} ${player.percentage}% (${player.change > 0 ? '+' : ''}${player.change})
                </div>
              </div>
            </div>
          `;
        }).join('');
      } else {
        popList.innerHTML = '<p class="muted">No popularity data yet.</p>';
      }
    
      // Render Island Influence
      const influenceList = document.getElementById("islandInfluenceList");
      if (analytics.rankings.islandInfluence && analytics.rankings.islandInfluence.length > 0) {
        influenceList.innerHTML = analytics.rankings.islandInfluence.map((player, idx) => `
          <div class="ranking-item">
            <div class="ranking-rank">${idx + 1}.</div>
            <div class="ranking-player">
              <div class="ranking-player-name">${player.name}</div>
              <div class="ranking-stat">${player.score} points</div>
            </div>
          </div>
        `).join('');
      } else {
        influenceList.innerHTML = '<p class="muted">No influence data yet.</p>';
      }
    
      // Render Alliance Network
      const allianceList = document.getElementById("allianceNetworkList");
      if (analytics.rankings.alliances && analytics.rankings.alliances.length > 0) {
        allianceList.innerHTML = analytics.rankings.alliances.map(alliance => `
          <div class="alliance-item">
            <div class="alliance-name">${alliance.name}</div>
            <div class="alliance-members">
              ${alliance.members.map(m => `<span class="alliance-member">${m}</span>`).join('')}
            </div>
          </div>
        `).join('');
      } else {
        allianceList.innerHTML = '<p class="muted">No active alliances detected yet.</p>';
      }
    }
    
    // ========== TAB 2: RELATIONSHIPS ==========
    
    function renderRelationshipsTab(analytics) {
      const container = document.getElementById("relationshipHeatmapContainer");
      
      if (!analytics || !analytics.relationships) {
        container.innerHTML = '<p class="muted">No relationship data available yet.</p>';
        return;
      }
    
      const relationships = analytics.relationships;
      const players = Object.keys(relationships);
    
      if (players.length === 0) {
        container.innerHTML = '<p class="muted">No relationship data available yet.</p>';
        return;
      }
    
      // Build heat map table
      let html = '<table class="heatmap-table"><thead><tr><th>üë• PLAYERS</th>';
      players.forEach(p => {
        html += `<th><span class="ai-player"><span class="ai-avatar"><span>üë§</span></span><span class="ai-name">${p}</span></span></th>`;
      });
      html += '</tr></thead><tbody>';
    
      players.forEach(player1 => {
        html += `<tr><th>${player1}</th>`;
        players.forEach(player2 => {
          if (player1 === player2) {
            html += '<td>‚Äî</td>';
          } else {
            const value = relationships[player1]?.[player2] || 0;
            const relClass = 
              value >= 7 ? 'rel-alliance' :
              value >= 3 ? 'rel-friends' :
              value <= -7 ? 'rel-enemies' :
              value <= -3 ? 'rel-tension' :
              'rel-neutral';
            const label = 
              value >= 7 ? 'Alliance' :
              value >= 3 ? 'Friends' :
              value <= -7 ? 'Enemies' :
              value <= -3 ? 'Tension' :
              'Neutral';
            html += `<td class="${relClass}">
              ${value > 0 ? '+' : ''}${value}<br>
              <small style="opacity:0.7">${label}</small>
            </td>`;
          }
        });
        html += '</tr>';
      });
    
      html += '</tbody></table>';
      container.innerHTML = html;
    }
    
    // ========== TAB 3: COMPASS ==========
    
    function renderCompassTab(analytics) {
      const canvas = document.getElementById("compassCanvas");
      const analysis = document.getElementById("compassAnalysis");
    
      if (!analytics || !analytics.compass) {
        canvas.innerHTML = '<p class="muted" style="text-align: center; padding-top: 230px;">No compass data available yet.</p>';
        analysis.innerHTML = '';
        return;
      }
    
      const compass = analytics.compass;
    
      // Clear and render compass dots
      canvas.innerHTML = '';
      canvas.style.position = 'relative';
    
      compass.forEach(player => {
        // Convert -1 to 1 coordinates to pixel positions
        const x = ((player.x + 1) / 2) * 100; // Convert to percentage
        const y = ((1 - player.y) / 2) * 100; // Invert Y axis
    
        const dot = document.createElement('div');
        dot.className = 'compass-player-dot';
        dot.innerHTML = player.icon || player.name[0];
        dot.style.left = `${x}%`;
        dot.style.top = `${y}%`;
        dot.style.transform = 'translate(-50%, -50%)';
        dot.title = `${player.name}: ${player.archetype}`;
        canvas.appendChild(dot);
      });
    
      // Render analysis table
      analysis.innerHTML = `
        <h4 style="margin-bottom: 16px;">üìä Individual Gameplay Analysis</h4>
        ${compass.map(player => `
          <div class="compass-player-row">
            <div class="compass-player-icon">${player.icon || player.name[0]}</div>
            <div>
              <div style="font-weight: 700;">${player.name}</div>
              <div style="font-size: 13px; color: var(--muted);">${player.archetype}</div>
            </div>
            <div style="font-size: 13px; color: var(--muted);">${player.gameplayStyle}</div>
            <div style="font-size: 12px; opacity: 0.7;">(${player.x.toFixed(2)}, ${player.y.toFixed(2)})</div>
          </div>
        `).join('')}
      `;
    }
    
    // ========== TAB 4: RESUMES ==========
    
    function renderResumesTab(analytics) {
      const grid = document.getElementById("resumeGrid");
    
      if (!analytics || !analytics.resumes) {
        grid.innerHTML = '<p class="muted">No resume data available yet.</p>';
        return;
      }
    
      const resumes = analytics.resumes;
      const players = Object.keys(resumes);
    
      if (players.length === 0) {
        grid.innerHTML = '<p class="muted">No resume data available yet.</p>';
        return;
      }
    
      grid.innerHTML = players.map(playerName => {
        const resume = resumes[playerName];
        return `
          <div class="resume-card">
            <div class="resume-header">
              <div class="resume-player-info">
                <h3>${playerName}</h3>
                <div class="resume-status">‚ö° Active</div>
              </div>
              <div class="resume-win-equity">
                <div class="win-equity-percent">${resume.winEquity || 50}%</div>
                <div class="win-equity-label">Win Equity</div>
              </div>
            </div>
    
            <div class="resume-stats">
              <div class="resume-stat">
                <span class="resume-stat-value">${resume.majorityVotes || 0}/${resume.totalVotes || 0}</span>
                <span class="resume-stat-label">üó≥Ô∏è Majority</span>
              </div>
              <div class="resume-stat">
                <span class="resume-stat-value">${resume.immunities || 0}</span>
                <span class="resume-stat-label">üèÜ Immunities</span>
              </div>
              <div class="resume-stat">
                <span class="resume-stat-value">${resume.votesAgainst || 0}</span>
                <span class="resume-stat-label">üéØ Votes</span>
              </div>
              <div class="resume-stat">
                <span class="resume-stat-value">${resume.votesNullified || 0}</span>
                <span class="resume-stat-label">ü©∏ Nullified</span>
              </div>
              <div class="resume-stat">
                <span class="resume-stat-value">${resume.socialScore || 0}</span>
                <span class="resume-stat-label">üí´ Social</span>
              </div>
            </div>
    
            ${resume.keyMoves && resume.keyMoves.length > 0 ? `
              <div class="resume-moves">
                <div class="resume-moves-title">üéØ Key Moves (${resume.keyMoves.length})</div>
                ${resume.keyMoves.map(move => `
                  <div class="resume-move">
                    <div class="resume-move-episode">Episode ${move.episode || '?'}</div>
                    <div class="resume-move-desc">${move.description}</div>
                  </div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }
    
    // ========== TAB 5: TRENDS ==========
    
    function renderTrendsTab(analytics) {
      const select = document.getElementById("trendPlayerSelect");
      const grid = document.getElementById("trendsGrid");
    
      if (!analytics || !analytics.relationshipHistory) {
        select.innerHTML = '<option value="">-- No data available --</option>';
        grid.innerHTML = '<p class="muted">No relationship history available yet.</p>';
        return;
      }
    
      const history = analytics.relationshipHistory;
      const players = Object.keys(history);
    
      if (players.length === 0) {
        select.innerHTML = '<option value="">-- No data available --</option>';
        grid.innerHTML = '<p class="muted">No relationship history available yet.</p>';
        return;
      }
    
      // Populate player select
      select.innerHTML = '<option value="">-- Select a player --</option>' +
        players.map(p => `<option value="${p}">${p}</option>`).join('');
    
      // Handle player selection
      select.onchange = function() {
        const selectedPlayer = this.value;
        if (!selectedPlayer) {
          grid.innerHTML = '<p class="muted">Select a player to see their relationship trends.</p>';
          return;
        }
    
        const playerHistory = history[selectedPlayer];
        const relationships = Object.keys(playerHistory);
    
        grid.innerHTML = relationships.map(otherPlayer => {
          const rel = playerHistory[otherPlayer];
          const trendIcon = rel.trend === 'rising' ? '‚Üó' : rel.trend === 'falling' ? '‚Üò' : '‚Üí';
          const trendClass = rel.trend === 'rising' ? 'trend-up' : rel.trend === 'falling' ? 'trend-down' : 'trend-neutral';
          
          return `
            <div class="trend-item">
              <div class="trend-player-name">${otherPlayer}</div>
              <div class="trend-value ${trendClass}">
                <span class="trend-arrow">${trendIcon}</span>
                <span>${rel.weightedAvg.toFixed(1)} avg</span>
              </div>
            </div>
          `;
        }).join('');
      };
    }
    
    // ========== TAB 6: VOTES ==========
    
    function renderVotesTab(analytics) {
      const select = document.getElementById("voteEpisodeSelect");
      const container = document.getElementById("voteAnalysisContainer");
    
      if (!analytics || !analytics.votes) {
        select.innerHTML = '<option value="">-- No data available --</option>';
        container.innerHTML = '<p class="muted">No vote data available yet.</p>';
        return;
      }
    
      const votes = analytics.votes;
      const episodes = Object.keys(votes);
    
      if (episodes.length === 0) {
        select.innerHTML = '<option value="">-- No data available --</option>';
        container.innerHTML = '<p class="muted">No vote data available yet.</p>';
        return;
      }
    
      // Populate episode select
      select.innerHTML = '<option value="">-- Select episode --</option>' +
        episodes.map(ep => `<option value="${ep}">Episode ${ep.replace('episode', '')}</option>`).join('');
    
      // Handle episode selection
      select.onchange = function() {
        const selectedEp = this.value;
        if (!selectedEp) {
          container.innerHTML = '<p class="muted">Select an episode to see vote analysis.</p>';
          return;
        }
    
        const epData = votes[selectedEp];
        
        let html = `
          <div class="vote-eliminated">
            <div class="vote-eliminated-label">üî• ELIMINATED</div>
            <div class="vote-eliminated-name">${epData.eliminated}</div>
          </div>
    
          <div class="vote-blocs">
            <h4 class="vote-blocs-title">üë• Voting Blocs</h4>
            ${epData.blocs.map(bloc => `
              <div class="vote-bloc">
                <div class="vote-bloc-header">
                  <div class="vote-bloc-name">${bloc.name}</div>
                  <div class="vote-bloc-meta">
                    <span>üéØ Target: ${bloc.target}</span>
                    <span>üí° ${bloc.motivation}</span>
                  </div>
                </div>
                ${bloc.spearheader ? `
                  <div class="vote-bloc-spearheader">
                    <strong>üëë ${bloc.spearheader} (Spearheader)</strong>
                    <div class="vote-bloc-quote">"${bloc.quote}"</div>
                  </div>
                ` : ''}
                <div class="vote-bloc-members">
                  ${bloc.members.map(m => `<span class="alliance-member">${m}</span>`).join('')}
                </div>
              </div>
            `).join('')}
          </div>
    
          <h4 class="vote-individual-title">üó≥Ô∏è Individual Vote Breakdown</h4>
          <div class="vote-individual-grid">
            ${epData.votes.map(vote => `
              <div class="vote-individual-item">
                <div>
                  <span class="vote-individual-voter">${vote.voter}</span>
                  <span class="vote-individual-arrow">‚Üí</span>
                  <span class="vote-individual-target">${vote.target}</span>
                  <span class="vote-individual-type vote-type-${vote.type}">${vote.type}</span>
                </div>
                <div class="vote-individual-reasoning">${vote.reasoning}</div>
              </div>
            `).join('')}
          </div>
        `;
    
        container.innerHTML = html;
      };
    }
    
    // ========== TAB 7: EDGIC ==========
    
    function renderEdgicTab(analytics) {
      const tableContainer = document.getElementById("edgicTableContainer");
      const contendersGrid = document.getElementById("edgicContenders");
    
      if (!analytics || !analytics.edgic) {
        tableContainer.innerHTML = '<p class="muted">No edgic data available yet.</p>';
        contendersGrid.innerHTML = '<p class="muted">No contender data available yet.</p>';
        return;
      }
    
      const edgic = analytics.edgic;
      const players = Object.keys(edgic.ratings || {});
      const episodes = Object.keys((edgic.ratings[players[0]] || {})).filter(k => k.startsWith('episode'));
    
      if (players.length === 0) {
        tableContainer.innerHTML = '<p class="muted">No edgic data available yet.</p>';
        contendersGrid.innerHTML = '<p class="muted">No contender data available yet.</p>';
        return;
      }
    
      // Build edgic table
      let html = '<table class="edgic-table"><thead><tr><th>Contestant</th>';
      episodes.forEach((ep, idx) => {
        html += `<th>${idx + 1}</th>`;
      });
      html += '<th>AVG</th></tr></thead><tbody>';
    
      players.forEach(player => {
        const ratings = edgic.ratings[player];
        html += `<tr><th>${player}</th>`;
        episodes.forEach(ep => {
          const rating = ratings[ep]?.rating || 'MOR';
          const ratingClass = rating.substring(0, 3).toLowerCase();
          html += `<td class="edgic-${ratingClass}">${rating}</td>`;
        });
        html += `<td class="edgic-${ratings.average?.substring(0,3).toLowerCase() || 'mor'}">${ratings.average || 'MOR'}</td>`;
        html += '</tr>';
      });
    
      html += '</tbody></table>';
      tableContainer.innerHTML = html;
    
      // Render contenders
      if (edgic.contenders && edgic.contenders.length > 0) {
        contendersGrid.innerHTML = edgic.contenders.map(contender => `
          <div class="edgic-contender">
            <div class="edgic-contender-rank">${contender.rank}</div>
            <div class="edgic-contender-name">${contender.playerName}</div>
          </div>
        `).join('');
      } else {
        contendersGrid.innerHTML = '<p class="muted">No contender data available yet.</p>';
      }
    }
    
    // ========== RENDER ALL TABS AFTER ANALYTICS GENERATION ==========
    
    function renderAllAnalyticsTabs(analytics) {
      if (!analytics) return;
      
      renderRankingsTab(analytics);
      renderRelationshipsTab(analytics);
      renderCompassTab(analytics);
      renderResumesTab(analytics);
      renderTrendsTab(analytics);
      renderVotesTab(analytics);
      renderEdgicTab(analytics);
}


// ===== Expose tab renderers globally + flush any queued renders =====
window.__realRenderAllAnalyticsTabs = renderAllAnalyticsTabs;
window.__realRenderRankingsTab = renderRankingsTab;
window.__realRenderRelationshipsTab = renderRelationshipsTab;
window.__realRenderCompassTab = renderCompassTab;
window.__realRenderEdgicTab = renderEdgicTab;

window.__realRenderResumesTab = renderResumesTab;
window.__realRenderTrendsTab = renderTrendsTab;
window.__realRenderVotesTab = renderVotesTab;


window.renderAllAnalyticsTabs = renderAllAnalyticsTabs;
window.renderRankingsTab = renderRankingsTab;
window.renderRelationshipsTab = renderRelationshipsTab;
window.renderCompassTab = renderCompassTab;
window.renderEdgicTab = renderEdgicTab;

if (typeof window.__flushTabRenderQueue === "function") window.__flushTabRenderQueue();

  })(); // Close the main IIFE
}, 500); // Close setTimeout - Wait for DOM to fully render

</script>
</div><footer class="siteFooter">
  <div class="footerInner">
    <div class="footerTitle">DC Franchise Database</div>
    <div class="footerSub">Static archive ‚Ä¢ 5 seasons ‚Ä¢ 58 players ‚Ä¢ Icons: name.png</div>
  </div>
</footer>
<!-- SITE FOOTER END -->
</body>
</html>
