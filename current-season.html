<!doctype html>
<html lang="en" data-root=".">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Current Season ‚Äî Season 5</title>
  <link rel="stylesheet" href="styles.css">

  <style>
    .muted{opacity:.78}
    .ai-controls{display:flex;gap:12px;align-items:flex-end;flex-wrap:wrap;margin:14px 0}
    .ai-field{flex:1;min-width:240px}
    .ai-field label{display:block;margin-bottom:6px}
    .ai-field input,.ai-field textarea{
      width:100%;
      border-radius:12px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      color:inherit;
      outline:none;
    }
    .ai-field textarea{resize:vertical}
    .ai-actions{display:flex;gap:10px;flex-wrap:wrap}
    .ai-inline{display:flex;gap:12px;flex-wrap:wrap}
    .ai-list{display:flex;flex-direction:column;gap:12px;margin-top:8px}
    .ai-row{padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.12)}
    .ai-row-top{display:flex;justify-content:space-between;gap:10px;align-items:baseline}
    .ai-row-label{font-weight:700}
    .ai-row-val{opacity:.85;font-variant-numeric:tabular-nums}
    .ai-row-sub{margin-top:6px;opacity:.78;font-size:.92rem}
    .ai-bar{height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:8px}
    .ai-bar span{display:block;height:100%;background:rgba(150,100,255,.85)}
    .ai-tag{display:inline-block;margin-left:8px;font-size:.8rem;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);opacity:.85}
    .ai-line{padding:6px 2px}
  
    /* AI: avatars + cast grid */
    .ai-player{display:flex;align-items:center;gap:10px;min-width:0}
    .ai-avatar{width:28px;height:28px;border-radius:999px;overflow:hidden;flex:0 0 28px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      display:grid;place-items:center}
    .ai-avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .ai-avatar span{font-size:16px;opacity:.9;line-height:1}
    .ai-name{font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ai-out{opacity:.45;filter:grayscale(1)}
    .ai-cast-grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(170px,1fr));
      gap:12px;
      margin-top:10px
    }
    .ai-cast-card{
      display:flex;gap:12px;align-items:center;
      padding:12px;border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.12);
      text-decoration:none;color:inherit
    }
    .ai-cast-card:hover{border-color:rgba(255,255,255,.16);background:rgba(0,0,0,.16)}
    .ai-cast-left{display:flex;align-items:center;gap:10px;min-width:0}
    .ai-cast-avatar{width:42px;height:42px;border-radius:999px;overflow:hidden;flex:0 0 42px;
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      display:grid;place-items:center}
    .ai-cast-avatar img{width:100%;height:100%;object-fit:cover;display:block}
    .ai-cast-avatar span{font-size:20px;opacity:.9}
    .ai-cast-meta{min-width:0}
    .ai-cast-meta .t1{font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ai-cast-meta .t2{opacity:.72;font-size:.9rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  
/* --- AI RE-ARCH (current-season) --- */
.ai-panel{padding:18px;margin:18px 0}
.glass-card{background:rgba(24,16,34,.55);border:1px solid rgba(255,255,255,.08);border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.35);backdrop-filter: blur(10px)}
.section-title{margin:0 0 8px 0;font-size:20px}
.muted{opacity:.75}
.small{font-size:12px}
.ai-head{display:flex;justify-content:space-between;gap:12px;align-items:flex-end;flex-wrap:wrap}
.ai-status{opacity:.85;font-size:13px}
.ai-row{margin-top:12px}
.ai-label{display:block;font-size:12px;letter-spacing:.04em;text-transform:uppercase;opacity:.8;margin-bottom:8px}
.ai-endpoint{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.ai-input{width:100%;min-width:260px;background:rgba(10,8,18,.55);border:1px solid rgba(255,255,255,.10);color:#fff;border-radius:12px;padding:10px 12px;outline:none}
.ai-textarea{width:100%;min-height:170px;background:rgba(10,8,18,.55);border:1px solid rgba(255,255,255,.10);color:#fff;border-radius:12px;padding:12px;outline:none;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;line-height:1.35}
.ai-controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;align-items:flex-end}
.ai-field{flex:1;min-width:160px}
.ai-actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.ai-toggle{display:flex;gap:8px;align-items:center;font-size:13px;opacity:.9;user-select:none}
.ai-toggle input{accent-color: #9b6dff}
.btn{border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
.btn:hover{background:rgba(255,255,255,.10)}
.btn-primary{background:rgba(155,109,255,.22);border-color:rgba(155,109,255,.45)}
.btn-primary:hover{background:rgba(155,109,255,.30)}
.btn-ghost{background:rgba(255,255,255,.06)}

.episode-panel{padding:18px;margin:18px 0}
.episode-hero{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;padding:10px 6px 16px;border-bottom:1px solid rgba(255,255,255,.08);margin-bottom:14px}
.episode-kicker{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75}
.episode-title{font-size:28px;font-weight:800;line-height:1.15;margin-top:4px}
.episode-num{color:rgba(255,255,255,.95)}
.episode-name{color:rgba(155,109,255,.95);margin-left:8px}
.episode-sub{margin-top:8px;opacity:.85}
.subhead{margin:0 0 10px 0}

.players-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:14px}
.player-card{position:relative;display:flex;flex-direction:column;align-items:center;gap:8px;padding:14px;border-radius:16px;text-decoration:none;color:#fff;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.09);transition:transform .12s ease, border-color .12s ease, background .12s ease}
.player-card:hover{transform:translateY(-2px);border-color:rgba(155,109,255,.38);background:rgba(155,109,255,.08)}
.player-card.eliminated{opacity:.38;filter:grayscale(1)}
.pc-avatar{width:64px;height:64px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:flex;align-items:center;justify-content:center;overflow:hidden}
.pc-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.pc-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.75}
.pc-name{font-weight:800;text-align:center}
.pc-title{font-size:12px;opacity:.8;text-align:center;min-height:30px}
.pc-badge{position:absolute;top:10px;right:10px;font-size:10px;letter-spacing:.06em;text-transform:uppercase;background:rgba(255,120,120,.18);border:1px solid rgba(255,120,120,.35);padding:4px 8px;border-radius:999px}
.players-foot{margin-top:10px;opacity:.85;font-size:13px}

.window{padding:18px;margin:18px 0}
.window-head{display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
.window-tabs{display:flex;gap:8px;flex-wrap:wrap}
.tab-btn{border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#fff;cursor:pointer}
.tab-btn.active{background:rgba(155,109,255,.22);border-color:rgba(155,109,255,.45)}
.window-body.hidden{display:none}

.cards-grid{display:grid;grid-template-columns:repeat(4, minmax(0,1fr));gap:12px}
.cards-grid.two{grid-template-columns:repeat(4, minmax(0,1fr));margin-top:12px}
@media (max-width: 1100px){
  .cards-grid{grid-template-columns:repeat(2, minmax(0,1fr))}
  .cards-grid.two{grid-template-columns:repeat(2, minmax(0,1fr))}
}
@media (max-width: 620px){
  .cards-grid{grid-template-columns:1fr}
  .cards-grid.two{grid-template-columns:1fr}
}
.mini-panel{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.09);border-radius:16px;padding:14px}
.mini-title{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75;margin-bottom:10px}
.mini-subtitle{font-size:12px;opacity:.75;margin:-4px 0 10px}
.mini-body{font-size:13px;line-height:1.4;opacity:.95}

.rowline{display:flex;gap:10px;align-items:flex-start}
.mini-avatar{width:38px;height:38px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:flex;align-items:center;justify-content:center;overflow:hidden;flex:none}
.mini-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.mini-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;opacity:.75}
.rowtext{display:flex;flex-direction:column;gap:6px}
.plink{color:#fff;text-decoration:none}
.plink:hover{text-decoration:underline}

.bar-row{padding:10px 10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(0,0,0,.14);margin-bottom:10px}
.bar-head{display:flex;justify-content:space-between;gap:10px;align-items:center}
.bar-left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.bar-pct{opacity:.85;font-variant-numeric:tabular-nums}
.bar-track{height:8px;border-radius:999px;background:rgba(255,255,255,.09);margin:8px 0 8px;overflow:hidden}
.bar-fill{height:100%;background:rgba(155,109,255,.75);border-radius:999px}
.bar-note{opacity:.82;font-size:12px;line-height:1.35}

.tiny-avatar{width:22px;height:22px;border-radius:999px;background:rgba(0,0,0,.35);border:1px solid rgba(155,109,255,.35);display:inline-flex;align-items:center;justify-content:center;overflow:hidden}
.tiny-avatar img{width:100%;height:100%;object-fit:cover;display:none}
.tiny-fallback{display:inline-flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;font-size:11px;opacity:.75}

.tag{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);opacity:.9}
.tag-up{background:rgba(80,255,170,.12);border-color:rgba(80,255,170,.35)}
.tag-down{background:rgba(255,90,120,.12);border-color:rgba(255,90,120,.35)}
.tag-steady{background:rgba(255,255,255,.08)}

.title-row{display:flex;gap:8px;align-items:center;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,.08)}
.title-row:last-child{border-bottom:none}

.gameplay-grid{display:grid;grid-template-columns:1.2fr .8fr;gap:12px}
@media (max-width: 980px){ .gameplay-grid{grid-template-columns:1fr} }
.compass-wrap{padding:8px}
.compass{position:relative;width:100%;aspect-ratio: 1.6/1;background:rgba(0,0,0,.14);border:1px solid rgba(255,255,255,.10);border-radius:16px;overflow:hidden}
.axis{position:absolute;background:rgba(255,255,255,.10)}
.axis-x{left:0;right:0;top:50%;height:1px}
.axis-y{top:0;bottom:0;left:50%;width:1px}
.axis-label{position:absolute;font-size:11px;opacity:.75}
.axis-label.left{left:10px;top:50%;transform:translateY(-50%)}
.axis-label.right{right:10px;top:50%;transform:translateY(-50%)}
.axis-label.top{top:10px;left:50%;transform:translateX(-50%)}
.axis-label.bottom{bottom:10px;left:50%;transform:translateX(-50%)}
.compass-points{position:absolute;inset:0}
.dot{position:absolute;transform:translate(-50%,-50%);text-decoration:none;color:#fff}
.dot-circle{width:30px;height:30px;border-radius:999px;background:rgba(255,255,255,.10);border:1px solid rgba(155,109,255,.40);display:flex;align-items:center;justify-content:center;overflow:hidden}
.dot-circle img{width:100%;height:100%;object-fit:cover;display:none}
.dot-fallback{display:flex;width:100%;height:100%;align-items:center;justify-content:center;font-weight:800;font-size:12px;opacity:.8}
.dot-label{display:block;margin-top:4px;font-size:10px;opacity:.85;text-shadow:0 2px 10px rgba(0,0,0,.6);max-width:90px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.table-wrap{overflow:auto;border-radius:16px;border:1px solid rgba(255,255,255,.10)}
.gp-table{width:100%;border-collapse:collapse}
.gp-table th,.gp-table td{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);font-size:13px;text-align:left}
.gp-table th{font-size:12px;letter-spacing:.12em;text-transform:uppercase;opacity:.75;background:rgba(255,255,255,.04);position:sticky;top:0}
.row-player{display:inline-flex;gap:8px;align-items:center}
</style>

</head>
<body>
<!-- SITE HEADER START -->
<header class="modern-header" id="modernHeader">
  <div class="header-container">
    <!-- Top Bar -->
    <div class="header-top">
      <a href="index.html" class="brand-section" aria-label="Go to home">
        <div class="brand-icon">
          <span class="brand-logo-text">‚ö°</span>
        </div>
        <div class="brand-content">
          <h1>DC <span class="brand-gradient">Franchise</span> Database</h1>
          <p class="brand-subtitle">Season <span id="currentSeasonNum">5</span> Live ‚Ä¢ Click to Explore</p>
        </div>
      </a>

      <div class="stats-badge">
        <div class="stats-main"><span id="totalSeasons">5</span> Seasons ‚Ä¢ <span id="totalPlayers">58</span> Players</div>
        <div class="stats-sub">Icons: <span id="iconFormat">name.png</span></div>
      </div>
    </div>

    <!-- Navigation -->
    <nav class="header-nav" aria-label="Primary navigation">
      <ul class="nav-list">
        <li class="nav-item">
          <a href="index.html" class="nav-link" data-page="index">
            <span class="nav-icon">üè†</span>
            <span>Home</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="current-season.html" class="nav-link" data-page="current-season">
            <span class="nav-icon">üìä</span>
            <span>Current Season</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="voting-analytics.html" class="nav-link" data-page="voting-analytics">
            <span class="nav-icon">üßæ</span>
            <span>Voting Analytics</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="franchise.html" class="nav-link" data-page="franchise">
            <span class="nav-icon">üèõÔ∏è</span>
            <span>Franchise</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="rankings.html" class="nav-link" data-page="rankings">
            <span class="nav-icon">üèÜ</span>
            <span>Rankings</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="seasons.html" class="nav-link" data-page="seasons">
            <span class="nav-icon">üóÇÔ∏è</span>
            <span>Seasons</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="devotees.html" class="nav-link" data-page="devotees">
            <span class="nav-icon">üë•</span>
            <span>Players</span>
          </a>
        </li>
        <li class="nav-item">
          <a href="awards.html" class="nav-link" data-page="awards">
            <span class="nav-icon">üèÖ</span>
            <span>Awards</span>
          </a>
        </li>
      </ul>
    </nav>
  </div>
</header>

<script>
(function() {
  // Load site config and update header stats
  if (window.SITE_CONFIG) {
    document.getElementById('totalSeasons').textContent = window.SITE_CONFIG.seasons;
    document.getElementById('totalPlayers').textContent = window.SITE_CONFIG.players;
    document.getElementById('currentSeasonNum').textContent = window.SITE_CONFIG.currentSeason;
    document.getElementById('iconFormat').textContent = window.SITE_CONFIG.iconFormat;
  }

  // Scroll behavior
  const header = document.getElementById('modernHeader');
  if (!header) return;
  
  window.addEventListener('scroll', () => {
    const currentScroll = window.pageYOffset;
    if (currentScroll > 20) {
      header.classList.add('scrolled');
    } else {
      header.classList.remove('scrolled');
    }
  }, { passive: true });

  // Active page highlighting
  const currentPage = window.location.pathname.split('/').pop() || 'index.html';
  const navLinks = document.querySelectorAll('.nav-link');
  
  navLinks.forEach(link => {
    const linkPage = link.getAttribute('href');
    if (linkPage === currentPage || (currentPage === '' && linkPage === 'index.html')) {
      link.classList.add('active');
    }
  });

  // Path resolution for nested folders
  const root = (document.documentElement.dataset.root || document.body.dataset.root || ".").replace(/\/+$/, "");
  
  if (root !== ".") {
    const allLinks = header.querySelectorAll('a[href]');
    allLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (href && !href.startsWith('http') && !href.startsWith('#')) {
        link.setAttribute('href', root + '/' + href);
      }
    });
  }
})();
</script>
<!-- SITE HEADER END -->

  <div class="container">
  <!-- 1) TOTAL DRAMA ANALYTICS (AI) -->
  <section class="ai-panel glass-card" id="aiPanel">
    <div class="ai-head">
      <h2 class="section-title">üìà Total Drama Analytics <span class="muted">(AI)</span></h2>
      <div class="ai-status" id="aiStatus">Paste your episode summary and generate analytics.</div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="aiWorkerUrl">AI Endpoint (Cloudflare Worker URL)</label>
      <div class="ai-endpoint">
        <input id="aiWorkerUrl" class="ai-input" placeholder="https://dc-analytics.yoursubdomain.workers.dev" />
        <button class="btn btn-ghost" id="aiSaveUrl">Save URL</button>
      </div>
    </div>

    <div class="ai-controls">
      <div class="ai-field">
        <label class="ai-label" for="aiSeason">Season</label>
        <input id="aiSeason" class="ai-input" type="number" min="1" value="5" />
      </div>
      <div class="ai-field">
        <label class="ai-label" for="aiEpisode">Episode</label>
        <input id="aiEpisode" class="ai-input" type="number" min="1" value="1" />
      </div>

      <div class="ai-actions">
        <button class="btn btn-primary" id="aiGenerate">Generate Analytics</button>
        <button class="btn btn-ghost" id="aiLoadCached">Load Cached</button>
        <label class="ai-toggle">
          <input type="checkbox" id="aiAutoLoad" checked />
          <span>Auto-load on refresh</span>
        </label>
      </div>
    </div>

    <div class="ai-row">
      <label class="ai-label" for="aiSummary">Episode Summary Input</label>
      <textarea id="aiSummary" class="ai-textarea" spellcheck="false" placeholder="Paste your episode write-up here (like your Episode 1 summary)..."></textarea>
    </div>
  </section>

  <!-- 2) EPISODE HEADER + CURRENT PLAYERS (BIG) -->
  <section class="episode-panel glass-card" id="episodePanel">
    <div class="episode-hero">
      <div>
        <div class="episode-kicker">TOTAL DRAMA ‚Ä¢ Current Episode</div>
        <div class="episode-title">
          <span class="episode-num" id="uiEpisodeNum">Episode 1</span>
          <span class="episode-name" id="uiEpisodeName">‚Äî</span>
        </div>
        <div class="episode-sub">
          <span id="uiPlayersRemaining">‚Äî</span> remaining ‚Ä¢ Click any player to open their profile
        </div>
      </div>

      <div class="episode-hero-actions">
        <button class="btn btn-ghost" id="btnSyncFromSummary">Sync title/players from summary</button>
      </div>
    </div>

    <h3 class="subhead">Current Players</h3>
    <div class="players-grid" id="currentPlayersGrid"></div>
    <div class="players-foot">
      <span class="muted">Tip:</span> eliminated players are greyed out automatically if your summary includes an <b>ELIMINATED</b> block.
    </div>
  </section>

  <!-- 3) SWITCHABLE ANALYTICS WINDOW -->
  <section class="window glass-card" id="analyticsWindow">
    <div class="window-head">
      <h2 class="section-title">üìä Cullhouse Analytics</h2>
      <div class="window-tabs" role="tablist" aria-label="Analytics tabs">
        <button class="tab-btn active" id="tabOverview" role="tab" aria-selected="true">üìò Overview</button>
        <button class="tab-btn" id="tabGameplay" role="tab" aria-selected="false">üß≠ Gameplay</button>
        <button class="tab-btn" id="tabEpisode" role="tab" aria-selected="false">üì∫ Episode</button>
        <button class="tab-btn" id="tabSeasonSetup" role="tab" aria-selected="false">‚≠ê Season Setup</button>
      </div>
    </div>

    <!-- OVERVIEW PAGE -->
    <div class="window-body" id="viewOverview">
      <div class="cards-grid">
        <div class="mini-panel">
          <div class="mini-title">BEST MOVE</div>
          <div class="mini-body" id="cardBestMove">‚Äî</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">BIGGEST RISK</div>
          <div class="mini-body" id="cardBiggestRisk">‚Äî</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">EPISODE SUMMARY</div>
          <div class="mini-body" id="cardEpisodeSummary">‚Äî</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">ALLIANCE OVERVIEW</div>
          <div class="mini-body" id="cardAllianceOverview">‚Äî</div>
        </div>
      </div>

      <div class="cards-grid two">
        <div class="mini-panel">
          <div class="mini-title">BOOT ODDS (NEXT)</div>
          <div class="mini-body" id="cardBootOdds">No boot predictions yet.</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">POWER RANKINGS</div>
          <div class="mini-body" id="cardPowerRankings">No power rankings yet.</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">ALLIANCE STABILITY</div>
          <div class="mini-body" id="cardAllianceStability">No alliance stability yet.</div>
        </div>

        <div class="mini-panel">
          <div class="mini-title">TITLES</div>
          <div class="mini-body" id="cardTitles">No titles yet.</div>
        </div>
      </div>
    </div>

    <!-- GAMEPLAY PAGE -->
    <div class="window-body hidden" id="viewGameplay">
      <div class="gameplay-grid">
        <div class="mini-panel gameplay-panel">
          <div class="mini-title">GAMEPLAY COMPASS</div>
          <div class="mini-subtitle">AI-derived placement from your overview stats (Power vs Safety)</div>
          <div class="compass-wrap">
            <div class="compass" id="compass">
              <div class="axis axis-x"></div>
              <div class="axis axis-y"></div>
              <div class="axis-label left">Low Power</div>
              <div class="axis-label right">High Power</div>
              <div class="axis-label top">Safe</div>
              <div class="axis-label bottom">At Risk</div>
              <div class="compass-points" id="compassPoints"></div>
            </div>
          </div>
          <div class="muted small">If you want true ‚ÄúSocial vs Competition‚Äù, I can upgrade your Worker to output compass coordinates directly.</div>
        </div>

        <div class="mini-panel gameplay-panel">
          <div class="mini-title">INDIVIDUAL GAMEPLAY ANALYSIS</div>
          <div class="mini-subtitle">Auto-built from AI output (tag + score + risk)</div>

          <div class="table-wrap">
            <table class="gp-table">
              <thead>
                <tr>
                  <th>Player</th>
                  <th>Title</th>
                  <th>Trend</th>
                  <th>Power</th>
                  <th>Boot Risk</th>
                  <th>Role</th>
                </tr>
              </thead>
              <tbody id="gpTableBody"></tbody>
            </table>
          </div>
        </div>
      </div>
      
      <!-- NEW ANALYTICS PANELS -->
      <div class="cards-grid two" style="margin-top: 20px;">
        <div class="mini-panel">
          <div class="mini-title">SOCIAL NETWORK</div>
          <div class="mini-body" id="cardSocialNetwork">No social network data yet.</div>
        </div>
        
        <div class="mini-panel">
          <div class="mini-title">JURY MANAGEMENT</div>
          <div class="mini-body" id="cardJuryManagement">No jury management data yet.</div>
        </div>
        
        <div class="mini-panel">
          <div class="mini-title">THREAT BREAKDOWN</div>
          <div class="mini-body" id="cardThreatBreakdown">No threat breakdown yet.</div>
        </div>
        
        <div class="mini-panel">
          <div class="mini-title">PATH TO VICTORY</div>
          <div class="mini-body" id="cardPathToVictory">No path to victory data yet.</div>
        </div>
      </div>
    </div>

    <!-- EPISODE TAB -->
    <div class="window-body hidden" id="viewEpisode">
      <div class="episode-viewer">
        
        <!-- Summary Input for AI Generation -->
        <div class="glass-card" style="padding: 20px; margin-bottom: 20px;">
          <h3 style="margin-top: 0;">ü§ñ AI Episode Generation</h3>
          <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
            Paste your BrantSteele episode summary here, then click "Generate Episode" to create a full Total Drama episode transcript.
          </p>
          <textarea 
            id="episode-summary-input" 
            class="episode-input" 
            placeholder="Paste your BrantSteele episode summary here...

Example:
Episode 2: Tribal swap! Belo won immunity. At Reba, Ella was voted out 2-1..."
            style="width: 100%; min-height: 150px; margin-bottom: 12px;"></textarea>
          <button onclick="generateEpisodeAI()" id="generate-episode-btn" class="btn btn-primary">
            üé¨ Generate Episode with AI
          </button>
        </div>

        <!-- Manual Transcript Input -->
        <div class="glass-card" style="padding: 20px; margin-bottom: 20px;">
          <h3 style="margin-top: 0;">üìù Episode Transcript</h3>
          <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
            Or paste a manually written episode transcript here.
          </p>
          <textarea 
            id="episode-input" 
            class="episode-input" 
            placeholder="Paste or generate your episode transcript here...

Format:
[Scene: Beach. Morning.]

Chris: Welcome to Total Drama!

Owen: I'm so excited!

[Confessional: Owen]
Owen: This is going to be amazing!"
            style="width: 100%; min-height: 300px;"></textarea>
        </div>
        
        <!-- Controls -->
        <div class="episode-controls">
          <button onclick="renderEpisode()" class="btn btn-primary">üé¨ Render Episode</button>
          <button onclick="saveEpisode()" class="btn">üíæ Save Episode</button>
          <button onclick="loadEpisode()" class="btn">üìÇ Load Saved</button>
          <button onclick="clearEpisode()" class="btn btn-ghost">üóëÔ∏è Clear</button>
        </div>
        
        <!-- Rendered Episode -->
        <div id="episode-rendered"></div>
      </div>
    </div>

    <!-- SEASON SETUP TAB -->
    <div class="window-body hidden" id="viewSeasonSetup">
      <div class="glass-card" style="padding: 24px; margin-bottom: 20px;">
        <h3 style="margin-top: 0;">üé¨ Season Initialization</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 20px;">
          Start a new season by creating player profiles from your Episode 1 summary. 
          The system will detect new players vs returning players automatically.
        </p>
        
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">
            üìã Episode 1 Summary (with cast list)
          </label>
          <textarea 
            id="season-setup-summary" 
            style="width: 100%; min-height: 300px; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--text); font-family: monospace; font-size: 13px;"
            placeholder="Paste your Episode 1 summary here...

Must include:
=== CAST (ALL) ===
Amy
Beardo
Blaineley
..."></textarea>
        </div>
        
        <button id="analyze-cast-btn" class="btn btn-primary" style="margin-right: 10px;">
          üîç Analyze Cast
        </button>
        
        <div id="cast-analysis-result" style="margin-top: 20px; padding: 16px; background: rgba(125,76,255,0.1); border: 1px solid rgba(125,76,255,0.3); border-radius: 12px; display: none;">
          <!-- Analysis results will appear here -->
        </div>
        
        <div id="create-profiles-section" style="margin-top: 20px; display: none;">
          <button id="create-profiles-btn" class="btn" style="background: linear-gradient(135deg, #4ade80, #22c55e); font-weight: 700;">
            üé≠ Create Player Profiles
          </button>
        </div>
      </div>
      
      <!-- COMPLETE SEASON BUILDER -->
      <div class="glass-card" style="padding: 24px; margin-top: 20px; background: linear-gradient(135deg, rgba(155,109,255,0.15), rgba(76,255,179,0.05)); border: 2px solid rgba(155,109,255,0.3);">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 32px;">‚ö°</span>
            <div>
              <h3 style="margin: 0;">Complete Season Builder</h3>
              <p style="margin: 4px 0 0; opacity: 0.8; font-size: 13px;">
                Build entire season database from episode summaries (generates all JSON files)
              </p>
            </div>
          </div>
          
          <!-- Save Indicator & Clear Button -->
          <div style="display: flex; align-items: center; gap: 12px;">
            <div id="sb-save-indicator" style="display: none; padding: 8px 12px; background: rgba(76,255,179,0.2); border: 1px solid rgba(76,255,179,0.4); border-radius: 8px; font-size: 13px;">
              ‚úÖ Auto-saved
            </div>
            <button onclick="clearCurrentSeasonData()" style="padding: 8px 16px; background: rgba(255,76,76,0.2); border: 1px solid rgba(255,76,76,0.4); border-radius: 8px; color: #fff; cursor: pointer; font-size: 13px;">
              üóëÔ∏è Clear Season
            </button>
          </div>
        </div>
        
        <!-- SEASON METADATA -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
            <span>üìù</span> Season Metadata
          </h4>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Season Number</label>
              <input type="number" id="sb-season-number" value="6" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Episode Count</label>
              <input type="number" id="sb-episode-count" value="14" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Emoji</label>
              <input type="text" id="sb-season-emoji" value="üéØ" maxlength="4"
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-size: 24px; text-align: center;" />
            </div>
          </div>
          
          <div style="margin-top: 16px;">
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Season Title</label>
            <input type="text" id="sb-season-title" placeholder="Total Drama [Theme Name]" 
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
          </div>
          
          <div style="margin-top: 12px;">
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Subtitle</label>
            <input type="text" id="sb-season-subtitle" placeholder="Season tagline or description" 
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
          </div>
          
          <div style="margin-top: 12px;">
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Theme</label>
            <input type="text" id="sb-season-theme" placeholder="E.g., '3 tribes + swaps + redemption island'" 
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
          </div>
        </div>
        
        <!-- BRANTSTEELE STATS -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
            <span>üìä</span> Brantsteele Stats (Optional but Recommended)
          </h4>
          
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">
              Paste Brantsteele Summary Stats
              <span style="opacity: 0.6;">(Placements, Challenge Wins, Votes Received, Idols, etc.)</span>
            </label>
            <textarea id="sb-brantsteele-stats" rows="8" placeholder="Optional: Paste the full Brantsteele season summary here for accurate stats...

Example format:
Place | Player | Phase | Notes
1 | Jacques | Winner | 7 votes to win
2 | Mickey | Finalist | 1 vote
...

Challenge Performance:
Jacques: 4 wins
Mickey: 1 win
...

Votes Received:
Brody: 26
Kitty: 15
..."
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px;"></textarea>
          </div>
          
          <div style="margin-top: 12px; padding: 12px; background: rgba(76,255,179,0.1); border: 1px solid rgba(76,255,179,0.3); border-radius: 8px;">
            <p style="margin: 0; font-size: 12px; opacity: 0.85;">
              üí° <strong>Tip:</strong> Including Brantsteele stats ensures 100% accuracy for challenge wins, idol counts, and votes received. AI will merge this data with episode narratives.
            </p>
          </div>
        </div>
        
        <!-- EPISODE SUMMARIES -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h4 style="margin: 0; display: flex; align-items: center; gap: 8px;">
              <span>üìö</span> Episode Summaries
            </h4>
            <button id="sb-toggle-episodes" class="btn" style="font-size: 12px; padding: 6px 12px;">
              Show All Episodes
            </button>
          </div>
          
          <div id="sb-episodes-container">
            <!-- Episode inputs will be dynamically generated by JavaScript -->
          </div>
          
          <div style="margin-top: 16px; padding: 12px; background: rgba(255,179,71,0.1); border: 1px solid rgba(255,179,71,0.3); border-radius: 8px;">
            <p style="margin: 0 0 8px 0; font-size: 12px; opacity: 0.85;">
              üí° <strong>Required:</strong> Episode 1 must include the cast list in format:<br/>
              <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">=== CAST (ALL) ===</code>
            </p>
            <p style="margin: 0; font-size: 12px; opacity: 0.85;">
              üí° <strong>Optional:</strong> Include tribe assignments for tribe tracking:<br/>
              <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">=== TRIBE: Galang ===</code><br/>
              <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">Mickey, Jacques, Ryan...</code>
            </p>
          </div>
        </div>
        
        <!-- FINALE & AWARDS -->
        <div style="background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
            <span>üèÜ</span> Finale Results & Awards
          </h4>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 16px;">
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Winner</label>
              <input type="text" id="sb-finale-winner" placeholder="Winner name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Runner-Up(s)</label>
              <input type="text" id="sb-finale-runnerup" placeholder="Name1, Name2" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Final Vote</label>
              <input type="text" id="sb-finale-vote" placeholder="5-4 or 4-3-2" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
          </div>
          
          <div>
            <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Jury Votes (one per line: Juror voted for Finalist)</label>
            <textarea id="sb-jury-votes" rows="6" placeholder="Scarlett voted for Mickey
Sugar voted for Sky
Dave voted for Mickey
..."
              style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px;"></textarea>
          </div>
          
          <h5 style="margin: 20px 0 12px 0; opacity: 0.9;">Season Awards</h5>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Fan Favorite</label>
              <input type="text" id="sb-award-fan" placeholder="Player name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Best Strategic</label>
              <input type="text" id="sb-award-strategic" placeholder="Player name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 6px; font-size: 13px; opacity: 0.9;">Most Challenge Wins</label>
              <input type="text" id="sb-award-challenges" placeholder="Player name" 
                style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff;" />
            </div>
          </div>
        </div>
        
        <!-- GENERATE BUTTON -->
        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
          <button id="sb-generate-all" class="btn btn-primary" style="flex: 1; font-size: 16px; padding: 14px; background: linear-gradient(135deg, #9b6dff, #4cffb3); font-weight: 700;">
            ‚ö° Generate Complete Season Database
          </button>
          
          <button id="sb-preview-data" class="btn" style="padding: 14px 20px;">
            üëÅÔ∏è Preview Data
          </button>
        </div>
        
        <!-- PROGRESS/RESULTS -->
        <div id="sb-progress" style="margin-top: 20px; display: none;">
          <!-- Progress updates will appear here -->
        </div>
      </div>
      
      <div class="glass-card" style="padding: 24px;">
        <h3 style="margin-top: 0;">üìä Season Progress Tracking</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
          Track eliminations throughout the season. Placement data updates automatically when you generate analytics.
        </p>
        
        <div id="season-progress-info" style="padding: 16px; background: rgba(255,179,71,0.1); border: 1px solid rgba(255,179,71,0.3); border-radius: 12px;">
          <p style="margin: 0; opacity: 0.7;">No season data loaded. Create profiles first.</p>
        </div>
      </div>
      
      <div class="glass-card" style="padding: 24px; margin-top: 20px;">
        <h3 style="margin-top: 0;">üèÜ End-of-Season Finalization</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
          After the finale, manually edit the player database JSON to add:
        </p>
        <ul style="opacity: 0.8; font-size: 14px; line-height: 1.8;">
          <li><strong>Challenge wins</strong> - Individual immunity/reward wins</li>
          <li><strong>Strategic rank</strong> - Your assessment of their gameplay</li>
          <li><strong>Alliance history</strong> - Key alliances they were part of</li>
          <li><strong>Bonds & rivalries</strong> - Important relationships</li>
          <li><strong>Jury votes</strong> - How many jury votes they received (finalists only)</li>
          <li><strong>Tier ranking</strong> - Calculate based on performance</li>
          <li><strong>Badges</strong> - Awards like "Challenge Beast", "Strategic Mastermind"</li>
        </ul>
        
        <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
          <p style="margin: 0; font-size: 13px; opacity: 0.7;">
            üí° <strong>Tip:</strong> The system auto-creates profiles and tracks eliminations. 
            You focus on the rich gameplay data at season's end!
          </p>
        </div>
      </div>
      
      <div class="glass-card" style="padding: 24px; margin-top: 20px;">
        <h3 style="margin-top: 0;">üíæ Database Management</h3>
        <p style="opacity: 0.8; font-size: 14px; margin-bottom: 16px;">
          Export, import, or sync your player database.
        </p>
        
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button id="export-database-btn" class="btn" style="background: linear-gradient(135deg, #22c55e, #16a34a);">
            üì• Export Database to JSON
          </button>
          
          <button id="import-database-btn" class="btn" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">
            üì§ Import Database from JSON
          </button>
          
          <button id="sync-devotees-btn" class="btn" style="background: linear-gradient(135deg, #a855f7, #9333ea);">
            üîÑ Sync to devotees.html
          </button>
          
          <button id="rebuild-rankings-btn" class="btn" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
            üîÑ Rebuild All Rankings
          </button>
        </div>
        
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
        
        <div id="database-status" style="margin-top: 16px; padding: 12px; background: rgba(125,76,255,0.1); border: 1px solid rgba(125,76,255,0.3); border-radius: 8px; display: none;">
          <!-- Status messages appear here -->
        </div>
      </div>
    </div>
  </section>

  <!-- SCRIPT: AI + RENDERING -->
  <script>

  (function() {
    const $ = (id) => document.getElementById(id);

    const els = {
      workerUrl: $("aiWorkerUrl"),
      saveUrl: $("aiSaveUrl"),
      season: $("aiSeason"),
      episode: $("aiEpisode"),
      generate: $("aiGenerate"),
      loadCached: $("aiLoadCached"),
      autoLoad: $("aiAutoLoad"),
      summary: $("aiSummary"),
      status: $("aiStatus"),

      uiEpNum: $("uiEpisodeNum"),
      uiEpName: $("uiEpisodeName"),
      uiRemain: $("uiPlayersRemaining"),
      syncFromSummary: $("btnSyncFromSummary"),
      playersGrid: $("currentPlayersGrid"),

      tabOverview: $("tabOverview"),
      tabGameplay: $("tabGameplay"),
      tabEpisode: $("tabEpisode"),
      tabSeasonSetup: $("tabSeasonSetup"),
      viewOverview: $("viewOverview"),
      viewGameplay: $("viewGameplay"),
      viewEpisode: $("viewEpisode"),
      viewSeasonSetup: $("viewSeasonSetup"),

      cardBestMove: $("cardBestMove"),
      cardBiggestRisk: $("cardBiggestRisk"),
      cardEpisodeSummary: $("cardEpisodeSummary"),
      cardAllianceOverview: $("cardAllianceOverview"),
      cardBootOdds: $("cardBootOdds"),
      cardPowerRankings: $("cardPowerRankings"),
      cardAllianceStability: $("cardAllianceStability"),
      cardTitles: $("cardTitles"),
      cardSocialNetwork: $("cardSocialNetwork"),
      cardJuryManagement: $("cardJuryManagement"),
      cardThreatBreakdown: $("cardThreatBreakdown"),
      cardPathToVictory: $("cardPathToVictory"),

      compassPoints: $("compassPoints"),
      gpTableBody: $("gpTableBody"),
    };

    // ----------------------------
    // Helpers
    // ----------------------------
    function normalizeWorkerUrl(raw) {
      let url = (raw || "").trim();
      if (!url) return "";
      if (!/^https?:\/\//i.test(url)) url = "https://" + url;
      return url.replace(/\/+$/, "");
    }

    function slugify(name) {
      return (name || "")
        .toLowerCase()
        .trim()
        .replace(/['".]/g, "")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");
    }

    function escapeHtml(s) {
      return String(s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function setStatus(msg) {
      if (els.status) els.status.textContent = msg;
    }

    function cacheKey(season, episode) {
      return `AI_ANALYTICS_s${season}_e${episode}`;
    }

    function saveLastSelection(season, episode) {
      localStorage.setItem("AI_LAST_SELECTION", JSON.stringify({ season, episode }));
    }

    function loadLastSelection() {
      try { return JSON.parse(localStorage.getItem("AI_LAST_SELECTION") || "null"); } catch { return null; }
    }

    // Extract cast list from summary (best effort)
        function parseBlock(text, headerRegex) {
      const lines = (text || "").split(/\r?\n/);
      let start = -1;
      for (let i = 0; i < lines.length; i++) {
        if (headerRegex.test(lines[i].trim())) { start = i; break; }
      }
      if (start === -1) return [];
      const out = [];
      for (let i = start + 1; i < lines.length; i++) {
        const raw = lines[i];
        const l = (raw || "").trim();
        if (!l) continue;
        if (/^===\s*/.test(l)) break;
        // stop if next major section starts (fallback)
        if (/^(PRE-CHALLENGE|CHALLENGES|POST-CHALLENGE|TRIBAL|VOTING|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
        out.push(l);
      }
      return out;
    }

    function cleanNameLine(l) {
      let s = (l || "").trim();
      if (!s) return "";
      s = s.replace(/^[-‚Ä¢]\s*/, "");
      // strip numbering like "18. Leonard" or "18th Leonard"
      s = s.replace(/^\d+\s*(?:[.)]|(?:st|nd|rd|th)\b)\s*/i, "");
      // strip "Name:18th" or "Name - 18th"
      s = s.replace(/:\s*\d+(?:st|nd|rd|th)\b.*$/i, "").trim();
      s = s.replace(/[‚Äî‚Äì].*$/, "").trim();
      return s;
    }

    function isProbablyName(s) {
      return /^[A-Za-z][A-Za-z0-9' -]*$/.test(s) && s.length <= 30;
    }

    function parseCastFromSummary(text) {
      const lines = (text || "").split(/\r?\n/).map(l => l.trim());
      let names = [];

      // META block: === CAST (ALL) ===
      const castBlock = parseBlock(text, /^===\s*CAST\b/i);
      if (castBlock.length) {
        castBlock.forEach(l => {
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        });
      }

      // TRIBES block: === TRIBES (ACTIVE) === with # Tribe headings
      const tribesBlock = parseBlock(text, /^===\s*TRIBES\b/i);
      if (tribesBlock.length) {
        tribesBlock.forEach(l => {
          if (/^#\s*/.test(l)) return; // header
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        });
      }

      // Pattern 1: after "The Cast arrives"
      const idx = lines.findIndex(l => /the\s+cast\s+arrives/i.test(l));
      if (idx !== -1) {
        for (let i = idx + 1; i < lines.length; i++) {
          const l = lines[i];
          if (!l) break;
          if (/^(PRE-CHALLENGE|CHALLENGES|POST-CHALLENGE|VOTING|TRIBAL|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
          const n = cleanNameLine(l);
          if (isProbablyName(n)) names.push(n);
        }
      }

      // Pattern 2: Active Players lines like "Belo Tribe (6): Amy, Rodney..."
      const tribeLines = lines.filter(l => /tribe\s*\(\d+\)\s*:/i.test(l));
      for (const tl of tribeLines) {
        const after = tl.split(":")[1] || "";
        after.split(",").map(x => x.trim()).filter(Boolean).forEach(n => {
          const cn = cleanNameLine(n);
          if (isProbablyName(cn)) names.push(cn);
        });
      }

      // De-dup while preserving order
      const seen = new Set();
      names = names
        .map(n => n.trim())
        .filter(Boolean)
        .filter(n => {
          const k = n.toLowerCase();
          if (seen.has(k)) return false;
          seen.add(k);
          return true;
        });

      return names;
    }

    function parseEpisodeTitle(text) {
      // Episode 2: "Shadows of Doubt"
      const m = (text || "").match(/Episode\s+(\d+)\s*[:\-]\s*["‚Äú]?([^"\n‚Äù]+)["‚Äù]?/i);
      if (m) return { num: parseInt(m[1], 10), title: m[2].trim() };
      // EPISODE 1 SUMMARY (no title)
      const m2 = (text || "").match(/EPISODE\s+(\d+)/i);
      if (m2) return { num: parseInt(m2[1], 10), title: "" };
      return null;
    }

        function parseEliminated(text) {
      const rawLines = (text || "").split(/\r?\n/);
      const lines = rawLines.map(l => (l || "").trim());

      const out = [];
      const pushName = (l) => {
        const n = cleanNameLine(l);
        if (isProbablyName(n)) out.push(n);
      };

      // META block: === ELIMINATED ===
      const elimBlock = parseBlock(text, /^===\s*ELIMINATED\b/i);
      if (elimBlock.length) {
        elimBlock.forEach(pushName);
      }

      // Traditional "ELIMINATED" section(s)
      for (let i = 0; i < lines.length; i++) {
        if (!/^ELIMINATED\b/i.test(lines[i])) continue;
        for (let j = i + 1; j < lines.length; j++) {
          const l = lines[j];
          if (!l) break;
          if (/^===\s*/.test(l)) break;
          if (/^(Vote count|Reason|Edge of Extinction|Not applicable|TRIBAL|MAJOR STRATEGIC|CURRENT GAME STATUS|NEXT EPISODE QUESTIONS)\b/i.test(l)) break;
          pushName(l);
        }
      }

      // Footer style: "Eliminated:" list
      for (let i = 0; i < lines.length; i++) {
        if (!/^Eliminated\s*:/i.test(lines[i])) continue;
        for (let j = i + 1; j < lines.length; j++) {
          const l = lines[j];
          if (!l) break;
          if (/^===\s*/.test(l)) break;
          if (/^(NEXT EPISODE QUESTIONS|CURRENT GAME STATUS|TRIBAL|MAJOR STRATEGIC)\b/i.test(l)) break;
          pushName(l);
        }
      }

      // De-dup
      const seen = new Set();
      return out.filter(n => {
        const k = n.toLowerCase();
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      });
    }

    function getProbForPlayer(bootPredictions, player) {
      if (!Array.isArray(bootPredictions)) return 0;
      const found = bootPredictions.find(x => (x?.player || "").toLowerCase() === (player || "").toLowerCase());
      return found ? Number(found.prob) || 0 : 0;
    }

    // ----------------------------
    // Rendering: Current Players grid
    // ----------------------------
    function renderPlayersGrid(castNames, eliminatedNames, titlesMap) {
      const eliminated = new Set((eliminatedNames || []).map(n => n.toLowerCase()));
      const cast = (castNames || []).slice(0, 60);

      if (!cast.length) {
        els.playersGrid.innerHTML = `<div class="muted">No cast detected yet. Click ‚ÄúSync title/players from summary‚Äù.</div>`;
        els.uiRemain.textContent = "‚Äî";
        return;
      }

      const remainingCount = cast.filter(n => !eliminated.has(n.toLowerCase())).length;
      els.uiRemain.textContent = `${remainingCount} players`;

      els.playersGrid.innerHTML = cast.map((name) => {
        const id = slugify(name);
        const isOut = eliminated.has(name.toLowerCase());
        const title = titlesMap?.[name.toLowerCase()] || "";
        const subtitle = title ? escapeHtml(title) : "‚Äî";
        const classes = "player-card" + (isOut ? " eliminated" : "");
        return `
          <a class="${classes}" href="player.html?player=${id}" data-player="${id}">
            <div class="pc-avatar">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
              <span class="pc-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
            </div>
            <div class="pc-name">${escapeHtml(name)}</div>
            <div class="pc-title">${subtitle}</div>
            ${isOut ? `<div class="pc-badge">ELIMINATED</div>` : ``}
          </a>
        `;
      }).join("");
    }

    // ----------------------------
    // Rendering: Overview cards
    // ----------------------------
    function renderMoveCard(targetEl, moveObj) {
      if (!moveObj || !moveObj.player) { targetEl.textContent = "‚Äî"; return; }
      const id = slugify(moveObj.player);
      targetEl.innerHTML = `
        <div class="rowline">
          <div class="mini-avatar">
            <img src="assets/avatars/${id}.png" alt="${escapeHtml(moveObj.player)}"
              onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
              onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
            <span class="mini-fallback">${escapeHtml((moveObj.player||'?').slice(0,1).toUpperCase())}</span>
          </div>
          <div class="rowtext">
            <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(moveObj.player)}</b></a>
            <div class="muted">${escapeHtml(moveObj.reason || "")}</div>
          </div>
        </div>
      `;
    }

    function renderBootOdds(targetEl, bootPredictions) {
      if (!Array.isArray(bootPredictions) || bootPredictions.length === 0) {
        targetEl.textContent = "No boot predictions returned.";
        return;
      }
      
      // Sort by probability descending (highest risk first)
      const sorted = [...bootPredictions].sort((a, b) => (Number(b.prob) || 0) - (Number(a.prob) || 0));
      
      targetEl.innerHTML = sorted
        .map((p) => {
          const name = p.player || "";
          const id = slugify(name);
          const pct = Math.round((Number(p.prob) || 0) * 100);
          return `
            <div class="bar-row">
              <div class="bar-head">
                <div class="bar-left">
                  <span class="tiny-avatar">
                    <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                      onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                    <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                  </span>
                  <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                </div>
                <div class="bar-pct">${pct}%</div>
              </div>
              <div class="bar-track"><div class="bar-fill" style="width:${pct}%"></div></div>
              <div class="bar-note">${escapeHtml(p.why || "")}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderPowerRankings(targetEl, powerRankings) {
      if (!Array.isArray(powerRankings) || powerRankings.length === 0) {
        targetEl.textContent = "No power rankings returned.";
        return;
      }
      targetEl.innerHTML = powerRankings
        .map((r) => {
          const name = r.player || "";
          const id = slugify(name);
          const score = Math.round(Number(r.score) || 0);
          const tag = (r.tag || "Steady").toLowerCase();
          const tagClass = tag === "rising" ? "tag tag-up" : tag === "falling" ? "tag tag-down" : "tag tag-steady";
          return `
            <div class="bar-row">
              <div class="bar-head">
                <div class="bar-left">
                  <span class="tiny-avatar">
                    <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                      onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                    <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                  </span>
                  <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                  <span class="${tagClass}">${escapeHtml(r.tag || "Steady")}</span>
                </div>
                <div class="bar-pct">${score}/100</div>
              </div>
              <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
              <div class="bar-note">${escapeHtml(r.blurb || "")}</div>
            </div>
          `;
        })
        .join("");
    }

    function renderAllianceStability(targetEl, allianceStability) {
      if (!Array.isArray(allianceStability) || allianceStability.length === 0) {
        targetEl.textContent = "No alliances detected (or none provided).";
        return;
      }
      targetEl.innerHTML = allianceStability.map((a) => {
        const score = Math.max(0, Math.min(100, Math.round(Number(a.score) || 0)));
        return `
          <div class="bar-row">
            <div class="bar-head">
              <div class="bar-left"><b>${escapeHtml(a.name || "Alliance")}</b></div>
              <div class="bar-pct">${score}/100</div>
            </div>
            <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
            <div class="bar-note">${escapeHtml(a.note || "")}</div>
          </div>
        `;
      }).join("");
    }

    function renderTitles(targetEl, titles) {
      if (!Array.isArray(titles) || titles.length === 0) {
        targetEl.textContent = "No titles returned.";
        return;
      }
      targetEl.innerHTML = titles.map((t) => {
        const name = t.player || "";
        const id = slugify(name);
        return `
          <div class="title-row">
            <span class="tiny-avatar">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
              <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
            </span>
            <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
            <span class="muted">‚Äî</span>
            <span>${escapeHtml(t.title || "")}</span>
          </div>
        `;
      }).join("");
    }

    function renderSocialNetwork(targetEl, socialNetwork) {
      if (!Array.isArray(socialNetwork) || socialNetwork.length === 0) {
        targetEl.textContent = "No social network data returned.";
        return;
      }
      targetEl.innerHTML = socialNetwork.map((s) => {
        const name = s.player || "";
        const id = slugify(name);
        const likes = s.strongLikes || [];
        const dislikes = s.strongDislikes || [];
        const centrality = Math.round(Number(s.centralityScore) || 0);
        const isolated = s.isolated ? 'üî¥ Isolated' : '';
        
        return `
          <div class="bar-row">
            <div class="bar-head" style="flex-direction: column; align-items: flex-start; gap: 6px;">
              <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                <span class="muted" style="margin-left: auto; font-size: 11px;">Centrality: ${centrality}/100 ${isolated}</span>
              </div>
              <div style="font-size: 12px; opacity: 0.8;">
                ${likes.length > 0 ? `üíö Likes: ${escapeHtml(likes.join(', '))}` : ''}
                ${likes.length > 0 && dislikes.length > 0 ? '<br/>' : ''}
                ${dislikes.length > 0 ? `‚ù§Ô∏è‚Äçüî• Dislikes: ${escapeHtml(dislikes.join(', '))}` : ''}
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderJuryManagement(targetEl, juryManagement) {
      if (!Array.isArray(juryManagement) || juryManagement.length === 0) {
        targetEl.textContent = "No jury management data returned.";
        return;
      }
      
      const sorted = [...juryManagement].sort((a, b) => (Number(b.score) || 0) - (Number(a.score) || 0));
      
      targetEl.innerHTML = sorted.map((j) => {
        const name = j.player || "";
        const id = slugify(name);
        const score = Math.round(Number(j.score) || 0);
        const note = j.note || "";
        
        return `
          <div class="bar-row">
            <div class="bar-head">
              <div class="bar-left">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
              </div>
              <div class="bar-pct">${score}/100</div>
            </div>
            <div class="bar-track"><div class="bar-fill" style="width:${score}%"></div></div>
            <div class="bar-note">${escapeHtml(note)}</div>
          </div>
        `;
      }).join("");
    }

    function renderThreatBreakdown(targetEl, threatBreakdown) {
      if (!Array.isArray(threatBreakdown) || threatBreakdown.length === 0) {
        targetEl.textContent = "No threat breakdown data returned.";
        return;
      }
      
      // Calculate totals and sort by total threat (highest to lowest)
      const withTotals = threatBreakdown.map((t) => {
        const physical = Math.round(Number(t.physical) || 0);
        const strategic = Math.round(Number(t.strategic) || 0);
        const social = Math.round(Number(t.social) || 0);
        const advantage = Math.round(Number(t.advantage) || 0);
        const total = Math.round((physical + strategic + social + advantage) / 4);
        return { ...t, physical, strategic, social, advantage, total };
      });
      
      const sorted = withTotals.sort((a, b) => b.total - a.total);
      
      targetEl.innerHTML = sorted.map((t) => {
        const name = t.player || "";
        const id = slugify(name);
        
        return `
          <div class="bar-row">
            <div class="bar-head" style="flex-direction: column; align-items: flex-start; gap: 8px;">
              <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                <span class="muted" style="margin-left: auto;">Total: ${t.total}/100</span>
              </div>
              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; width: 100%; font-size: 11px;">
                <div>üí™ Phys: ${t.physical}</div>
                <div>üß† Strat: ${t.strategic}</div>
                <div>ü§ù Social: ${t.social}</div>
                <div>üéÅ Adv: ${t.advantage}</div>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderPathToVictory(targetEl, pathToVictory) {
      if (!Array.isArray(pathToVictory) || pathToVictory.length === 0) {
        targetEl.textContent = "No path to victory data returned.";
        return;
      }
      
      const viabilityOrder = { 'High': 1, 'Medium': 2, 'Low': 3, 'None': 4 };
      const sorted = [...pathToVictory].sort((a, b) => 
        (viabilityOrder[a.viability] || 99) - (viabilityOrder[b.viability] || 99)
      );
      
      targetEl.innerHTML = sorted.map((p) => {
        const name = p.player || "";
        const id = slugify(name);
        const viability = p.viability || "Unknown";
        const winCondition = p.winCondition || "";
        const obstacles = p.obstacles || "";
        
        const viabilityColor = {
          'High': '#4ade80',
          'Medium': '#fbbf24',
          'Low': '#fb923c',
          'None': '#ef4444'
        }[viability] || '#9ca3af';
        
        return `
          <div class="bar-row">
            <div class="bar-head" style="flex-direction: column; align-items: flex-start; gap: 8px;">
              <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <a class="plink" href="player.html?player=${id}"><b>${escapeHtml(name)}</b></a>
                <span style="margin-left: auto; padding: 2px 8px; border-radius: 6px; font-size: 11px; font-weight: 700; background: ${viabilityColor}22; color: ${viabilityColor}; border: 1px solid ${viabilityColor};">
                  ${escapeHtml(viability)}
                </span>
              </div>
              <div style="font-size: 12px; opacity: 0.9;">
                <div><b>Win Condition:</b> ${escapeHtml(winCondition)}</div>
                <div style="margin-top: 4px;"><b>Obstacles:</b> ${escapeHtml(obstacles)}</div>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderAllianceOverview(targetEl, analytics, summaryText) {
      // Lightweight: show top alliance stability + any named alliances in summary (best effort)
      const st = Array.isArray(analytics?.allianceStability) ? analytics.allianceStability : [];
      const top = st.slice(0, 2).map(a => `${a.name} (${Math.round(Number(a.score)||0)}/100)`).join(", ");
      const has = top ? `<b>Detected:</b> ${escapeHtml(top)}<br/>` : "";

      // Try to detect any explicit "Alliance Status" block names
      const m = (summaryText||"").match(/Alliance Status[\s\S]*?(CHALLENGES|POST-CHALLENGE|VOTING|TRIBAL)/i);
      const snippet = m ? m[0].split("\n").slice(0, 18).join("\n") : "";
      const lines = snippet.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const allianceNames = lines
        .filter(l => /^[A-Za-z0-9][A-Za-z0-9_-]{2,}\s*\(/.test(l))
        .map(l => l.split("(")[0].trim())
        .slice(0, 4);

      const extra = allianceNames.length ? `<div class="muted small">From summary: ${escapeHtml(allianceNames.join(", "))}</div>` : `<div class="muted small">No named alliances found yet.</div>`;
      targetEl.innerHTML = has + extra;
    }

    // ----------------------------
    // Rendering: Gameplay page
    // ----------------------------
    function renderCompass(analytics, castNames, eliminatedNames) {
      const eliminated = new Set((eliminatedNames||[]).map(n=>n.toLowerCase()));

      // Build a map of power scores
      const pr = Array.isArray(analytics?.powerRankings) ? analytics.powerRankings : [];
      const bm = new Map(pr.map(x => [(x.player||"").toLowerCase(), Math.max(0, Math.min(100, Number(x.score)||0))]));

      const bp = Array.isArray(analytics?.bootPredictions) ? analytics.bootPredictions : [];
      const probMap = new Map(bp.map(x => [(x.player||"").toLowerCase(), Math.max(0, Math.min(1, Number(x.prob)||0))]));

      const active = (castNames||[]).filter(n => !eliminated.has(n.toLowerCase()));
      const points = active.slice(0, 30).map((name) => {
        const key = name.toLowerCase();
        const power = bm.get(key) ?? 50;
        
        // Use boot prediction from AI if available
        // Otherwise use a safe default based on power
        let prob = probMap.get(key);
        if (prob === undefined) {
          // Fallback: If AI didn't include this player, assume moderate-low risk
          // Power 100 = 10% risk, Power 50 = 20% risk, Power 0 = 40% risk
          prob = Math.max(0.10, Math.min(0.40, 0.50 - (power / 100) * 0.40));
        }
        
        // x: power (0..100)
        // y: safety = 100 - prob*100
        const x = power;
        const y = 100 - prob*100;
        return { name, x, y, prob, power };
      });
      
      // Normalize to use full compass space
      const xValues = points.map(p => p.x);
      const yValues = points.map(p => p.y);
      const xMin = Math.min(...xValues);
      const xMax = Math.max(...xValues);
      const yMin = Math.min(...yValues);
      const yMax = Math.max(...yValues);
      
      // Scale to 10-90 range for better visualization (with 10% padding)
      const normalizedPoints = points.map(p => {
        const xRange = xMax - xMin || 1;
        const yRange = yMax - yMin || 1;
        const xNorm = 10 + ((p.x - xMin) / xRange) * 80;
        const yNorm = 10 + ((p.y - yMin) / yRange) * 80;
        return { name: p.name, x: xNorm, y: yNorm };
      });

      els.compassPoints.innerHTML = normalizedPoints.map((p) => {
        const id = slugify(p.name);
        // convert x,y (0..100) to %
        const left = Math.max(3, Math.min(97, p.x));
        const top = Math.max(3, Math.min(97, 100 - p.y)); // invert for CSS top
        return `
          <a class="dot" href="player.html?player=${id}" style="left:${left}%;top:${top}%;">
            <span class="dot-circle">
              <img src="assets/avatars/${id}.png" alt="${escapeHtml(p.name)}"
                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                onload="this.style.display='block'; this.nextElementSibling.style.display='none';" />
              <span class="dot-fallback">${escapeHtml((p.name||'?').slice(0,1).toUpperCase())}</span>
            </span>
            <span class="dot-label">${escapeHtml(p.name)}</span>
          </a>
        `;
      }).join("");
    }

    function renderGameplayTable(analytics, castNames, eliminatedNames, titlesMap) {
      const eliminated = new Set((eliminatedNames||[]).map(n=>n.toLowerCase()));
      const pr = Array.isArray(analytics?.powerRankings) ? analytics.powerRankings : [];
      const bp = Array.isArray(analytics?.bootPredictions) ? analytics.bootPredictions : [];
      const rolesArr = Array.isArray(analytics?.roles) ? analytics.roles : [];

      const powerMap = new Map(pr.map(x => [(x.player||"").toLowerCase(), x]));
      const probMap = new Map(bp.map(x => [(x.player||"").toLowerCase(), x]));
      const rolesMap = new Map(rolesArr.map(x => [(x.player||"").toLowerCase(), x.role||""]));

      const active = (castNames||[]).filter(n => !eliminated.has(n.toLowerCase()));
      const rows = active.map((name) => {
        const key = name.toLowerCase();
        const r = powerMap.get(key) || { player: name, score: 50, tag: "Steady", blurb: "" };
        const p = probMap.get(key) || { prob: 0.15, why: "" };
        const score = Math.round(Number(r.score)||0);
        const prob = Math.round((Number(p.prob)||0)*100);
        const title = titlesMap?.[key] || "";
        
        // Use AI-generated role from analytics, fallback to calculated role
        const role = rolesMap.get(key) || (
          prob >= 35 ? "In Danger" :
          score >= 80 ? "Power Player" :
          score >= 65 ? "Well-Positioned" :
          "Under the Radar"
        );
        
        return { name, score, prob, tag: r.tag || "Steady", title, role };
      }).sort((a,b)=>b.score-a.score);

      els.gpTableBody.innerHTML = rows.map((row) => {
        const id = slugify(row.name);
        const tag = (row.tag||"Steady").toLowerCase();
        const tagClass = tag==="rising" ? "tag tag-up" : tag==="falling" ? "tag tag-down" : "tag tag-steady";
        return `
          <tr>
            <td>
              <a class="plink row-player" href="player.html?player=${id}">
                <span class="tiny-avatar">
                  <img src="assets/avatars/${id}.png" alt="${escapeHtml(row.name)}"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-flex';"
                    onload="this.style.display='inline-flex'; this.nextElementSibling.style.display='none';" />
                  <span class="tiny-fallback">${escapeHtml((row.name||'?').slice(0,1).toUpperCase())}</span>
                </span>
                <b>${escapeHtml(row.name)}</b>
              </a>
            </td>
            <td class="muted">${escapeHtml(row.title || "‚Äî")}</td>
            <td><span class="${tagClass}">${escapeHtml(row.tag)}</span></td>
            <td>${row.score}</td>
            <td>${row.prob}%</td>
            <td>${escapeHtml(row.role)}</td>
          </tr>
        `;
      }).join("");
    }

    // ----------------------------
    // Main render from analytics
    // ----------------------------
    function renderAll(analytics, summaryText) {
      if (!analytics || typeof analytics !== "object") return;

      // Titles map for quick lookups
      const titlesArr = Array.isArray(analytics.titles) ? analytics.titles : [];
      const titlesMap = {};
      for (const t of titlesArr) {
        if (t?.player) titlesMap[t.player.toLowerCase()] = t.title || "";
      }

      CURRENT.titlesMap = titlesMap;

      // Detect cast + eliminated from current summary input (best effort)
      const txt = (summaryText || els.summary.value || "").trim();

      // Prefer parsing from summary; fall back to saved cast state if summary isn't present.
      let cast = parseCastFromSummary(txt);
      let eliminated = parseEliminated(txt);

      const seasonNow = Number(els.season.value || 1);
      const episodeNow = Number(els.episode.value || 1);

      if ((!cast || cast.length === 0) || (eliminated && eliminated.size === 0 && !txt)) {
        const saved = loadCastState(seasonNow, episodeNow);
        if (saved) {
          if (!cast || cast.length === 0) cast = Array.isArray(saved.cast) ? saved.cast : [];
          if ((!eliminated || eliminated.size === 0) && Array.isArray(saved.eliminated)) {
            eliminated = new Set(saved.eliminated.map(s => String(s).toLowerCase()));
          }
          if (!txt && saved.title && els.uiEpName) {
            els.uiEpName.textContent = saved.title;
          }
        }
      }

      // Save for later use (tab switches, etc.)
      CURRENT.analytics = analytics;
      CURRENT.season = seasonNow;
      CURRENT.episode = episodeNow;
      CURRENT.summaryText = txt;
      CURRENT.cast = cast || [];
      CURRENT.eliminated = eliminated || new Set();

      renderPlayersGrid(cast, eliminated, titlesMap);

      // Overview cards
      renderMoveCard(els.cardBestMove, analytics.bestMove);
      renderMoveCard(els.cardBiggestRisk, analytics.biggestRisk);
      els.cardEpisodeSummary.textContent = analytics.narrativeSummary || "‚Äî";
      renderAllianceOverview(els.cardAllianceOverview, analytics, txt);
      renderBootOdds(els.cardBootOdds, analytics.bootPredictions);
      renderPowerRankings(els.cardPowerRankings, analytics.powerRankings);
      renderAllianceStability(els.cardAllianceStability, analytics.allianceStability);
      renderTitles(els.cardTitles, analytics.titles);
      renderSocialNetwork(els.cardSocialNetwork, analytics.socialNetwork);
      renderJuryManagement(els.cardJuryManagement, analytics.juryManagement);
      renderThreatBreakdown(els.cardThreatBreakdown, analytics.threatBreakdown);
      renderPathToVictory(els.cardPathToVictory, analytics.pathToVictory);

      // Gameplay
      renderCompass(analytics, cast, eliminated, titlesMap);
      renderGameplayTable(analytics, cast, eliminated, titlesMap);
    }

    // ----------------------------
    // Tabs
    // ----------------------------
    function showTab(which) {
      const isOverview = which === "overview";
      const isGameplay = which === "gameplay";
      const isEpisode = which === "episode";
      const isSeasonSetup = which === "seasonsetup";

      els.viewOverview.classList.toggle("hidden", !isOverview);
      els.viewGameplay.classList.toggle("hidden", !isGameplay);
      els.viewEpisode.classList.toggle("hidden", !isEpisode);
      els.viewSeasonSetup.classList.toggle("hidden", !isSeasonSetup);

      els.tabOverview.classList.toggle("active", isOverview);
      els.tabGameplay.classList.toggle("active", isGameplay);
      els.tabEpisode.classList.toggle("active", isEpisode);
      els.tabSeasonSetup.classList.toggle("active", isSeasonSetup);
      
      els.tabOverview.setAttribute("aria-selected", isOverview ? "true" : "false");
      els.tabGameplay.setAttribute("aria-selected", isGameplay ? "true" : "false");
      els.tabEpisode.setAttribute("aria-selected", isEpisode ? "true" : "false");
      els.tabSeasonSetup.setAttribute("aria-selected", isSeasonSetup ? "true" : "false");

      // Persist tab choice per episode
      const s = Number(els.season.value || 1);
      const e = Number(els.episode.value || 1);
      try { localStorage.setItem(tabKey(s, e), which); } catch {}

      // If switching to gameplay, ensure it's rendered (in case cast was synced later)
      if (isGameplay && CURRENT.analytics) {
        const cast = (CURRENT.cast && CURRENT.cast.length) ? CURRENT.cast : parseCastFromSummary(CURRENT.summaryText || "");
        const eliminated = (CURRENT.eliminated && CURRENT.eliminated.size) ? CURRENT.eliminated : parseEliminated(CURRENT.summaryText || "");
        renderCompass(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
        renderGameplayTable(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
      }
    }

    els.tabOverview.addEventListener("click", () => showTab("overview"));
    els.tabGameplay.addEventListener("click", () => showTab("gameplay"));
    els.tabEpisode.addEventListener("click", () => {
      showTab("episode");
      // Try to auto-load saved episode
      if (typeof loadEpisode === 'function') loadEpisode();
    });
    els.tabSeasonSetup.addEventListener("click", () => showTab("seasonsetup"));

    // ----------------------------
    // Actions
    // ----------------------------
    els.saveUrl.addEventListener("click", () => {
      const url = normalizeWorkerUrl(els.workerUrl.value);
      if (!url) return setStatus("Enter a Worker URL first.");
      els.workerUrl.value = url;
      localStorage.setItem("AI_ENDPOINT_URL", url);
      setStatus("Saved AI endpoint.");
    });

    els.syncFromSummary.addEventListener("click", () => {
      const txt = els.summary.value || "";
      const s = Number(els.season.value || 1);

      const ep = parseEpisodeTitle(txt);
      if (ep?.num) els.episode.value = ep.num;

      const e = Number(els.episode.value || 1);
      if (ep?.title) els.uiEpName.textContent = `‚Äú${ep.title}‚Äù`;
      els.uiEpNum.textContent = `Episode ${e}`;

      // Persist summary + cast for reloads
      saveSummary(s, e, txt);

      const cast = parseCastFromSummary(txt);
      const eliminated = parseEliminated(txt);

      // Save cast state even if empty (lets us show ‚Äúno cast detected‚Äù consistently)
      saveCastState(s, e, cast, eliminated, ep?.title ? `‚Äú${ep.title}‚Äù` : els.uiEpName.textContent);

      // Update runtime state
      CURRENT.season = s;
      CURRENT.episode = e;
      CURRENT.summaryText = (txt || "").trim();
      CURRENT.cast = cast;
      CURRENT.eliminated = eliminated;

      renderPlayersGrid(cast, eliminated, {});
      // If AI already loaded, refresh gameplay view too
      if (CURRENT.analytics) {
        renderCompass(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
        renderGameplayTable(CURRENT.analytics, cast, eliminated, CURRENT.titlesMap || {});
      }

      setStatus("Synced from summary (saved for reload).");
    });

    async function callAI(season, episode, summaryText) {
      const url = normalizeWorkerUrl(els.workerUrl.value || localStorage.getItem("AI_ENDPOINT_URL") || "");
      if (!url) throw new Error("Missing AI endpoint URL.");
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ season, episode, summaryText }),
      });
      const data = await res.json();
      if (!res.ok) {
        // Try to surface OpenAI error nicely
        const msg = data?.error?.message || data?.message || "Unknown error.";
        throw new Error(msg);
      }
      
      // VALIDATION: Auto-fill missing players
      const cast = parseCastFromSummary(summaryText);
      const eliminated = parseEliminated(summaryText);
      const active = cast.filter(name => !eliminated.some(e => e.toLowerCase() === name.toLowerCase()));
      
      // Ensure all active players are in bootPredictions
      if (Array.isArray(data.bootPredictions)) {
        const bootMap = new Map(data.bootPredictions.map(x => [x.player.toLowerCase(), x]));
        active.forEach(player => {
          const key = player.toLowerCase();
          if (!bootMap.has(key)) {
            // Missing player - add with default low risk
            console.warn(`Missing in bootPredictions: ${player} - auto-adding with 10% risk`);
            data.bootPredictions.push({
              player: player,
              prob: 0.10,
              why: "Not in AI's top predictions; assumed moderate safety."
            });
          }
        });
      }
      
      // Ensure all active players are in powerRankings
      if (Array.isArray(data.powerRankings)) {
        const powerMap = new Map(data.powerRankings.map(x => [x.player.toLowerCase(), x]));
        active.forEach(player => {
          const key = player.toLowerCase();
          if (!powerMap.has(key)) {
            // Missing player - add with default middle score
            console.warn(`Missing in powerRankings: ${player} - auto-adding with score 50`);
            data.powerRankings.push({
              player: player,
              score: 50,
              tag: "Steady",
              blurb: "Not in AI's detailed rankings; neutral position."
            });
          }
        });
      }
      
      return data;
    }

    function loadCached(season, episode) {
      const key = cacheKey(season, episode);
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function summaryKey(season, episode) {
      return `AI_SUMMARY_s${season}_e${episode}`;
    }
    function castStateKey(season, episode) {
      return `AI_CAST_s${season}_e${episode}`;
    }
    function tabKey(season, episode) {
      return `AI_TAB_s${season}_e${episode}`;
    }

    function saveSummary(season, episode, text) {
      try { localStorage.setItem(summaryKey(season, episode), text || ""); } catch {}
    }
    function loadSummary(season, episode) {
      try { return localStorage.getItem(summaryKey(season, episode)) || ""; } catch { return ""; }
    }

    function saveCastState(season, episode, cast, eliminated, epTitle) {
      const payload = { cast: cast || [], eliminated: Array.from(eliminated || []), title: epTitle || "" };
      try { localStorage.setItem(castStateKey(season, episode), JSON.stringify(payload)); } catch {}
    }
    function loadCastState(season, episode) {
      try {
        const raw = localStorage.getItem(castStateKey(season, episode));
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }

    // Runtime state
    let CURRENT = {
      analytics: null,
      season: null,
      episode: null,
      summaryText: "",
      cast: [],
      eliminated: new Set(),
      titlesMap: {}
    };

    function saveCached(season, episode, analytics) {
      const key = cacheKey(season, episode);
      localStorage.setItem(key, JSON.stringify(analytics));
      saveLastSelection(season, episode);
    }

    function updateEpisodeHeaderFromInputs() {
      const epNum = Number(els.episode.value || 1);
      els.uiEpNum.textContent = `Episode ${epNum}`;
      // Keep title as-is unless we can parse one
      if (!els.uiEpName.textContent || els.uiEpName.textContent === "‚Äî") {
        const parsed = parseEpisodeTitle(els.summary.value || "");
        if (parsed?.title) els.uiEpName.textContent = `‚Äú${parsed.title}‚Äù`;
      }
    }

    els.generate.addEventListener("click", async () => {
      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);
      const summaryText = els.summary.value || "";
      if (!summaryText.trim()) return setStatus("Paste an episode summary first.");

      // Persist summary so reload keeps cast + gameplay
      saveSummary(season, episode, summaryText);

      updateEpisodeHeaderFromInputs();
      setStatus("Generating analytics...");

      try {
        const analytics = await callAI(season, episode, summaryText);
        saveCached(season, episode, analytics);

        // Save cast/elims for reloads
        const cast = parseCastFromSummary(summaryText);
        const eliminated = parseEliminated(summaryText);
        const ep = parseEpisodeTitle(summaryText);
        const epTitle = ep?.title ? `‚Äú${ep.title}‚Äù` : els.uiEpName.textContent;
        saveCastState(season, episode, cast, eliminated, epTitle);

        // üÜï AUTO-UPDATE PLAYER DATABASE WITH ELIMINATIONS
        if (typeof updatePlayerEliminationsFromEpisode === 'function') {
          updatePlayerEliminationsFromEpisode(season, episode, cast, eliminated);
        }

        renderAll(analytics, summaryText);

        setStatus(`Done. Cached as ${cacheKey(season, episode)}.`);
      } catch (e) {
        setStatus("Error: " + (e?.message || String(e)));
        console.error(e);
      }
    });

    els.loadCached.addEventListener("click", () => {
      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);
      updateEpisodeHeaderFromInputs();
      const cached = loadCached(season, episode);
      if (!cached) return setStatus("No cached analytics found for this season/episode.");
      renderAll(cached, els.summary.value || "");
      setStatus("Loaded cached analytics.");
    });


    // ----------------------------
    // Season/Episode switching
    // ----------------------------
    function clearRenderedUI() {
      // Overview placeholders
      els.cardBestMove.innerHTML = "‚Äî";
      els.cardBiggestRisk.innerHTML = "‚Äî";
      els.cardEpisodeSummary.textContent = "‚Äî";
      els.cardBootOdds.innerHTML = "<div class='muted'>No boot predictions yet.</div>";
      els.cardPowerRankings.innerHTML = "<div class='muted'>No power rankings yet.</div>";
      els.cardAllianceOverview.innerHTML = "<div class='muted'>No alliance info yet.</div>";
      els.cardAllianceStability.innerHTML = "<div class='muted'>No alliance stability yet.</div>";
      els.cardTitles.innerHTML = "<div class='muted'>No titles yet.</div>";
      els.cardSocialNetwork.innerHTML = "<div class='muted'>No social network data yet.</div>";
      els.cardJuryManagement.innerHTML = "<div class='muted'>No jury management data yet.</div>";
      els.cardThreatBreakdown.innerHTML = "<div class='muted'>No threat breakdown yet.</div>";
      els.cardPathToVictory.innerHTML = "<div class='muted'>No path to victory data yet.</div>";

      // Gameplay placeholders
      // els.gpSvg.innerHTML = ""; // REMOVED - element doesnt exist
      els.gpTableBody.innerHTML = "";

      // Players placeholder
      els.playersGrid.innerHTML =
        "<div class='muted'>No cast detected yet. Paste your summary and click ‚ÄúSync title/players from summary‚Äù.</div>";

      // Reset runtime
      CURRENT.analytics = null;
      CURRENT.summaryText = "";
      CURRENT.cast = [];
      CURRENT.eliminated = new Set();
      CURRENT.titlesMap = {};
    }

    function applySelection(season, episode, opts = {}) {
      const { quiet=false } = opts;

      // Persist last selection (so reload returns here)
      saveLastSelection(season, episode);

      // Update inputs (normalize)
      els.season.value = String(season);
      els.episode.value = String(episode);

      // Restore summary + cast state for this selection
      const savedSummary = loadSummary(season, episode);
      els.summary.value = savedSummary || "";

      // Restore episode title (from saved cast state) if available
      const savedCast = loadCastState(season, episode);
      if (savedCast?.title) {
        els.uiEpName.textContent = savedCast.title;
      } else {
        els.uiEpName.textContent = "‚Äî";
      }
      els.uiEpNum.textContent = `Episode ${episode}`;

      // Restore last tab for this episode
      let savedTab = "overview";
      try { savedTab = localStorage.getItem(tabKey(season, episode)) || "overview"; } catch {}
      showTab(savedTab === "gameplay" ? "gameplay" : "overview");

      // If we have cached analytics for this selection, load it (if auto-load enabled)
      const cached = loadCached(season, episode);

      if (cached && els.autoLoad.checked) {
        renderAll(cached, els.summary.value || "");
        if (!quiet) setStatus("Loaded cached analytics for this season/episode.");
        return;
      }

      // Otherwise, reset UI and show cast if we can infer it
      clearRenderedUI();

      const txt = els.summary.value || "";
      const cast = parseCastFromSummary(txt);
      const eliminated = parseEliminated(txt);

      if (cast.length) {
        renderPlayersGrid(cast, eliminated, {});
      } else if (savedCast?.cast?.length) {
        const elim = new Set((savedCast.eliminated || []).map(s => String(s).toLowerCase()));
        renderPlayersGrid(savedCast.cast, elim, {});
      }

      if (!quiet) {
        setStatus(cached ? "Cached analytics exists for this episode ‚Äî click ‚ÄúLoad Cached‚Äù (or enable auto-load)." : "No cached analytics for this season/episode yet.");
      }
    }

    // Change handlers
    function onSeasonEpisodeChange() {
      const s = Number(els.season.value || 1);
      const e = Number(els.episode.value || 1);
      applySelection(s, e);
    }
    els.season.addEventListener("change", onSeasonEpisodeChange);
    els.episode.addEventListener("change", onSeasonEpisodeChange);

    // ----------------------------
    // Init
    // ----------------------------
    (function init() {
      // Load endpoint
      const savedUrl = localStorage.getItem("AI_ENDPOINT_URL");
      if (savedUrl) els.workerUrl.value = savedUrl;

      // Restore last selection (so reload returns to the last viewed episode)
      const last = loadLastSelection();
      if (last?.season) els.season.value = last.season;
      if (last?.episode) els.episode.value = last.episode;

      const season = Number(els.season.value || 1);
      const episode = Number(els.episode.value || 1);

      // Apply selection: restores summary, cast, tab, and (optionally) cached analytics
      applySelection(season, episode, { quiet: true });

      // Friendly status
      const cached = loadCached(season, episode);
      if (cached && els.autoLoad.checked) setStatus("Auto-loaded cached analytics.");
      else if (cached) setStatus("Cached analytics found ‚Äî enable auto-load or click ‚ÄúLoad Cached‚Äù.");
      else setStatus("Ready ‚Äî paste summary and generate analytics.");
    })();
  })();
  
  // ========================================
  // EPISODE TAB FUNCTIONALITY (Global scope for onclick handlers)
  // ========================================
  
  // Configuration
  const EPISODE_WORKER_URL = 'https://dc-analytics.yannari19.workers.dev'; // Update with your worker URL
  
  // Character avatar mapping
  const CHARACTER_AVATARS = {
    'chris': 'üòè', 'chef': 'üë®‚Äçüç≥', 'owen': 'üçî', 'gwen': 'üé®', 'duncan': 'üíÄ',
    'courtney': 'üìã', 'heather': 'üíÖ', 'lindsay': 'üíÅ', 'alejandro': 'üëë',
    'sierra': 'üì±', 'noah': 'üìö', 'cody': 'üò¨', 'izzy': 'ü§™', 'eva': 'üò†',
    'tyler': 'üèÄ', 'trent': 'üé∏', 'bridgette': 'üèÑ', 'geoff': 'üéâ', 'beth': 'üå∏',
    'justin': 'üòé', 'katie': 'üíñ', 'sadie': 'üíñ', 'ezekiel': 'üèîÔ∏è', 'leshawna': 'üíÅ',
    'harold': 'ü§ì', 'amy': 'üòà', 'samey': 'üòä', 'scarlett': 'üß™', 'max': 'ü¶π',
    'ella': 'üé∂', 'topher': 'üì∫', 'jasmine': 'üåø', 'shawn': 'üßü', 'dave': 'üò§',
    'sky': 'ü•ã', 'sugar': 'üç≠', 'rodney': 'üíò', 'beardo': 'üéµ', 'leonard': 'ü™Ñ',
    'josee': '‚õ∑Ô∏è', 'mickey': 'üê≠', 'ryan': 'üèãÔ∏è', 'blaineley': 'üé§'
  };
  
  // Storage key generator
  function getEpisodeStorageKey() {
    const seasonEl = document.getElementById('aiSeason');
    const episodeEl = document.getElementById('aiEpisode');
    const season = seasonEl ? seasonEl.value : '5';
    const episode = episodeEl ? episodeEl.value : '1';
    return `td_episode_s${season}_e${episode}`;
  }
  
  // Save episode to localStorage
  function saveEpisode() {
    const transcript = document.getElementById('episode-input').value;
    if (!transcript.trim()) {
      alert('‚ö†Ô∏è Please paste or generate an episode transcript first!');
      return;
    }
    
    localStorage.setItem(getEpisodeStorageKey(), transcript);
    alert('‚úÖ Episode saved successfully!');
    renderEpisode();
  }
  
  // Load episode from localStorage
  function loadEpisode() {
    const saved = localStorage.getItem(getEpisodeStorageKey());
    if (saved) {
      document.getElementById('episode-input').value = saved;
      renderEpisode();
      return true;
    }
    return false;
  }
  
  // Clear episode
  function clearEpisode() {
    if (confirm('‚ö†Ô∏è Clear the current episode? This cannot be undone.')) {
      document.getElementById('episode-input').value = '';
      document.getElementById('episode-rendered').innerHTML = '';
      localStorage.removeItem(getEpisodeStorageKey());
      alert('üóëÔ∏è Episode cleared!');
    }
  }
  
  // Generate episode using AI
  async function generateEpisodeAI() {
    // Safety check: ensure EPISODE_WORKER_URL is defined
    if (typeof EPISODE_WORKER_URL === 'undefined') {
      console.error('EPISODE_WORKER_URL not initialized yet. Please refresh the page.');
      alert('‚ö†Ô∏è Page not fully loaded. Please refresh and try again.');
      return;
    }
    
    const summaryInput = document.getElementById('episode-summary-input');
    const summary = summaryInput ? summaryInput.value.trim() : '';
    
    if (!summary) {
      alert('‚ö†Ô∏è Please paste your BrantSteele episode summary first!');
      return;
    }
    
    const seasonEl = document.getElementById('aiSeason');
    const episodeEl = document.getElementById('aiEpisode');
    const season = seasonEl ? seasonEl.value : '5';
    const episode = episodeEl ? episodeEl.value : '1';
    
    const generateBtn = document.getElementById('generate-episode-btn');
    const originalText = generateBtn.innerHTML;
    generateBtn.innerHTML = '‚è≥ Generating Episode...';
    generateBtn.disabled = true;
    
    try {
      const response = await fetch(EPISODE_WORKER_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          mode: 'episode',
          season: season,
          episode: episode,
          summaryText: summary
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      const transcript = data.episodeTranscript || data.output_text || '';
      
      if (!transcript) {
        throw new Error('No episode transcript returned from AI');
      }
      
      document.getElementById('episode-input').value = transcript;
      saveEpisode();
      alert('‚úÖ Episode generated successfully!');
      
    } catch (error) {
      console.error('Error generating episode:', error);
      alert('‚ùå Error generating episode: ' + error.message);
    } finally {
      generateBtn.innerHTML = originalText;
      generateBtn.disabled = false;
    }
  }
  
  // Render episode from transcript
  function renderEpisode() {
    const transcript = document.getElementById('episode-input').value;
    const container = document.getElementById('episode-rendered');
    
    if (!transcript.trim()) {
      container.innerHTML = `
        <div class="episode-empty">
          <div class="episode-empty-icon">üì∫</div>
          <div class="episode-empty-text">No episode to display.</div>
          <div style="margin-top: 16px; opacity: 0.7; font-size: 14px;">
            Paste a transcript and click "Render Episode" or generate one with AI!
          </div>
        </div>
      `;
      return;
    }
    
    const html = parseTranscript(transcript);
    container.innerHTML = html;
    container.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  // Parse transcript into beautiful HTML with animations
  function parseTranscript(text) {
    let html = '<div class="episode-content">';
    const lines = text.split('\n');
    let currentScene = '';
    let inConfessional = false;
    let inTribal = false;
    let lineIndex = 0; // For staggered animations
    
    lines.forEach((line) => {
      line = line.trim();
      if (!line) return;
      
      // Scene headers: [Scene: ...] or [Location...]
      if (line.match(/^\[.*\]$/)) {
        const sceneText = line.replace(/[\[\]]/g, '');
        
        // Confessional detection
        if (sceneText.toLowerCase().includes('confessional')) {
          if (!inConfessional) {
            html += '<div class="confessional" style="animation-delay: ' + (lineIndex * 0.05) + 's">';
            html += '<div class="confessional-label">üé• ' + escapeHtml(sceneText).toUpperCase() + '</div>';
            inConfessional = true;
            lineIndex++;
          }
          return;
        }
        
        // Close confessional if we hit a new scene
        if (inConfessional && !sceneText.toLowerCase().includes('confessional')) {
          html += '</div>';
          inConfessional = false;
        }
        
        // Tribal Council detection with suspense
        if (sceneText.toLowerCase().includes('tribal') || sceneText.toLowerCase().includes('campfire ceremony')) {
          if (!inTribal) {
            html += '<div class="tribal-council" style="animation-delay: ' + (lineIndex * 0.05) + 's">';
            html += '<div class="tribal-header">üî• ' + escapeHtml(sceneText).toUpperCase() + ' üî•</div>';
            html += '<div class="tribal-suspense">‚è≥ The tension is palpable...</div>';
            inTribal = true;
            lineIndex++;
          }
          return;
        }
        
        // Close tribal if new scene
        if (inTribal && !sceneText.toLowerCase().includes('tribal') && !sceneText.toLowerCase().includes('vote') && !sceneText.toLowerCase().includes('campfire')) {
          html += '</div>';
          inTribal = false;
        }
        
        // Regular scene with sticky header
        if (currentScene && !inConfessional) html += '</div>';
        html += '<div class="scene">';
        html += '<div class="scene-header scene-sticky" style="animation-delay: ' + (lineIndex * 0.05) + 's">üìç ' + escapeHtml(sceneText) + '</div>';
        currentScene = sceneText;
        lineIndex++;
        return;
      }
      
      // Dialogue: "Name: Text" - rendered as chat bubbles
      const dialogueMatch = line.match(/^([A-Z][a-zA-Z\s']+):\s*(.+)$/);
      if (dialogueMatch) {
        let [, character, dialogue] = dialogueMatch;
        character = character.trim();
        const charKey = character.toLowerCase();
        const avatar = getCharacterAvatar(charKey);
        
        html += '<div class="dialogue-line chat-bubble" style="animation-delay: ' + (lineIndex * 0.05) + 's">';
        html += `<div class="character-avatar">${avatar}</div>`;
        html += '<div class="dialogue-bubble">';
        html += `<div class="character-name">${escapeHtml(character)}</div>`;
        html += `<div class="dialogue-text">${escapeHtml(dialogue)}</div>`;
        html += '</div>';
        html += '</div>';
        lineIndex++;
        return;
      }
      
      // Elimination announcement - special styling in Tribal
      if (line.toLowerCase().includes('eliminated') || line.toLowerCase().includes('voted out')) {
        html += `<div class="eliminated-player" style="animation-delay: ' + (lineIndex * 0.05) + 's">`;
        html += `<div class="eliminated-message">${escapeHtml(line)}</div>`;
        html += `</div>`;
        lineIndex++;
        return;
      }
      
      // Vote reveals in Tribal Council with suspense animation
      if (inTribal && (line.toLowerCase().includes('vote') || line.toLowerCase().includes('marshmallow'))) {
        html += `<div class="vote-reveal suspense-reveal" style="animation-delay: ${lineIndex * 0.1}s">${escapeHtml(line)}</div>`;
        lineIndex++;
        return;
      }
      
      // Stage directions or other text
      html += `<div class="stage-direction" style="animation-delay: ${lineIndex * 0.05}s">${escapeHtml(line)}</div>`;
      lineIndex++;
    });
    
    // Close any open sections
    if (currentScene) html += '</div>';
    if (inConfessional) html += '</div>';
    if (inTribal) html += '</div>';
    
    html += '</div>';
    return html;
  }
  
  // Get character avatar (image or emoji)
  function getCharacterAvatar(characterName) {
    const key = characterName.toLowerCase().replace(/\s+/g, '-');
    const keySimple = characterName.toLowerCase().replace(/\s+/g, '');
    
    const paths = [
      `assets/avatars/${key}.png`,
      `assets/avatars/${keySimple}.png`,
      `assets/avatars/${characterName.toLowerCase()}.png`
    ];
    
    const emoji = CHARACTER_AVATARS[keySimple] || CHARACTER_AVATARS[key] || 'üë§';
    
    return `
      <img src="${paths[0]}" alt="${escapeHtml(characterName)}" 
        onerror="this.onerror=null; this.style.display='none'; this.nextElementSibling.style.display='flex';">
      <span class="character-avatar-fallback" style="display:none;">
        ${emoji}
      </span>
    `;
  }
  
  // Escape HTML to prevent XSS
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  // Clear episode when season/episode changes
  let lastEpisodeKey = getEpisodeStorageKey();
  setInterval(() => {
    const currentKey = getEpisodeStorageKey();
    if (currentKey !== lastEpisodeKey) {
      const rendered = document.getElementById('episode-rendered');
      const input = document.getElementById('episode-input');
      if (rendered) rendered.innerHTML = '';
      if (input) input.value = '';
      lastEpisodeKey = currentKey;
      loadEpisode();
    }
  }, 1000);

// ========================================
// SEASON SETUP FUNCTIONS - FIXED VERSION (STANDALONE)
// Insert this code BEFORE the closing 
// This version includes all necessary functions
// ========================================

console.log("üöÄ Season Setup script tag reached!");

// Auto-load database from JSON if localStorage is empty
(function() {
  const existingDB = localStorage.getItem('players_database');
  if (!existingDB) {
    console.log("üì• No database in localStorage, attempting to load from players_database.json...");
    fetch('players_database.json')
      .then(r => r.json())
      .then(db => {
        localStorage.setItem('players_database', JSON.stringify(db, null, 2));
        console.log(`‚úÖ Database auto-loaded! ${db.players.length} players, ${db.franchise.totalSeasons} seasons`);
      })
      .catch(e => {
        console.warn("‚ö†Ô∏è Could not auto-load database:", e.message);
        console.log("Database will be empty until you import it manually or create profiles");
      });
  } else {
    const db = JSON.parse(existingDB);
    console.log(`‚úÖ Database already in localStorage (${db.players.length} players, ${db.franchise.totalSeasons} seasons)`);
  }
})();

// Use setTimeout to ensure ALL DOM elements are fully rendered AND database is loaded
setTimeout(function() {
(function() {
  console.log("üîß Season Setup: Initializing...");
  
  // Get Season Setup elements
  const seasonSetupSummary = document.getElementById("season-setup-summary");
  const analyzeCastBtn = document.getElementById("analyze-cast-btn");
  const castAnalysisResult = document.getElementById("cast-analysis-result");
  const createProfilesSection = document.getElementById("create-profiles-section");
  const createProfilesBtn = document.getElementById("create-profiles-btn");
  const exportDatabaseBtn = document.getElementById("export-database-btn");
  const importDatabaseBtn = document.getElementById("import-database-btn");
  const syncDevoteesBtn = document.getElementById("sync-devotees-btn");
  const rebuildRankingsBtn = document.getElementById("rebuild-rankings-btn");
  const importFileInput = document.getElementById("import-file-input");
  const databaseStatus = document.getElementById("database-status");

  console.log("üîß Elements check:");
  console.log("  - Button:", analyzeCastBtn ? "‚úÖ Found" : "‚ùå NOT FOUND");
  console.log("  - Textarea:", seasonSetupSummary ? "‚úÖ Found" : "‚ùå NOT FOUND");

  let analyzedCastData = null;

  // ========================================
  // HELPER: FORMAT PLAYER STORY
  // ========================================
  
  function formatPlayerStory(player, newSeasonStory, seasonNumber, seasonTheme) {
    // Count total seasons INCLUDING the current one being added
    const seasonDetails = player.seasonDetails || [];
    const isReturning = player.seasons && player.seasons.length > 0;
    const totalSeasons = isReturning ? seasonDetails.length + 1 : 1;
    
    // If player only has 1 season total (first time playing), use simple format
    if (totalSeasons === 1) {
      return newSeasonStory;
    }
    
    // Multi-season player: use structured format
    const existingStory = player.story || '';
    
    // Build new season section with proper formatting
    const newSection = `SEASON ${seasonNumber} ‚Äî ${seasonTheme}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nSEASON ${seasonNumber} ‚Äî ${seasonTheme}\n${newSeasonStory}`;
    
    // If no existing story, start fresh with structured format
    if (!existingStory) {
      return newSection;
    }
    
    // Check if this season already exists in the story (regeneration case)
    const seasonPattern = new RegExp(`SEASON\\s+${seasonNumber}\\s+[‚Äî\\-‚Äì]`, 'i');
    
    if (seasonPattern.test(existingStory)) {
      // Replace existing season section
      const sectionRegex = new RegExp(
        `SEASON\\s+${seasonNumber}\\s+[‚Äî\\-‚Äì][^\\n]*\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n[\\s\\S]*?(?=(?:\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\nSEASON|$))`,
        'gi'
      );
      return existingStory.replace(sectionRegex, newSection);
    } else {
      // Append new season
      return existingStory + '\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n' + newSection;
    }
  }

  // ========================================
  // HELPER: EXTRACT TRIBE INFORMATION
  // ========================================
  
  function extractPlayerTribes(episodes) {
    const playerTribes = {};
    
    if (!episodes || episodes.length === 0) return playerTribes;
    
    // Look for tribe assignments in early episodes (usually Episode 1)
    for (const ep of episodes.slice(0, 3)) { // Check first 3 episodes
      const summary = ep.summary || '';
      
      // Pattern 1: "=== TRIBE: TribeName ===" followed by player names
      const tribeMatches = summary.matchAll(/===\s*TRIBE[:\s]+([A-Za-z]+)\s*===\s*([\s\S]*?)(?=\n===|$)/gi);
      
      for (const match of tribeMatches) {
        const tribeName = match[1].trim();
        const memberBlock = match[2];
        
        // Extract player names from the block
        const lines = memberBlock.split('\n')
          .map(l => l.trim())
          .filter(l => l && !l.startsWith('===') && !l.startsWith('---'));
        
        for (const line of lines) {
          // Remove bullets, numbers, etc
          const cleanName = line.replace(/^[-*\d.)\s]+/, '').trim();
          if (cleanName.length > 2) {
            const playerId = slugify(cleanName);
            playerTribes[playerId] = tribeName;
          }
        }
      }
      
      // Pattern 2: Look for tribe mentions like "Galang members:", "Tadhana tribe:"
      const tribeLineMatches = summary.matchAll(/([A-Za-z]+)\s+(?:tribe|members?):\s*([^\n]+)/gi);
      
      for (const match of tribeLineMatches) {
        const tribeName = match[1].trim();
        const members = match[2];
        
        // Split by commas or "and"
        const names = members.split(/,|\sand\s/i).map(n => n.trim());
        
        for (const name of names) {
          const cleanName = name.replace(/^[-*\d.)\s]+/, '').trim();
          if (cleanName.length > 2 && !cleanName.toLowerCase().includes('member')) {
            const playerId = slugify(cleanName);
            playerTribes[playerId] = tribeName;
          }
        }
      }
      
      // Pattern 3: Inline mentions like "Mickey (Galang)" or "Ryan from Tadhana"
      const inlineMatches = summary.matchAll(/([A-Z][a-z]+)\s+(?:\(([A-Z][a-z]+)\)|from\s+([A-Z][a-z]+))/g);
      
      for (const match of inlineMatches) {
        const playerName = match[1];
        const tribeName = match[2] || match[3];
        
        if (playerName && tribeName) {
          const playerId = slugify(playerName);
          playerTribes[playerId] = tribeName;
        }
      }
    }
    
    console.log('üìã Extracted tribe assignments:', playerTribes);
    return playerTribes;
  }

  // ========================================
  // HELPER FUNCTIONS (copied from main script)
  // ========================================
  
  function slugify(name) {
    return name.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
  
  function parseCastFromSummary(text) {
    const castMatch = text.match(/===\s*CAST\s*\(ALL\)\s*===\s*([\s\S]*?)(?=\n===|$)/i);
    if (!castMatch) return [];
    
    const lines = castMatch[1].split('\n');
    const names = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('===') && !trimmed.startsWith('---')) {
        names.push(trimmed);
      }
    }
    return names;
  }

  // ========================================
  // AUTO-SAVE / AUTO-LOAD FOR SEASON BUILDER
  // ========================================
  
  let autoSaveTimeout = null;
  
  function getSeasonStorageKey(seasonNumber) {
    return `season_builder_s${seasonNumber}`;
  }
  
  function autoSaveSeasonBuilder() {
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(() => {
      try {
        const seasonNumber = parseInt(document.getElementById("sb-season-number").value) || 0;
        if (!seasonNumber) return;
        
        const data = {
          metadata: {
            title: document.getElementById("sb-season-title").value.trim(),
            subtitle: document.getElementById("sb-season-subtitle").value.trim(),
            theme: document.getElementById("sb-season-theme").value.trim(),
            emoji: document.getElementById("sb-season-emoji").value.trim(),
            episodeCount: parseInt(document.getElementById("sb-episode-count").value) || 17,
          },
          brantsteeleStats: document.getElementById("sb-brantsteele-stats").value.trim(),
          episodes: {},
          finale: {
            winner: document.getElementById("sb-finale-winner").value.trim(),
            runnerUp: document.getElementById("sb-finale-runnerup").value.trim(),
            finalVote: document.getElementById("sb-finale-vote").value.trim(),
            juryVotesText: document.getElementById("sb-jury-votes").value.trim(),
          },
          awards: {
            fanFavorite: document.getElementById("sb-award-fan").value.trim(),
            bestStrategic: document.getElementById("sb-award-strategic").value.trim(),
            mostChallengeWins: document.getElementById("sb-award-challenges").value.trim(),
          },
          savedAt: new Date().toISOString()
        };
        
        // Save episode summaries
        const episodeCount = data.metadata.episodeCount;
        for (let i = 1; i <= episodeCount; i++) {
          const textarea = document.getElementById(`sb-ep${i}-summary`);
          if (textarea) {
            data.episodes[i] = textarea.value.trim();
          }
        }
        
        const storageKey = getSeasonStorageKey(seasonNumber);
        localStorage.setItem(storageKey, JSON.stringify(data));
        
        // Show save indicator
        const indicator = document.getElementById("sb-save-indicator");
        if (indicator) {
          const savedDate = new Date().toLocaleTimeString();
          indicator.textContent = `‚úÖ Saved ${savedDate}`;
          indicator.style.display = 'block';
          setTimeout(() => {
            indicator.style.display = 'none';
          }, 2000);
        }
        
        console.log(`‚úÖ Auto-saved Season ${seasonNumber}`);
      } catch (e) {
        console.error('Auto-save error:', e);
      }
    }, 1000); // Debounce: save 1 second after last change
  }
  
  function loadSeasonBuilderData(seasonNumber) {
    try {
      const storageKey = getSeasonStorageKey(seasonNumber);
      const saved = localStorage.getItem(storageKey);
      
      if (!saved) {
        console.log(`No saved data for Season ${seasonNumber}`);
        return false;
      }
      
      const data = JSON.parse(saved);
      
      // Load metadata
      document.getElementById("sb-season-title").value = data.metadata.title || '';
      document.getElementById("sb-season-subtitle").value = data.metadata.subtitle || '';
      document.getElementById("sb-season-theme").value = data.metadata.theme || '';
      document.getElementById("sb-season-emoji").value = data.metadata.emoji || 'üéØ';
      document.getElementById("sb-episode-count").value = data.metadata.episodeCount || 17;
      
      // Load Brantsteele stats
      document.getElementById("sb-brantsteele-stats").value = data.brantsteeleStats || '';
      
      // Regenerate episode textareas if count changed
      const currentCount = parseInt(document.getElementById("sb-episode-count").value);
      generateSeasonBuilderEpisodeTextareas(currentCount);
      
      // Load episode summaries (use setTimeout to ensure textareas are rendered)
      setTimeout(() => {
        for (let i = 1; i <= currentCount; i++) {
          const textarea = document.getElementById(`sb-ep${i}-summary`);
          if (textarea && data.episodes[i]) {
            textarea.value = data.episodes[i];
          }
        }
      }, 100);
      
      // Load finale
      document.getElementById("sb-finale-winner").value = data.finale?.winner || '';
      document.getElementById("sb-finale-runnerup").value = data.finale?.runnerUp || '';
      document.getElementById("sb-finale-vote").value = data.finale?.finalVote || '';
      document.getElementById("sb-jury-votes").value = data.finale?.juryVotesText || '';
      
      // Load awards
      document.getElementById("sb-award-fan").value = data.awards?.fanFavorite || '';
      document.getElementById("sb-award-strategic").value = data.awards?.bestStrategic || '';
      document.getElementById("sb-award-challenges").value = data.awards?.mostChallengeWins || '';
      
      console.log(`‚úÖ Loaded Season ${seasonNumber} (saved ${data.savedAt})`);
      
      // Show load indicator
      const indicator = document.getElementById("sb-save-indicator");
      if (indicator) {
        indicator.textContent = `‚úÖ Loaded Season ${seasonNumber}`;
        indicator.style.display = 'block';
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 3000);
      }
      
      return true;
    } catch (e) {
      console.error('Load error:', e);
      return false;
    }
  }
  
  function clearCurrentSeasonData() {
    const seasonNumber = parseInt(document.getElementById("sb-season-number").value) || 0;
    if (!seasonNumber) {
      alert('Please enter a season number first');
      return;
    }
    
    if (!confirm(`Clear ALL saved data for Season ${seasonNumber}?\n\nThis will delete all episode summaries, metadata, and finale data.`)) {
      return;
    }
    
    const storageKey = getSeasonStorageKey(seasonNumber);
    localStorage.removeItem(storageKey);
    
    // Clear all fields
    document.getElementById("sb-season-title").value = '';
    document.getElementById("sb-season-subtitle").value = '';
    document.getElementById("sb-season-theme").value = '';
    document.getElementById("sb-season-emoji").value = 'üéØ';
    document.getElementById("sb-brantsteele-stats").value = '';
    document.getElementById("sb-finale-winner").value = '';
    document.getElementById("sb-finale-runnerup").value = '';
    document.getElementById("sb-finale-vote").value = '';
    document.getElementById("sb-jury-votes").value = '';
    document.getElementById("sb-award-fan").value = '';
    document.getElementById("sb-award-strategic").value = '';
    document.getElementById("sb-award-challenges").value = '';
    
    const episodeCount = parseInt(document.getElementById("sb-episode-count").value) || 17;
    for (let i = 1; i <= episodeCount; i++) {
      const textarea = document.getElementById(`sb-ep${i}-summary`);
      if (textarea) {
        textarea.value = '';
      }
    }
    
    alert(`‚úÖ Cleared Season ${seasonNumber} data`);
  }
  
  // Setup auto-save listeners
  function setupSeasonBuilderAutoSave() {
    const fields = [
      'sb-season-title', 'sb-season-subtitle', 'sb-season-theme', 'sb-season-emoji',
      'sb-brantsteele-stats', 'sb-finale-winner', 'sb-finale-runnerup', 
      'sb-finale-vote', 'sb-jury-votes', 'sb-award-fan', 'sb-award-strategic', 
      'sb-award-challenges'
    ];
    
    fields.forEach(id => {
      const field = document.getElementById(id);
      if (field) {
        field.addEventListener('input', autoSaveSeasonBuilder);
        field.addEventListener('change', autoSaveSeasonBuilder);
      }
    });
    
    // Episode textareas are added dynamically, so use event delegation
    document.addEventListener('input', (e) => {
      if (e.target.id && e.target.id.startsWith('sb-ep') && e.target.id.endsWith('-summary')) {
        autoSaveSeasonBuilder();
      }
    });
    
    // Load data when season number changes
    const seasonNumberField = document.getElementById('sb-season-number');
    if (seasonNumberField) {
      seasonNumberField.addEventListener('change', (e) => {
        const seasonNumber = parseInt(e.target.value);
        if (seasonNumber) {
          loadSeasonBuilderData(seasonNumber);
        }
      });
    }
    
    // Try to load current season on page load
    const currentSeason = parseInt(seasonNumberField?.value);
    if (currentSeason) {
      setTimeout(() => {
        loadSeasonBuilderData(currentSeason);
      }, 500);
    }
  }

  // ========================================
  // FEATURE 0: COMPLETE SEASON BUILDER
  // ========================================
  
  const sbEpisodesContainer = document.getElementById("sb-episodes-container");
  const sbToggleEpisodesBtn = document.getElementById("sb-toggle-episodes");
  const sbGenerateAllBtn = document.getElementById("sb-generate-all");
  const sbPreviewDataBtn = document.getElementById("sb-preview-data");
  const sbProgress = document.getElementById("sb-progress");
  
  let episodesExpanded = false;
  
  // Initialize episode textareas
  function initializeEpisodeInputs() {
    const seasonNumber = parseInt(document.getElementById("sb-season-number").value) || 0;
    const episodeCount = parseInt(document.getElementById("sb-episode-count").value) || 14;
    let html = '';
    
    for (let i = 1; i <= episodeCount; i++) {
      const isFirst = i === 1;
      const display = (isFirst || episodesExpanded) ? 'block' : 'none';
      const rows = isFirst ? 10 : 6;
      
      html += `
        <div class="sb-episode-input" data-episode="${i}" style="display: ${display}; margin-bottom: 16px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label style="font-weight: 600; font-size: 14px;">
              Episode ${i}${isFirst ? ' (Must include CAST list)' : ''}
            </label>
            <span class="sb-episode-status" data-episode="${i}" style="font-size: 12px; opacity: 0.7;">
              Empty
            </span>
          </div>
          <textarea id="sb-ep${i}-summary" rows="${rows}" placeholder="Paste Episode ${i} summary here...${isFirst ? '\n\nMust include:\n=== CAST (ALL) ===\nName1\nName2\n...' : ''}"
            style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px;"></textarea>
        </div>
      `;
    }
    
    if (sbEpisodesContainer) {
      sbEpisodesContainer.innerHTML = html;
      
      // Load saved data if exists
      if (seasonNumber) {
        const storageKey = getSeasonStorageKey(seasonNumber);
        const saved = localStorage.getItem(storageKey);
        if (saved) {
          try {
            const data = JSON.parse(saved);
            // Populate episode textareas with saved content
            if (data.episodes) {
              for (let i = 1; i <= episodeCount; i++) {
                const textarea = document.getElementById(`sb-ep${i}-summary`);
                if (textarea && data.episodes[i]) {
                  textarea.value = data.episodes[i];
                  // Trigger status update
                  textarea.dispatchEvent(new Event('input'));
                }
              }
            }
          } catch (e) {
            console.error('Error loading saved episodes:', e);
          }
        }
      }
      
      // Add change listeners to update status
      for (let i = 1; i <= episodeCount; i++) {
        const textarea = document.getElementById(`sb-ep${i}-summary`);
        const status = document.querySelector(`.sb-episode-status[data-episode="${i}"]`);
        if (textarea && status) {
          textarea.addEventListener('input', () => {
            const charCount = textarea.value.trim().length;
            if (charCount === 0) {
              status.textContent = 'Empty';
              status.style.color = '#ff6464';
            } else if (charCount < 200) {
              status.textContent = `${charCount} chars (needs more)`;
              status.style.color = '#ffb347';
            } else {
              status.textContent = `‚úÖ ${charCount} chars`;
              status.style.color = '#4cffb3';
            }
          });
          
          // Trigger initial status update
          textarea.dispatchEvent(new Event('input'));
        }
      }
    }
  }
  
  // Toggle episodes visibility
  if (sbToggleEpisodesBtn) {
    sbToggleEpisodesBtn.addEventListener('click', () => {
      episodesExpanded = !episodesExpanded;
      const episodes = document.querySelectorAll('.sb-episode-input');
      episodes.forEach((ep, i) => {
        if (i === 0) return; // Always show Episode 1
        ep.style.display = episodesExpanded ? 'block' : 'none';
      });
      sbToggleEpisodesBtn.textContent = episodesExpanded ? 'Hide Episodes 2-14' : 'Show All Episodes';
    });
  }
  
  // Episode count change handler
  const episodeCountInput = document.getElementById("sb-episode-count");
  if (episodeCountInput) {
    episodeCountInput.addEventListener('change', initializeEpisodeInputs);
  }
  
  // Initialize on load
  initializeEpisodeInputs();
  setupSeasonBuilderAutoSave(); // Enable auto-save
  
  // Preview Data Button
  if (sbPreviewDataBtn) {
    sbPreviewDataBtn.addEventListener('click', () => {
      try {
        const data = collectSeasonBuilderData();
        const preview = JSON.stringify(data, null, 2);
        
        // Show in modal/alert
        const previewWindow = window.open('', 'Season Data Preview', 'width=800,height=600');
        previewWindow.document.write(`
          <html>
          <head>
            <title>Season ${data.metadata.seasonNumber} Preview</title>
            <style>
              body { 
                font-family: monospace; 
                padding: 20px; 
                background: #1a1a1a; 
                color: #fff; 
              }
              pre { 
                background: #000; 
                padding: 20px; 
                border-radius: 8px; 
                overflow: auto; 
                max-height: 80vh;
              }
              h2 { color: #4cffb3; }
            </style>
          </head>
          <body>
            <h2>Season ${data.metadata.seasonNumber} Data Preview</h2>
            <p>Episodes collected: ${data.episodes.length}</p>
            <p>Cast size: ${data.cast.length}</p>
            <pre>${escapeHtml(preview)}</pre>
          </body>
          </html>
        `);
      } catch (error) {
        alert(`‚ùå Preview error: ${error.message}`);
      }
    });
  }
  
  // Generate All Button (Main function - will be implemented in next steps)
  if (sbGenerateAllBtn) {
    sbGenerateAllBtn.addEventListener('click', () => {
      if (!confirm('Generate complete Season database?\n\nThis will:\n‚Ä¢ Parse all episode summaries\n‚Ä¢ Create season6-data.json\n‚Ä¢ Update all databases\n‚Ä¢ Generate voting analytics\n\nContinue?')) {
        return;
      }
      
      sbGenerateAllBtn.disabled = true;
      sbGenerateAllBtn.innerHTML = '‚è≥ Generating...';
      
      setTimeout(() => {
        try {
          generateCompleteSeasonDatabase();
        } catch (error) {
          console.error('Generation error:', error);
          showProgress(`
            <div style="padding: 20px; background: rgba(255,100,100,0.2); border: 2px solid #ff6464; border-radius: 16px;">
              <h3 style="color: #ff6464;">‚ùå Generation Failed</h3>
              <p>${error.message}</p>
            </div>
          `);
        } finally {
          sbGenerateAllBtn.disabled = false;
          sbGenerateAllBtn.innerHTML = '‚ö° Generate Complete Season Database';
        }
      }, 100);
    });
  }
  
  // Helper: Collect all Season Builder data
  function collectSeasonBuilderData() {
    const seasonNumber = parseInt(document.getElementById("sb-season-number").value);
    const episodeCount = parseInt(document.getElementById("sb-episode-count").value);
    
    // Collect metadata
    const metadata = {
      seasonNumber,
      title: document.getElementById("sb-season-title").value.trim() || `Total Drama Season ${seasonNumber}`,
      subtitle: document.getElementById("sb-season-subtitle").value.trim() || "",
      theme: document.getElementById("sb-season-theme").value.trim() || "",
      emoji: document.getElementById("sb-season-emoji").value.trim() || "üéØ",
      episodeCount,
      castSize: 0, // Will be determined from Episode 1 or Brantsteele stats
      jurySize: 0  // Will be calculated
    };
    
    // Collect Brantsteele stats (optional)
    const brantsteeleStats = document.getElementById("sb-brantsteele-stats").value.trim();
    
    // Collect episode summaries
    const episodes = [];
    for (let i = 1; i <= episodeCount; i++) {
      const textarea = document.getElementById(`sb-ep${i}-summary`);
      if (!textarea) {
        throw new Error(`Episode ${i} textarea not found`);
      }
      const summary = textarea.value.trim();
      if (!summary) {
        throw new Error(`Episode ${i} is empty! Please fill in all episodes.`);
      }
      episodes.push({
        episode: i,
        summary: summary
      });
    }
    
    // Get cast from Episode 1
    const cast = parseCastFromSummary(episodes[0].summary);
    if (cast.length === 0 && !brantsteeleStats) {
      throw new Error('No cast found in Episode 1! Make sure it has "=== CAST (ALL) ===" section, or provide Brantsteele stats.');
    }
    if (cast.length > 0) {
      metadata.castSize = cast.length;
    }
    
    // Collect finale data
    const finale = {
      winner: document.getElementById("sb-finale-winner").value.trim(),
      runnerUp: document.getElementById("sb-finale-runnerup").value.trim(),
      finalVote: document.getElementById("sb-finale-vote").value.trim(),
      juryVotesText: document.getElementById("sb-jury-votes").value.trim()
    };
    
    if (!finale.winner) throw new Error('Winner name is required!');
    if (!finale.runnerUp) throw new Error('Runner-up name(s) required!');
    if (!finale.finalVote) throw new Error('Final vote count is required!');
    
    // Parse jury votes
    const juryVotes = [];
    const juryLines = finale.juryVotesText.split('\n');
    for (const line of juryLines) {
      const match = line.match(/([A-Za-z]+)\s+voted\s+for\s+([A-Za-z]+)/i);
      if (match) {
        juryVotes.push({
          juror: match[1].trim(),
          votedFor: match[2].trim()
        });
      }
    }
    metadata.jurySize = juryVotes.length;
    
    // Collect awards
    const awards = {
      fanFavorite: document.getElementById("sb-award-fan").value.trim(),
      bestStrategic: document.getElementById("sb-award-strategic").value.trim(),
      mostChallengeWins: document.getElementById("sb-award-challenges").value.trim()
    };
    
    return {
      metadata,
      cast,
      episodes,
      finale: {
        ...finale,
        juryVotes
      },
      awards,
      brantsteeleStats // Include Brantsteele stats
    };
  }
  
  // Helper: Show progress messages
  function showProgress(html) {
    if (sbProgress) {
      sbProgress.style.display = 'block';
      sbProgress.innerHTML = html;
      sbProgress.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }
  
  // Main generation function (placeholder - will be fully implemented in next steps)
  function generateCompleteSeasonDatabase() {
    showProgress('<h3>‚ö° Starting generation...</h3>');
    
    // Step 1: Collect data
    showProgress('<h3>‚ö° Starting generation...</h3><p>üìù Collecting data...</p>');
    const data = collectSeasonBuilderData();
    
    // Step 2: Validation
    showProgress('<h3>‚ö° Starting generation...</h3><p>üìù Collecting data... ‚úÖ</p><p>‚úÖ Validating...</p>');
    console.log('Season Builder Data:', data);
    
    // TODO: Next steps will implement:
    // - Parse episode data (eliminations, votes, challenges)
    // - Generate season6-data.json
    // - Update seasons_database.json
    // - Update franchise_database.json
    // - Update players_database.json
    // - Update rankings_database.json
    // - Generate voting-analytics HTML
    
    // Call AI-first implementation
    generateCompleteSeasonDatabaseAI(data);
  }
  
  // AI-FIRST IMPLEMENTATION - Let AI do ALL the parsing
  async function generateCompleteSeasonDatabaseAI(data) {
    try {
      // Step 1: AI extracts ALL data from episodes
      showProgress('<h3>‚ö° Step 1/5: AI Data Extraction</h3><p>ü§ñ Having AI analyze all episodes and extract structured data...</p>');
      await sleep(500);
      
      const aiSeasonData = await getAISeasonData(data);
      
      if (!aiSeasonData) {
        throw new Error('AI data extraction failed. Check worker URL and try again.');
      }
      
      console.log('AI Extracted Data:', aiSeasonData);
      
      // Step 2: Generate season data file from AI output
      showProgress('<h3>‚ö° Step 2/5: Building Season File</h3><p>üìÑ Creating season' + data.metadata.seasonNumber + '-data.json from AI data...</p>');
      await sleep(500);
      
      const seasonData = buildSeasonDataFromAI(data, aiSeasonData);
      downloadJSON(seasonData, `season${data.metadata.seasonNumber}-data.json`);
      
      // Step 3: Update seasons_database
      showProgress('<h3>‚ö° Step 3/5: Updating Seasons Database</h3><p>üìö Adding Season ' + data.metadata.seasonNumber + ' to seasons_database.json...</p>');
      await sleep(500);
      
      updateSeasonsDatabase(seasonData);
      
      // Step 4: Update franchise_database
      showProgress('<h3>‚ö° Step 4/5: Updating Franchise Database</h3><p>üèõÔ∏è Adding records, milestones, and trends...</p>');
      await sleep(500);
      
      updateFranchiseDatabase(seasonData);
      
      // Step 5: Update players_database with AI-enhanced data
      showProgress('<h3>‚ö° Step 5/5: Updating Players Database</h3><p>üë• Creating/updating player profiles with AI narratives...</p>');
      await sleep(500);
      
      updatePlayersDatabase(seasonData);
      
      // Step 6: Recalculate rankings
      showProgress('<h3>‚ö° Bonus: Recalculating Rankings</h3><p>üèÜ Calculating scores for all players...</p>');
      await sleep(500);
      
      // Load old rankings from project file
      let oldRankingsData = null;
      try {
        console.log('üìÇ Attempting to load rankings_database.json from project...');
        const rankingsResponse = await fetch('rankings_database.json');
        if (rankingsResponse.ok) {
          oldRankingsData = await rankingsResponse.json();
          console.log(`‚úÖ Loaded old rankings from project file`);
        } else {
          console.log('‚ÑπÔ∏è rankings_database.json not found in project - will calculate fresh rankings');
        }
      } catch (e) {
        console.log('‚ÑπÔ∏è Could not load rankings file from project:', e.message);
      }
      
      // Load ranking overrides (if available)
      let overrides = null;
      try {
        const overridesResp = await fetch('ranking-overrides.json');
        if (overridesResp.ok) {
          overrides = await overridesResp.json();
          console.log(`‚úì Loaded ${Object.keys(overrides.overrides || {}).length} ranking overrides`);
        }
      } catch (e) {
        console.log('‚ÑπÔ∏è No ranking overrides found, using AI scores only');
      }
      
      // IMPORTANT: Use 'rankings-update' to preserve non-returnees
      // Use 'rankings-rebuild' once to recalculate everyone from scratch
      const rankingsResp = await fetch(workerUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          mode: "rankings-update",  // Preserves non-returnees
          playersDB,
          seasonData,
          oldRankingsDB: oldRankingsData,
          overrides: overrides  // ‚Üê Pass overrides here
        })
      });
      
      // Step 7: Generate voting analytics HTML
      showProgress('<h3>‚ö° Bonus: Generating Voting Analytics</h3><p>üó≥Ô∏è Creating HTML table...</p>');
      await sleep(500);
      
      const votingHTML = generateVotingAnalyticsHTML(seasonData);
      downloadText(votingHTML, `season${data.metadata.seasonNumber}-voting-table.html`);
      
      // SUCCESS!
      showProgress(`
        <div style="padding: 30px; background: linear-gradient(135deg, rgba(76,255,179,0.3), rgba(76,255,179,0.1)); border: 3px solid #4cffb3; border-radius: 20px; text-align: center;">
          <div style="font-size: 72px; margin-bottom: 16px;">üéâ</div>
          <h2 style="margin: 0 0 12px; color: #4cffb3;">Season ${data.metadata.seasonNumber} Complete!</h2>
          <div style="font-size: 16px; opacity: 0.95; margin-bottom: 24px;">
            All data extracted by AI and databases updated successfully
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin: 24px 0;">
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">season${data.metadata.seasonNumber}-data.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">seasons_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">franchise_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">players_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #4cffb3;">‚úÖ</div>
              <div style="font-size: 14px; opacity: 0.9;">rankings_database.json</div>
            </div>
            <div style="padding: 16px; background: rgba(0,0,0,0.2); border-radius: 12px;">
              <div style="font-size: 32px; font-weight: 700; color: #ffb347;">üìã</div>
              <div style="font-size: 14px; opacity: 0.9;">voting-analytics.html<br/>(downloaded)</div>
            </div>
          </div>
          
          <div style="padding: 16px; background: rgba(76,255,179,0.15); border-radius: 12px; margin-top: 24px; font-size: 14px;">
            <strong>ü§ñ AI-Generated:</strong> All player data, placements, votes, and narratives extracted by AI
          </div>
          
          <div style="display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin-top: 24px;">
            <button onclick="location.reload()" class="btn btn-primary">
              ‚ú® Start Season ${data.metadata.seasonNumber + 1}
            </button>
            <button onclick="window.open('franchise.html', '_blank')" class="btn">
              üèõÔ∏è View Franchise
            </button>
            <button onclick="window.open('rankings.html', '_blank')" class="btn">
              üèÜ View Rankings
            </button>
          </div>
        </div>
      `);
      
    } catch (error) {
      console.error('Generation error:', error);
      showProgress(`
        <div style="padding: 20px; background: rgba(255,100,100,0.2); border: 2px solid #ff6464; border-radius: 16px;">
          <h3 style="color: #ff6464;">‚ùå Generation Failed</h3>
          <p><strong>Error:</strong> ${error.message}</p>
          <details style="margin-top: 12px;">
            <summary style="cursor: pointer;">Show Stack Trace</summary>
            <pre style="margin-top: 8px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px; font-size: 11px; overflow: auto;">${error.stack}</pre>
          </details>
        </div>
      `);
    }
  }
  
  // ========================================
  // HELPER FUNCTIONS
  // ========================================
  
  function normalizeWorkerUrl(raw) {
    let url = (raw || "").trim();
    if (!url) return "";
    if (!/^https?:\/\//i.test(url)) url = "https://" + url;
    return url.replace(/\/+$/, "");
  }
  
  function getWorkerUrl() {
    // Try to get from the analytics section (aiWorkerUrl)
    const workerUrlInput = document.getElementById("aiWorkerUrl");
    if (workerUrlInput && workerUrlInput.value.trim()) {
      return normalizeWorkerUrl(workerUrlInput.value.trim());
    }
    
    // Try to get from localStorage
    const stored = localStorage.getItem('workerUrl');
    if (stored) {
      return normalizeWorkerUrl(stored);
    }
    
    return '';
  }
  
  function slugify(name) {
    return (name || "")
      .toLowerCase()
      .trim()
      .replace(/['".]/g, "")
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }
  
  // ========================================
  // AI DATA EXTRACTION
  // ========================================
  
  async function getAISeasonData(data) {
    const workerUrl = getWorkerUrl();
    
    if (!workerUrl) {
      throw new Error('Worker URL not set! Please enter your Cloudflare Worker URL in the Overview tab.');
    }
    
    try {
      // Build episode summaries
      const episodeSummaries = data.episodes.map(ep => ({
        episode: ep.episode,
        summary: ep.summary
      }));
      
      // Call AI Worker with full season data extraction mode
      const response = await fetch(workerUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          mode: 'season-data-extraction',
          season: data.metadata.seasonNumber,
          seasonTitle: data.metadata.title,
          episodes: episodeSummaries,
          finale: data.finale,
          awards: data.awards,
          metadata: data.metadata,
          brantsteeleStats: data.brantsteeleStats || null // Include Brantsteele stats
        })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`AI Worker failed (${response.status}): ${errorText}`);
      }
      
      const result = await response.json();
      return result;
      
    } catch (error) {
      console.error('AI data extraction error:', error);
      throw error;
    }
  }
  
  function buildSeasonDataFromAI(inputData, aiData) {
    const { metadata, finale } = inputData;
    
    // Use AI-extracted data to build complete season file
    const seasonData = {
      seasonNumber: metadata.seasonNumber,
      title: metadata.title,
      subtitle: metadata.subtitle,
      castSize: aiData.cast.length,
      episodeCount: metadata.episodeCount,
      jurySize: aiData.jury.length,
      
      winner: {
        name: aiData.winner.name,
        playerSlug: slugify(aiData.winner.name),
        vote: finale.finalVote,
        runnerUp: aiData.finalists.filter(f => f.placement > 1).map(f => f.name).join(' & '),
        keyStats: aiData.winner.keyStats,
        strategy: aiData.winner.strategy,
        legacy: aiData.winner.legacy
      },
      
      finalists: aiData.finalists.map(f => ({
        name: f.name,
        playerSlug: slugify(f.name),
        placement: f.placement,
        votes: f.juryVotes
      })),
      
      placements: aiData.placements.map(p => ({
        placement: p.placement,
        name: p.name,
        playerSlug: slugify(p.name),
        phase: p.phase,
        notes: p.notes,
        strategicRank: p.strategicRank,
        story: p.story,
        gameplayStyle: p.gameplayStyle,
        keyMoments: p.keyMoments || [],
        challengeWins: p.challengeWins || 0,
        immunityWins: p.immunityWins || 0,
        idolsFound: p.idolsFound || 0,
        votesReceived: p.votesReceived || 0,
        alliances: p.alliances || [],
        rivalries: p.rivalries || []
      })),
      
      votingHistory: aiData.votingHistory.map(vh => ({
        episode: vh.episode,
        eliminated: vh.eliminated,
        eliminatedSlug: vh.eliminated ? slugify(vh.eliminated) : null,
        votes: vh.votes.map(v => ({
          voter: v.voter,
          voterSlug: slugify(v.voter),
          target: v.target,
          targetSlug: slugify(v.target)
        }))
      })),
      
      finalTribalCouncil: {
        votes: finale.juryVotes.map(jv => ({
          juror: jv.juror,
          jurorSlug: slugify(jv.juror),
          votedFor: jv.votedFor,
          votedForSlug: slugify(jv.votedFor)
        }))
      },
      
      awards: {
        fanFavorite: {
          name: inputData.awards.fanFavorite,
          playerSlug: slugify(inputData.awards.fanFavorite)
        },
        bestStrategic: {
          name: inputData.awards.bestStrategic,
          playerSlug: slugify(inputData.awards.bestStrategic)
        },
        mostChallengeWins: {
          name: inputData.awards.mostChallengeWins,
          playerSlug: slugify(inputData.awards.mostChallengeWins),
          detail: `${aiData.placements.find(p => p.name.toLowerCase() === inputData.awards.mostChallengeWins.toLowerCase())?.challengeWins || 0} total`
        }
      },
      
      seasonNarrative: aiData.seasonNarrative,
      theme: metadata.theme,
      status: "Complete",
      castPhotoPath: `assets/cast/s${metadata.seasonNumber}-cast.png`,
      emoji: metadata.emoji
    };
    
    return seasonData;
  }
  
  // ========================================
  // PARSERS
  // ========================================
  
  function parseAllEpisodes(episodes, cast) {
    const parsedEpisodes = [];
    const activePlayers = new Set(cast);
    
    for (const ep of episodes) {
      const parsed = parseEpisodeSummary(ep.summary, ep.episode, activePlayers);
      parsedEpisodes.push(parsed);
      
      // Remove eliminated players from active set
      if (parsed.eliminated) {
        activePlayers.delete(parsed.eliminated);
      }
    }
    
    return parsedEpisodes;
  }
  
  function parseEpisodeSummary(text, episodeNum, activePlayers) {
    const result = {
      episode: episodeNum,
      eliminated: null,
      eliminatedSlug: null,
      votes: [],
      challengeWinners: [],
      immunityWinners: [],
      idolPlays: []
    };
    
    // Parse eliminated player
    // Look for patterns like: "X was voted out", "X was eliminated", "Boot: X"
    const bootPatterns = [
      /(?:voted out|eliminated|boot):\s*([A-Z][a-z]+)/i,
      /([A-Z][a-z]+)\s+(?:was voted out|was eliminated|got voted out)/i,
      /Eliminated:\s*([A-Z][a-z]+)/i
    ];
    
    for (const pattern of bootPatterns) {
      const match = text.match(pattern);
      if (match) {
        result.eliminated = match[1].trim();
        result.eliminatedSlug = slugify(match[1].trim());
        break;
      }
    }
    
    // Parse voting chart
    // Format: "Player1 voted Player2" or "Votes: Player1->Player2, ..."
    const votePattern = /([A-Z][a-z]+)\s+voted\s+(?:for\s+)?([A-Z][a-z]+)/gi;
    let voteMatch;
    while ((voteMatch = votePattern.exec(text)) !== null) {
      const voter = voteMatch[1].trim();
      const target = voteMatch[2].trim();
      
      // Only add if both are active players or in cast
      if (activePlayers.has(voter)) {
        result.votes.push({
          voter: voter,
          voterSlug: slugify(voter),
          target: target,
          targetSlug: slugify(target)
        });
      }
    }
    
    // Parse challenge winners
    const challengePattern = /(?:Challenge Winner|won (?:the )?challenge):\s*([A-Z][a-z]+)/gi;
    let challengeMatch;
    while ((challengeMatch = challengePattern.exec(text)) !== null) {
      result.challengeWinners.push(challengeMatch[1].trim());
    }
    
    // Parse immunity winners
    const immunityPattern = /(?:Immunity Winner|won (?:individual )?immunity):\s*([A-Z][a-z]+)/gi;
    let immunityMatch;
    while ((immunityMatch = immunityPattern.exec(text)) !== null) {
      result.immunityWinners.push(immunityMatch[1].trim());
    }
    
    // Parse idol plays
    const idolPattern = /([A-Z][a-z]+)\s+played\s+(?:an?\s+)?(?:hidden\s+)?idol/gi;
    let idolMatch;
    while ((idolMatch = idolPattern.exec(text)) !== null) {
      result.idolPlays.push(idolMatch[1].trim());
    }
    
    return result;
  }
  
  // ========================================
  // SEASON DATA GENERATION
  // ========================================
  
  function generateSeasonDataJSON(data, parsedEpisodes) {
    const { metadata, cast, episodes, finale, awards } = data;
    
    // Calculate placements
    const placements = calculatePlacements(cast, parsedEpisodes, finale);
    
    // Build finale finalists
    const finalists = [];
    const runnerUps = finale.runnerUp.split(',').map(s => s.trim());
    const allFinalists = [finale.winner, ...runnerUps];
    const voteCounts = finale.finalVote.split('-').map(Number);
    
    allFinalists.forEach((name, i) => {
      finalists.push({
        name: name,
        playerSlug: slugify(name),
        placement: i + 1,
        votes: voteCounts[i] || 0
      });
    });
    
    // Build season data JSON
    const seasonData = {
      seasonNumber: metadata.seasonNumber,
      title: metadata.title,
      subtitle: metadata.subtitle,
      castSize: metadata.castSize,
      episodeCount: metadata.episodeCount,
      jurySize: metadata.jurySize,
      winner: {
        name: finale.winner,
        playerSlug: slugify(finale.winner),
        vote: finale.finalVote,
        runnerUp: runnerUps.join(' & '),
        keyStats: `${voteCounts[0]} jury votes to win`,
        strategy: "TBD - Update manually",
        legacy: "TBD - Update manually"
      },
      finalists: finalists,
      placements: placements,
      votingHistory: parsedEpisodes.map(ep => ({
        episode: ep.episode,
        eliminated: ep.eliminated,
        eliminatedSlug: ep.eliminatedSlug,
        votes: ep.votes
      })),
      finalTribalCouncil: {
        votes: finale.juryVotes.map(jv => ({
          juror: jv.juror,
          jurorSlug: slugify(jv.juror),
          votedFor: jv.votedFor,
          votedForSlug: slugify(jv.votedFor)
        }))
      },
      awards: {
        fanFavorite: {
          name: awards.fanFavorite,
          playerSlug: slugify(awards.fanFavorite)
        },
        bestStrategic: {
          name: awards.bestStrategic,
          playerSlug: slugify(awards.bestStrategic)
        },
        mostChallengeWins: {
          name: awards.mostChallengeWins,
          playerSlug: slugify(awards.mostChallengeWins),
          detail: "TBD - count from episodes"
        }
      },
      theme: metadata.theme,
      status: "Complete",
      castPhotoPath: `assets/cast/s${metadata.seasonNumber}-cast.png`,
      emoji: metadata.emoji
    };
    
    return seasonData;
  }
  
  function calculatePlacements(cast, parsedEpisodes, finale) {
    const placements = [];
    const eliminated = [];
    
    // Track eliminations in order
    parsedEpisodes.forEach((ep, i) => {
      if (ep.eliminated) {
        eliminated.push({
          episode: ep.episode,
          name: ep.eliminated,
          placement: cast.length - eliminated.length
        });
      }
    });
    
    // Add finalists
    const runnerUps = finale.runnerUp.split(',').map(s => s.trim());
    const allFinalists = [finale.winner, ...runnerUps];
    const voteCounts = finale.finalVote.split('-').map(Number);
    
    allFinalists.forEach((name, i) => {
      placements.push({
        placement: i + 1,
        name: name,
        playerSlug: slugify(name),
        phase: i === 0 ? "Winner" : "Finalist",
        notes: `${i === 0 ? 'Winner' : 'Finalist'} - ${voteCounts[i] || 0} jury votes`
      });
    });
    
    // Add eliminated players (reverse order = highest placement first)
    eliminated.reverse().forEach((elim, i) => {
      const placement = allFinalists.length + i + 1;
      placements.push({
        placement: placement,
        name: elim.name,
        playerSlug: slugify(elim.name),
        phase: placement <= cast.length / 2 ? "Juror" : "Pre-Merge",
        notes: `Eliminated Episode ${elim.episode}`
      });
    });
    
    return placements;
  }
  
  // ========================================
  // DATABASE UPDATES
  // ========================================
  
  function updateSeasonsDatabase(seasonData) {
    let seasonsDB;
    try {
      const raw = localStorage.getItem('seasons_database');
      seasonsDB = raw ? JSON.parse(raw) : { franchise: {}, seasons: [] };
    } catch (e) {
      seasonsDB = { franchise: {}, seasons: [] };
    }
    
    // Check if season already exists
    const existingIndex = seasonsDB.seasons.findIndex(s => s.seasonNumber === seasonData.seasonNumber);
    
    const newSeasonEntry = {
      seasonNumber: seasonData.seasonNumber,
      title: seasonData.title,
      subtitle: seasonData.subtitle,
      castSize: seasonData.castSize,
      episodeCount: seasonData.episodeCount,
      winner: seasonData.winner,
      awards: seasonData.awards,
      theme: seasonData.theme,
      status: seasonData.status,
      castPhotoPath: seasonData.castPhotoPath,
      emoji: seasonData.emoji
    };
    
    if (existingIndex >= 0) {
      // Update existing season
      seasonsDB.seasons[existingIndex] = newSeasonEntry;
      console.log(`‚úÖ Updated existing Season ${seasonData.seasonNumber}`);
    } else {
      // Add new season
      seasonsDB.seasons.push(newSeasonEntry);
      console.log(`‚úÖ Added new Season ${seasonData.seasonNumber}`);
    }
    
    // Update franchise metadata
    seasonsDB.franchise.totalSeasons = seasonsDB.seasons.length;
    seasonsDB.franchise.name = "DC Franchise Database";
    seasonsDB.franchise.description = "Total Drama franchise statistics and season data";
    
    // Save
    localStorage.setItem('seasons_database', JSON.stringify(seasonsDB, null, 2));
    downloadJSON(seasonsDB, 'seasons_database.json');
    
    console.log('‚úÖ seasons_database.json updated');
  }
  
  function updateFranchiseDatabase(seasonData) {
    let franchiseDB;
    try {
      const raw = localStorage.getItem('franchise_database');
      franchiseDB = raw ? JSON.parse(raw) : createEmptyFranchiseDB();
    } catch (e) {
      franchiseDB = createEmptyFranchiseDB();
    }
    
    // Check if this season already exists in the database
    const seasonExists = franchiseDB.champions.some(c => c.season === seasonData.seasonNumber);
    
    if (seasonExists) {
      // Remove existing entries for this season
      franchiseDB.champions = franchiseDB.champions.filter(c => c.season !== seasonData.seasonNumber);
      franchiseDB.trends.winningStrategies = franchiseDB.trends.winningStrategies.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.trends.castComposition = franchiseDB.trends.castComposition.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.trends.finaleVoteMargins = franchiseDB.trends.finaleVoteMargins.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.trends.majorTwists = franchiseDB.trends.majorTwists.filter(s => s.season !== seasonData.seasonNumber);
      franchiseDB.fanFavorites = franchiseDB.fanFavorites.filter(s => s.season !== seasonData.seasonNumber);
      
      console.log(`üîÑ Replacing existing Season ${seasonData.seasonNumber} data in franchise database`);
    }
    
    // Update stats (recalculate from scratch)
    const uniqueSeasons = new Set(franchiseDB.champions.map(c => c.season));
    uniqueSeasons.add(seasonData.seasonNumber);
    franchiseDB.franchiseStats.totalSeasons = uniqueSeasons.size;
    
    // Add champion
    franchiseDB.champions.push({
      season: seasonData.seasonNumber,
      winner: seasonData.winner.name,
      playerSlug: seasonData.winner.playerSlug,
      strategy: seasonData.winner.strategy,
      finalVote: seasonData.winner.vote,
      runnerUp: seasonData.winner.runnerUp,
      keyStats: seasonData.winner.keyStats,
      legacy: seasonData.winner.legacy,
      votesAgainst: 0 // Calculate manually later
    });
    
    // Add to trends
    franchiseDB.trends.winningStrategies.push({
      season: seasonData.seasonNumber,
      strategy: seasonData.winner.strategy,
      winner: seasonData.winner.name
    });
    
    franchiseDB.trends.castComposition.push({
      season: seasonData.seasonNumber,
      composition: `${seasonData.castSize} players`
    });
    
    franchiseDB.trends.finaleVoteMargins.push({
      season: seasonData.seasonNumber,
      vote: seasonData.winner.vote,
      winner: seasonData.winner.name
    });
    
    franchiseDB.trends.majorTwists.push({
      season: seasonData.seasonNumber,
      twist: seasonData.theme || "TBD"
    });
    
    // Add fan favorite
    franchiseDB.fanFavorites.push({
      season: seasonData.seasonNumber,
      player: seasonData.awards.fanFavorite.name,
      playerSlug: seasonData.awards.fanFavorite.playerSlug,
      description: "Fan favorite"
    });
    
    // Save
    localStorage.setItem('franchise_database', JSON.stringify(franchiseDB, null, 2));
    downloadJSON(franchiseDB, 'franchise_database.json');
    
    console.log('‚úÖ franchise_database.json updated');
  }
  
  function createEmptyFranchiseDB() {
    return {
      franchiseStats: { totalSeasons: 0, totalEpisodes: 0, uniquePlayers: 0, totalAppearances: 0 },
      champions: [],
      records: { challengeRecords: [], votingRecords: [], strategicRecords: [], socialRecords: [] },
      fanFavorites: [],
      multiSeasonPlayers: { threeSeasons: [], twoSeasons: [] },
      trends: { winningStrategies: [], castComposition: [], finaleVoteMargins: [], majorTwists: [] },
      milestones: [],
      careerLeaders: { challengeDominance: [], socialGame: [], strategicImpact: {} },
      evolution: {}
    };
  }
  
  function updatePlayersDatabase(seasonData) {
    const db = loadPlayerDatabase();
    const season = seasonData.seasonNumber;
    
    // Banned IDs for fake players
    const bannedIds = [
      'votes-to-win', 'jury-votes', 'elimination-order', 'everyone', 'eliminate',
      'winner', 'finalist', 'juror', 'pre-juror', 'voted-out', 'medevac'
    ];
    
    // Extract tribe assignments from episodes
    const playerTribes = extractPlayerTribes(seasonData.episodes || []);
    
    // Track which players we've already processed to prevent duplicates
    const processedThisSeason = new Set();
    
    // Process each player in placements
    seasonData.placements.forEach(placement => {
      const name = placement.name;
      
      // Generate clean slug from name
      const id = slugify(name);
      
      // Validate player ID - skip obvious fakes
      if (!id || id.length < 2) {
        console.warn(`‚ö†Ô∏è Skipping invalid player ID: "${id}" from name "${name}"`);
        return;
      }
      
      // Skip fake players from parsing errors
      const isFake = bannedIds.some(banned => id.includes(banned) && id !== name.toLowerCase());
      if (isFake) {
        console.warn(`‚ö†Ô∏è Skipping fake player: "${name}" (ID: "${id}")`);
        return;
      }
      
      // Prevent duplicate processing in same season
      if (processedThisSeason.has(id)) {
        console.warn(`‚ö†Ô∏è Player "${name}" already processed for Season ${season}, skipping duplicate`);
        return;
      }
      processedThisSeason.add(id);
      
      let player = db.players.find(p => p.id === id);
      
      // Get AI-generated stats from placement
      const challengeWins = placement.challengeWins || 0;
      const immunityWins = placement.immunityWins || 0;
      const idolsFound = placement.idolsFound || 0;
      const votesReceived = placement.votesReceived || 0;
      const strategicRank = placement.strategicRank || 0;
      
      // Get jury votes if finalist
      const juryVotes = placement.placement <= 3 
        ? (seasonData.finalists?.find(f => slugify(f.name) === id)?.juryVotes || 0) 
        : 0;
      
      if (!player) {
        // Create new player
        player = {
          id,
          name,
          seasons: [season],
          totalSeasons: 1,
          bestPlacement: placement.placement,
          wins: placement.placement === 1 ? 1 : 0,
          totalChallengeWins: challengeWins,
          totalImmunityWins: immunityWins,
          totalRewardWins: 0, // Not tracked yet
          totalVotesAgainst: votesReceived,
          totalIdolsFound: idolsFound,
          totalJuryVotes: juryVotes,
          tier: "Unranked",
          badges: placement.placement === 1 ? [`S${season} Winner`] : [],
          seasonDetails: [],
          story: placement.story || `Competed in Season ${season}`
        };
        db.players.push(player);
        console.log(`‚úÖ Created new player: ${name} (ID: ${id})`);
      } else {
        // Update existing player
        
        // Initialize arrays if they don't exist
        if (!Array.isArray(player.seasons)) player.seasons = [];
        if (!Array.isArray(player.seasonDetails)) player.seasonDetails = [];
        if (!Array.isArray(player.badges)) player.badges = [];
        
        // Check if this season is already in their record
        const seasonIndex = player.seasonDetails.findIndex(s => s.season === season);
        if (seasonIndex >= 0) {
          console.log(`üîÑ Updating existing Season ${season} data for ${name}`);
          // Remove old season data to prevent accumulation
          const oldDetail = player.seasonDetails[seasonIndex];
          player.totalChallengeWins -= (oldDetail.challengeWins || 0);
          player.totalImmunityWins -= (oldDetail.immunityWins || 0);
          player.totalVotesAgainst -= (oldDetail.votesReceived || 0);
          player.totalIdolsFound -= (oldDetail.idolsFound || 0);
          player.totalJuryVotes -= (oldDetail.juryVotes || 0);
          
          // Remove season from list if it's there
          player.seasons = player.seasons.filter(s => s !== season);
          player.seasonDetails = player.seasonDetails.filter(s => s.season !== season);
          player.totalSeasons = player.seasons.length;
          
          // Initialize badges array if it doesn't exist
          if (!Array.isArray(player.badges)) {
            player.badges = [];
          }
          
          // Remove duplicate win badges
          player.badges = player.badges.filter(b => b !== `S${season} Winner`);
          if (player.wins > 0 && oldDetail.placement === 1) {
            player.wins--;
          }
        }
        
        // Add season
        if (!player.seasons.includes(season)) {
          player.seasons.push(season);
          player.totalSeasons++;
        }
        
        // Update best placement
        if (placement.placement < player.bestPlacement) {
          player.bestPlacement = placement.placement;
        }
        
        // Add win if applicable
        if (placement.placement === 1) {
          player.wins++;
          const badgeText = `S${season} Winner`;
          if (!player.badges.includes(badgeText)) {
            player.badges.push(badgeText);
          }
        }
        
        // Add this season's stats
        player.totalChallengeWins += challengeWins;
        player.totalImmunityWins += immunityWins;
        player.totalVotesAgainst += votesReceived;
        player.totalIdolsFound += idolsFound;
        player.totalJuryVotes += juryVotes;
        
        // Update story with proper formatting (multi-season vs single-season)
        if (placement.story) {
          const seasonTheme = seasonData.metadata?.theme || seasonData.metadata?.title || 'Unknown';
          player.story = formatPlayerStory(player, placement.story, season, seasonTheme);
        }
        
        console.log(`‚úÖ Updated player: ${name} - Now ${player.totalSeasons} season(s), ${player.wins} win(s)`);
      }
      
      // Add/update season details with AI-generated data
      const seasonDetail = {
        season,
        placement: placement.placement,
        status: placement.phase,
        tribe: playerTribes[id] || "Unknown", // Use extracted tribe
        challengeWins: challengeWins,
        immunityWins: immunityWins,
        rewardWins: 0, // Not tracked yet
        votesReceived: votesReceived,
        idolsFound: idolsFound,
        strategicRank: strategicRank,
        juryVotes: juryVotes,
        finalVote: placement.placement === 1 ? seasonData.winner.vote : "",
        advantages: [],
        notes: [placement.notes],
        // Add AI-generated narrative data
        gameplayStyle: placement.gameplayStyle || "",
        keyMoments: placement.keyMoments || [],
        alliances: placement.alliances || [],
        rivalries: placement.rivalries || []
      };
      
      player.seasonDetails.push(seasonDetail);
    });
    
    // Remove any duplicate/fake players that slipped through
    db.players = db.players.filter(player => {
      const isFake = bannedIds.some(banned => player.id.includes(banned));
      if (isFake) {
        console.warn(`üóëÔ∏è Removing fake player from database: ${player.id}`);
        return false;
      }
      return true;
    });
    
    savePlayerDatabase(db);
    downloadJSON(db, 'players_database.json');
    
    console.log(`‚úÖ players_database.json updated (${db.players.length} total players)`);
  }
  
  function countVotesAgainst(playerName, votingHistory) {
    let count = 0;
    votingHistory.forEach(ep => {
      ep.votes.forEach(vote => {
        if (vote.target === playerName) {
          count++;
        }
      });
    });
    return count;
  }
  
  function updateRankingsDatabase(seasonData, oldRankingsData = null) {
    const db = loadPlayerDatabase();
    const currentSeason = seasonData.seasonNumber;
    
    // Load existing rankings
    // oldRankingsData can be passed in from the main generation function
    let oldRankings = {};
    
    if (oldRankingsData && oldRankingsData.rankings) {
      // Use passed-in rankings (from project file)
      oldRankingsData.rankings.forEach(r => {
        oldRankings[r.playerId] = r;
      });
      console.log(`üìã Loaded ${Object.keys(oldRankings).length} existing rankings from project file`);
    } else {
      // Fallback: Try localStorage
      try {
        const oldDB = JSON.parse(localStorage.getItem('rankings_database') || '{}');
        if (oldDB.rankings && Array.isArray(oldDB.rankings)) {
          oldDB.rankings.forEach(r => {
            oldRankings[r.playerId] = r;
          });
          console.log(`üìã Loaded ${Object.keys(oldRankings).length} existing rankings from localStorage`);
        } else {
          console.log('‚ÑπÔ∏è No previous rankings - will calculate fresh for everyone');
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Could not load old rankings:', e.message);
        console.log('‚ÑπÔ∏è Will calculate fresh rankings for all players');
      }
    }
    
    // Get list of players who competed in current season
    const currentSeasonPlayers = new Set(
      seasonData.placements.map(p => slugify(p.name))
    );
    
    const rankings = [];
    
    // Filter out duplicate/invalid players
    const validPlayers = db.players.filter(player => {
      const id = player.id.toLowerCase();
      if (id.includes('votes-to-win') || 
          id.includes('juror-voted') ||
          id.includes('finalist-') ||
          id === 'everyone' ||
          id === 'eliminate') {
        console.warn(`Skipping invalid player: ${player.id}`);
        return false;
      }
      return true;
    });
    
    // Process each valid player
    validPlayers.forEach(player => {
      const playedThisSeason = currentSeasonPlayers.has(player.id);
      
      if (playedThisSeason || !oldRankings[player.id]) {
        // RECALCULATE: New players or returnees who played this season
        const score = calculatePlayerScore(player);
        const tier = calculateTier(score);
        
        rankings.push({
          playerId: player.id,
          tier: tier,
          score: score,
          rank: 0, // Will be set after sorting
          title: generatePlayerTitle(player),
          emoji: getPlayerEmoji(player),
          reasoning: generateReasoning(player),
          strengths: generateStrengths(player),
          weaknesses: generateWeaknesses(player),
          avgPlacement: calculateAvgPlacement(player),
          winRate: Math.round((player.wins / player.totalSeasons) * 100),
          seasons: player.seasons,
          placements: player.seasonDetails.map(s => s.placement),
          challengeWins: player.totalChallengeWins,
          votesAgainst: player.totalVotesAgainst,
          juryVotes: player.totalJuryVotes,
          idolsFound: player.totalIdolsFound,
          status: `Competed in ${player.totalSeasons} season(s)`
        });
        
        console.log(`‚úÖ Recalculated: ${player.name} (played S${currentSeason})`);
      } else {
        // PRESERVE: Players who didn't compete this season
        const oldRank = oldRankings[player.id];
        rankings.push({
          ...oldRank,
          rank: 0 // Will be reassigned based on score
        });
        
        console.log(`üìã Preserved: ${player.name} (didn't play S${currentSeason})`);
      }
    });
    
    // Sort by score (descending)
    rankings.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      // Tiebreaker: better avg placement
      return a.avgPlacement - b.avgPlacement;
    });
    
    // Assign new ranks
    rankings.forEach((r, i) => {
      r.rank = i + 1;
    });
    
    // Build rankings database
    const rankingsDB = {
      metadata: {
        name: "DC Franchise Rankings Database",
        version: `${currentSeason}.0`,
        lastUpdated: new Date().toISOString().split('T')[0],
        description: `Complete player rankings after Season ${currentSeason}`,
        totalPlayers: rankings.length,
        source: `Season ${currentSeason} integration`
      },
      scoringSystem: {
        placement: "40% - Average finish position across all seasons (lower placement = higher score)",
        winRate: "20% - Championships won / appearances",
        challengePerformance: "15% - Individual immunity + reward wins (normalized per season)",
        socialGame: "15% - Votes received (lower = better), jury votes earned",
        strategicImpact: "10% - Idol plays, blindsides executed, game control"
      },
      tiers: {
        "S+": { name: "TIER S+ ‚Äì Elite Winners", description: "91+ ‚Ä¢ Franchise legends", scoreRange: [91, 100] },
        "S": { name: "TIER S ‚Äì Championship Caliber", description: "81-90 ‚Ä¢ Top-tier threats", scoreRange: [81, 90] },
        "A": { name: "TIER A ‚Äì Elite Threats", description: "72-80 ‚Ä¢ Deep runs", scoreRange: [72, 80] },
        "B": { name: "TIER B ‚Äì Above Average", description: "61-71 ‚Ä¢ Solid gameplay", scoreRange: [61, 71] },
        "C": { name: "TIER C ‚Äì Average", description: "51-60 ‚Ä¢ Mid-game players", scoreRange: [51, 60] },
        "D": { name: "TIER D ‚Äì Below Average", description: "36-50 ‚Ä¢ Early exits", scoreRange: [36, 50] }
      },
      rankings
    };
    
    localStorage.setItem('rankings_database', JSON.stringify(rankingsDB, null, 2));
    downloadJSON(rankingsDB, 'rankings_database.json');
    
    console.log(`‚úÖ rankings_database.json updated (${rankings.length} valid players)`);
  }
  
  // Helper functions for enhanced rankings
  function getPlayerEmoji(player) {
    if (player.wins >= 2) return "üëë";
    if (player.wins === 1) return "‚≠ê";
    if (player.bestPlacement === 2) return "ü•à";
    if (player.bestPlacement === 3) return "ü•â";
    if (player.totalChallengeWins >= 10) return "üí™";
    return "‚≠ê";
  }
  
  function generateStrengths(player) {
    const strengths = [];
    
    if (player.wins >= 1) strengths.push("Winner pedigree");
    if (player.totalChallengeWins / player.totalSeasons >= 3) strengths.push("Challenge prowess");
    if (player.totalVotesAgainst / player.totalSeasons < 5) strengths.push("Low target profile");
    if (player.totalIdolsFound >= 2) strengths.push("Strategic gameplay");
    if (calculateAvgPlacement(player) <= 3) strengths.push("Consistent deep runs");
    
    return strengths;
  }
  
  function generateWeaknesses(player) {
    const weaknesses = [];
    
    if (player.totalVotesAgainst / player.totalSeasons > 15) weaknesses.push("High threat perception");
    if (player.totalSeasons >= 3 && player.wins === 0) weaknesses.push("Can't close");
    if (player.totalChallengeWins / player.totalSeasons < 1) weaknesses.push("Challenge liability");
    if (player.totalIdolsFound === 0 && player.totalSeasons >= 2) weaknesses.push("Limited strategic tools");
    
    return weaknesses;
  }
  
  // Scoring functions - Proper formula matching rubric
  function calculatePlayerScore(player) {
    if (!player || !player.totalSeasons || player.totalSeasons === 0) {
      return 0;
    }
    
    let score = 0;
    
    // 1. Placement (40%) - Lower average placement = better score
    const avgPlacement = calculateAvgPlacement(player);
    const castSize = 20; // Approximate average cast size
    const placementPercentile = Math.max(0, Math.min(100, ((castSize - avgPlacement) / castSize) * 100));
    score += placementPercentile * 0.4;
    
    // 2. Win Rate (20%) - Wins / Seasons
    const winRate = (player.wins / player.totalSeasons) * 100;
    score += winRate * 0.2;
    
    // 3. Challenge Performance (15%) - Normalized per season
    const challengesPerSeason = player.totalChallengeWins / player.totalSeasons;
    const challengeScore = Math.min(100, challengesPerSeason * 20); // 5 wins/season = 100
    score += challengeScore * 0.15;
    
    // 4. Social Game (15%) - Lower votes against = better, plus jury votes
    const votesPerSeason = player.totalVotesAgainst / player.totalSeasons;
    const votesScore = Math.max(0, 100 - (votesPerSeason * 3)); // 33 votes/season = 0
    const juryScore = Math.min(100, (player.totalJuryVotes / player.totalSeasons) * 10); // 10 jury votes/season = 100
    const socialScore = (votesScore * 0.7) + (juryScore * 0.3);
    score += socialScore * 0.15;
    
    // 5. Strategic Impact (10%) - Idols, advantages
    const idolsPerSeason = player.totalIdolsFound / player.totalSeasons;
    const strategicScore = Math.min(100, idolsPerSeason * 50); // 2 idols/season = 100
    score += strategicScore * 0.1;
    
    // Ensure score is between 0-100
    return Math.round(Math.max(0, Math.min(100, score)));
  }
  
  function calculateTier(score) {
    if (score >= 91) return "S+";
    if (score >= 81) return "S";
    if (score >= 72) return "A";
    if (score >= 61) return "B";
    if (score >= 51) return "C";
    if (score >= 36) return "D";
    return "F";
  }
  
  function calculateAvgPlacement(player) {
    if (!player.seasonDetails || player.seasonDetails.length === 0) return 99;
    const total = player.seasonDetails.reduce((sum, s) => sum + (s.placement || 99), 0);
    return parseFloat((total / player.seasonDetails.length).toFixed(1));
  }
  
  function generatePlayerTitle(player) {
    if (player.wins >= 2) return "The Legend";
    if (player.wins === 1) return "The Champion";
    if (player.bestPlacement === 2) return "The Runner-Up";
    if (player.totalChallengeWins >= 10) return "The Competitor";
    if (player.bestPlacement <= 5) return "The Threat";
    return "The Survivor";
  }
  
  function generateReasoning(player) {
    let text = `Competed in ${player.totalSeasons} season(s). `;
    if (player.wins > 0) {
      text += `Won ${player.wins} time(s). `;
    }
    text += `Best placement: ${player.bestPlacement}. `;
    text += `${player.totalChallengeWins} challenge wins, ${player.totalVotesAgainst} votes against.`;
    return text;
  }
  
  // ========================================
  // VOTING ANALYTICS HTML GENERATION
  // ========================================
  
  function generateVotingAnalyticsHTML(seasonData) {
    const { seasonNumber, castSize, episodeCount, winner, votingHistory, finalTribalCouncil, finalists } = seasonData;
    
    // Generate episode headers
    let episodeHeaders = '';
    let eliminatedHeaders = '';
    
    votingHistory.forEach(ep => {
      episodeHeaders += `<th>Episode ${ep.episode}</th>`;
      eliminatedHeaders += `<th class="eliminated">${ep.eliminated || 'N/A'}</th>`;
    });
    
    // Add finale columns
    finalists.forEach(f => {
      const className = f.placement === 1 ? 'winner-col' : 'finale-col';
      const label = f.placement === 1 ? 'Winner' : `${f.placement === 2 ? '2nd' : '3rd'} Place`;
      episodeHeaders += `<th class="${className}">${f.name}</th>`;
      eliminatedHeaders += `<th class="${className}">${label}</th>`;
    });
    
    // Generate player rows
    let playerRows = '';
    seasonData.placements.forEach(player => {
      const isWinner = player.placement === 1;
      const rowClass = isWinner ? 'winner-row' : '';
      
      let voteColumns = '';
      
      // Vote columns for each episode
      votingHistory.forEach(ep => {
        const playerVote = ep.votes.find(v => v.voter === player.name);
        voteColumns += `<td>${playerVote ? playerVote.target : '‚Äî'}</td>`;
      });
      
      // Finale vote columns
      if (player.placement <= finalists.length) {
        // This player is a finalist - they don't vote
        finalists.forEach(() => {
          voteColumns += `<td>‚Äî</td>`;
        });
      } else {
        // This player is a juror
        finalists.forEach(f => {
          const juryVote = finalTribalCouncil.votes.find(v => v.juror === player.name);
          const didVoteForThisFinalist = juryVote && juryVote.votedFor === f.name;
          voteColumns += `<td>${didVoteForThisFinalist ? f.name : '‚Äî'}</td>`;
        });
      }
      
      playerRows += `
        <tr class="${rowClass}">
          <td class="rank-col">${player.placement}</td>
          <td class="player-name">${player.name}</td>
          ${voteColumns}
        </tr>
      `;
    });
    
    // Generate complete HTML section
    return `
<!-- SEASON ${seasonNumber} -->
<div id="season${seasonNumber}-table" class="voting-table">
  <h2 style="text-align:center; margin: 20px 0;">üìä Season ${seasonNumber} Voting Chart</h2>
  
  <div class="callout">
    ${castSize} players ‚Ä¢ ${episodeCount} episodes + finale ‚Ä¢ Winner: ${winner.name} (${winner.vote} jury vote)
  </div>
  
  <div class="scroll-hint">
    ‚¨ÖÔ∏è SCROLL RIGHT TO SEE ALL EPISODES + FINALE ‚û°Ô∏è
  </div>
  
  <div class="panel">
    <div class="table-wrapper">
      <table class="vote-table">
        <thead>
          <tr>
            <th rowspan="2" class="rank-col">Rank</th>
            <th rowspan="2" class="player-name">Castaway</th>
            ${episodeHeaders}
          </tr>
          <tr>
            ${eliminatedHeaders}
          </tr>
        </thead>
        <tbody>
          ${playerRows}
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Don't forget to add the button to the season toggle:
<button class="season-btn" onclick="showSeason(${seasonNumber})">Season ${seasonNumber}</button>
-->
`;
  }
  
  // ========================================
  // HELPER FUNCTIONS
  // ========================================
  
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  function downloadJSON(data, filename) {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  function downloadText(text, filename) {
    const blob = new Blob([text], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  // ========================================
  // FEATURE 1: CAST ANALYSIS & PROFILE CREATION
  // ========================================

  if (analyzeCastBtn) {
    analyzeCastBtn.addEventListener("click", () => {
      const summary = seasonSetupSummary.value.trim();
      if (!summary) {
        alert("‚ö†Ô∏è Please paste Episode 1 summary first!");
        return;
      }
      
      // Show loading state
      const originalText = analyzeCastBtn.innerHTML;
      analyzeCastBtn.innerHTML = '‚è≥ Analyzing...';
      analyzeCastBtn.disabled = true;
      
      // Hide previous results
      castAnalysisResult.style.display = 'none';
      createProfilesSection.style.display = 'none';
      
      setTimeout(() => {
        try {
          const seasonInput = document.getElementById("aiSeason");
          const season = Number(seasonInput ? seasonInput.value : 1);
          analyzedCastData = analyzeCast(summary, season);
          
          if (analyzedCastData) {
            displayCastAnalysis(analyzedCastData);
            castAnalysisResult.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        } catch (error) {
          console.error('Analysis error:', error);
          alert(`‚ùå Analysis failed: ${error.message}`);
        } finally {
          analyzeCastBtn.innerHTML = originalText;
          analyzeCastBtn.disabled = false;
        }
      }, 100);
    });
  }

  if (createProfilesBtn) {
    createProfilesBtn.addEventListener("click", () => {
      if (!analyzedCastData) {
        alert("‚ö†Ô∏è Please analyze cast first!");
        return;
      }
      
      if (!confirm(`Create/update profiles for ${analyzedCastData.total} players in Season ${analyzedCastData.season}?\n\nThis will:\n‚Ä¢ Create ${analyzedCastData.newPlayers.length} new profiles\n‚Ä¢ Update ${analyzedCastData.returningPlayers.length} returning players`)) {
        return;
      }
      
      createPlayerProfiles(analyzedCastData);
    });
  }

  function analyzeCast(summaryText, season) {
    const cast = parseCastFromSummary(summaryText);
    
    if (cast.length === 0) {
      alert("‚ö†Ô∏è No cast detected! Make sure your summary has:\n\n=== CAST (ALL) ===\nAmy\nBeardo\n...");
      return null;
    }
    
    const db = loadPlayerDatabase();
    const seasonExists = db.players.some(p => 
      p.seasonDetails && p.seasonDetails.some(s => s.season === season)
    );
    
    if (seasonExists) {
      alert(`‚ö†Ô∏è Season ${season} already has player data!\n\nProfiles were already created.`);
      return null;
    }
    
    const newPlayers = [];
    const returningPlayers = [];
    
    for (const name of cast) {
      const id = slugify(name);
      const existing = db.players.find(p => p.id === id);
      
      if (existing) {
        returningPlayers.push({
          name: name,
          id: id,
          previousSeasons: existing.seasons,
          bestPlacement: existing.bestPlacement,
          wins: existing.wins
        });
      } else {
        newPlayers.push({ name: name, id: id });
      }
    }
    
    let seasonType;
    if (newPlayers.length === cast.length) {
      seasonType = "All Newbies";
    } else if (returningPlayers.length === cast.length) {
      seasonType = "All-Stars";
    } else {
      seasonType = `Mixed (${returningPlayers.length} returnees, ${newPlayers.length} newbies)`;
    }
    
    return {
      season,
      total: cast.length,
      newPlayers,
      returningPlayers,
      seasonType,
      castNames: cast
    };
  }

  function displayCastAnalysis(data) {
    if (!data) return;
    
    let html = `
      <div style="padding: 12px; background: linear-gradient(135deg, rgba(76,255,179,0.2), rgba(76,255,179,0.1)); border: 2px solid #4cffb3; border-radius: 12px; margin-bottom: 16px;">
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 24px;">‚úÖ</span>
          <div>
            <div style="font-weight: 700; color: #4cffb3;">Analysis Complete!</div>
            <div style="font-size: 13px; opacity: 0.9;">Found ${data.total} players for Season ${data.season}</div>
          </div>
        </div>
      </div>
      
      <h4 style="margin-top: 0; color: var(--accent);">Season ${data.season} - Cast Analysis</h4>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px;">
        <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
          <div style="font-size: 24px; font-weight: 700;">${data.total}</div>
          <div style="opacity: 0.7; font-size: 13px;">Total Cast</div>
        </div>
        <div style="padding: 12px; background: rgba(76,255,179,0.15); border-radius: 8px;">
          <div style="font-size: 24px; font-weight: 700; color: #4cffb3;">‚ú® ${data.newPlayers.length}</div>
          <div style="opacity: 0.7; font-size: 13px;">New Players</div>
        </div>
        <div style="padding: 12px; background: rgba(255,179,71,0.15); border-radius: 8px;">
          <div style="font-size: 24px; font-weight: 700; color: #ffb347;">üîÑ ${data.returningPlayers.length}</div>
          <div style="opacity: 0.7; font-size: 13px;">Returning Players</div>
        </div>
      </div>
      <div style="padding: 12px; background: rgba(125,76,255,0.15); border-radius: 8px; margin-bottom: 16px;">
        <strong>Season Type:</strong> ${data.seasonType}
      </div>
    `;
    
    if (data.returningPlayers.length > 0) {
      html += `<details style="margin-top: 12px;">
        <summary style="cursor: pointer; font-weight: 600; margin-bottom: 8px;">üîÑ Returning Players (${data.returningPlayers.length})</summary>
        <div style="display: grid; gap: 6px; margin-top: 8px; font-size: 13px;">`;
      
      for (const p of data.returningPlayers) {
        const trophy = p.wins > 0 ? " üèÜ".repeat(p.wins) : "";
        html += `<div style="padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
          <strong>${p.name}</strong>${trophy} - Seasons: ${p.previousSeasons.join(", ")} | Best: ${p.bestPlacement}${p.bestPlacement === 1 ? "st" : p.bestPlacement === 2 ? "nd" : p.bestPlacement === 3 ? "rd" : "th"}
        </div>`;
      }
      html += `</div></details>`;
    }
    
    if (data.newPlayers.length > 0) {
      html += `<details style="margin-top: 12px;" open>
        <summary style="cursor: pointer; font-weight: 600; margin-bottom: 8px;">‚ú® New Players (${data.newPlayers.length})</summary>
        <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; font-size: 13px;">`;
      
      for (const p of data.newPlayers) {
        html += `<span style="padding: 4px 10px; background: rgba(76,255,179,0.2); border-radius: 6px;">${p.name}</span>`;
      }
      html += `</div></details>`;
    }
    
    castAnalysisResult.innerHTML = html;
    castAnalysisResult.style.display = "block";
    createProfilesSection.style.display = "block";
  }

  function createPlayerProfiles(data) {
    const db = loadPlayerDatabase();
    const season = data.season;
    
    const originalText = createProfilesBtn.innerHTML;
    createProfilesBtn.innerHTML = '‚è≥ Creating profiles...';
    createProfilesBtn.disabled = true;
    
    setTimeout(() => {
      try {
        for (const name of data.castNames) {
          const id = slugify(name);
          let player = db.players.find(p => p.id === id);
          
          if (!player) {
            player = {
              id,
              name,
              seasons: [season],
              totalSeasons: 1,
              bestPlacement: 99,
              wins: 0,
              totalChallengeWins: 0,
              totalImmunityWins: 0,
              totalRewardWins: 0,
              totalVotesAgainst: 0,
              totalIdolsFound: 0,
              totalJuryVotes: 0,
              tier: "Unranked",
              badges: [],
              seasonDetails: []
            };
            db.players.push(player);
          }
          
          if (!player.seasons.includes(season)) {
            player.seasons.push(season);
            player.totalSeasons++;
          }
          
          const existingDetail = player.seasonDetails.find(s => s.season === season);
          if (!existingDetail) {
            player.seasonDetails.push({
              season,
              placement: 99,
              status: "Active",
              tribe: "TBD",
              challengeWins: 0,
              immunityWins: 0,
              rewardWins: 0,
              votesReceived: 0,
              idolsFound: 0,
              strategicRank: 0,
              juryVotes: 0,
              finalVote: "",
              unbreakableBonds: [],
              rivalries: [],
              allianceHistory: []
            });
          }
        }
        
        savePlayerDatabase(db);
        
        castAnalysisResult.innerHTML = `
          <div style="padding: 20px; background: linear-gradient(135deg, rgba(76,255,179,0.2), rgba(76,255,179,0.1)); border: 2px solid #4cffb3; border-radius: 16px; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 12px;">üéâ</div>
            <h3 style="margin: 0 0 8px; color: #4cffb3;">Profiles Created!</h3>
            <div style="font-size: 15px; opacity: 0.9; margin-bottom: 16px;">
              Season ${season} is ready to track
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 400px; margin: 0 auto;">
              <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                <div style="font-size: 24px; font-weight: 700; color: #4cffb3;">${data.newPlayers.length}</div>
                <div style="font-size: 12px; opacity: 0.8;">New Profiles</div>
              </div>
              <div style="padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                <div style="font-size: 24px; font-weight: 700; color: #ffb347;">${data.returningPlayers.length}</div>
                <div style="font-size: 12px; opacity: 0.8;">Updated</div>
              </div>
            </div>
            <div style="margin-top: 16px; font-size: 13px; opacity: 0.7;">
              üíæ Saved to localStorage as "players_database"
            </div>
          </div>
        `;
        
        createProfilesSection.innerHTML = `
          <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-top: 20px;">
            <button onclick="location.reload()" class="btn btn-primary">
              ‚ú® Create Another Season
            </button>
            <button onclick="document.getElementById('tabOverview').click()" class="btn">
              üìä Go to Analytics
            </button>
          </div>
        `;
        
        seasonSetupSummary.value = "";
        analyzedCastData = null;
        castAnalysisResult.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
      } catch (error) {
        console.error('Profile creation error:', error);
        alert(`‚ùå Error creating profiles: ${error.message}`);
      } finally {
        createProfilesBtn.innerHTML = originalText;
        createProfilesBtn.disabled = false;
      }
    }, 300);
  }

  // ========================================
  // FEATURE 2: AUTO-UPDATE ELIMINATIONS (GLOBAL)
  // ========================================
  
  window.updatePlayerEliminationsFromEpisode = function(season, episode, cast, eliminated) {
    const db = loadPlayerDatabase();
    let updated = 0;
    
    const activeCount = cast.length;
    const eliminatedArray = Array.from(eliminated);
    const eliminatedCount = eliminatedArray.length;
    const remainingCount = activeCount - eliminatedCount;
    
    for (const eliminatedName of eliminatedArray) {
      const player = db.players.find(p => 
        p.name.toLowerCase() === eliminatedName.toLowerCase()
      );
      
      if (player) {
        const seasonDetail = player.seasonDetails.find(s => s.season === season);
        if (seasonDetail && seasonDetail.status === "Active") {
          const placement = remainingCount + 1;
          seasonDetail.placement = placement;
          seasonDetail.status = "Eliminated";
          
          if (placement < player.bestPlacement) {
            player.bestPlacement = placement;
          }
          
          updated++;
          console.log(`‚úÖ Updated ${player.name}: ${placement}${placement === 1 ? 'st' : placement === 2 ? 'nd' : placement === 3 ? 'rd' : 'th'} place`);
        }
      }
    }
    
    if (updated > 0) {
      savePlayerDatabase(db);
      console.log(`üìä Auto-updated ${updated} elimination(s) for Season ${season} Episode ${episode}`);
    }
  };

  // ========================================
  // FEATURE 3: EXPORT/IMPORT/SYNC DATABASE
  // ========================================

  if (exportDatabaseBtn) {
    exportDatabaseBtn.addEventListener("click", () => {
      const db = loadPlayerDatabase();
      
      const json = JSON.stringify(db, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `players_database_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showDatabaseStatus(`‚úÖ Database exported! (${db.players.length} players, ${db.franchise.totalSeasons} seasons)`);
    });
  }

  if (importDatabaseBtn) {
    importDatabaseBtn.addEventListener("click", () => {
      importFileInput.click();
    });
  }

  if (importFileInput) {
    importFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const db = JSON.parse(event.target.result);
          
          if (!db.franchise || !Array.isArray(db.players)) {
            throw new Error("Invalid database structure");
          }
          
          if (!confirm(`Import database with ${db.players.length} players and ${db.franchise.totalSeasons} seasons?\n\nThis will REPLACE your current database!`)) {
            return;
          }
          
          localStorage.setItem('players_database', JSON.stringify(db, null, 2));
          showDatabaseStatus(`‚úÖ Database imported! (${db.players.length} players, ${db.franchise.totalSeasons} seasons)`);
          
        } catch (error) {
          alert(`‚ùå Import failed: ${error.message}`);
        }
        
        importFileInput.value = '';
      };
      
      reader.readAsText(file);
    });
  }

  if (syncDevoteesBtn) {
    syncDevoteesBtn.addEventListener("click", () => {
      const db = loadPlayerDatabase();
      
      if (db.players.length === 0) {
        alert("‚ö†Ô∏è No players in database. Create profiles first!");
        return;
      }
      
      const json = JSON.stringify(db, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        showDatabaseStatus(`‚úÖ Database copied to clipboard!\n\nNow:\n1. Open devotees.html\n2. Paste into localStorage or JSON file`);
      }).catch(() => {
        alert(`‚úÖ Copy this JSON:\n\n${json.substring(0, 200)}...\n\n(See console for full output)`);
        console.log('Database JSON:', json);
      });
    });
    
    // Rebuild Rankings Button
    if (rebuildRankingsBtn) {
      rebuildRankingsBtn.addEventListener("click", async () => {
        if (!confirm("‚ö†Ô∏è Rebuild ALL Rankings?\n\nThis will recalculate scores for ALL players using percentile-based relative scoring.\n\nUse this ONCE to establish new baseline rankings.\n\nContinue?")) {
          return;
        }
        
        rebuildRankingsBtn.disabled = true;
        rebuildRankingsBtn.textContent = "‚è≥ Rebuilding...";
        
        try {
          const db = loadPlayerDatabase();
          
          if (db.players.length === 0) {
            alert("‚ö†Ô∏è No players in database!");
            return;
          }
          
          // Get worker URL
          const workerUrl = getWorkerUrl();
          if (!workerUrl) {
            alert("‚ö†Ô∏è Please set AI Worker URL in Settings first!");
            return;
          }
          
          console.log("üîÑ Rebuilding rankings for all players...");
          
          // Load ranking overrides (if available)
          let overrides = null;
          try {
            const overridesResp = await fetch('ranking-overrides.json');
            if (overridesResp.ok) {
              overrides = await overridesResp.json();
              console.log(`‚úì Loaded ${Object.keys(overrides.overrides || {}).length} ranking overrides`);
            }
          } catch (e) {
            console.log('‚ÑπÔ∏è No ranking overrides found, using AI scores only');
          }
          
          const response = await fetch(workerUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              mode: "rankings-rebuild",
              playersDB: db,
              currentSeason: db.franchise?.totalSeasons || 6,
              overrides: overrides  // ‚Üê Pass overrides here
            })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Worker failed (${response.status}): ${errorText}`);
          }
          
          const rankingsDB = await response.json();
          
          if (rankingsDB.error) {
            throw new Error(rankingsDB.error);
          }
          
          // Save to localStorage and download
          localStorage.setItem('rankings_database', JSON.stringify(rankingsDB, null, 2));
          downloadJSON(rankingsDB, 'rankings_database.json');
          
          showDatabaseStatus(`‚úÖ Rankings rebuilt!\n\n${rankingsDB.rankings.length} players ranked with percentile-based scoring.\n\nDownloaded: rankings_database.json`);
          
          console.log("‚úÖ Rankings rebuilt:", rankingsDB);
          
        } catch (error) {
          console.error("Rebuild error:", error);
          alert(`‚ùå Rebuild failed:\n\n${error.message}`);
        } finally {
          rebuildRankingsBtn.disabled = false;
          rebuildRankingsBtn.textContent = "üîÑ Rebuild All Rankings";
        }
      });
    }
  }

  function showDatabaseStatus(message) {
    if (databaseStatus) {
      databaseStatus.textContent = message;
      databaseStatus.style.display = 'block';
      setTimeout(() => {
        databaseStatus.style.display = 'none';
      }, 5000);
    }
  }

  // ========================================
  // DATABASE HELPERS
  // ========================================

  function loadPlayerDatabase() {
    try {
      const raw = localStorage.getItem("players_database");
      if (raw) return JSON.parse(raw);
    } catch (e) {
      console.error("Error loading player database:", e);
    }
    
    return {
      franchise: {
        name: "DC Franchise Database",
        totalSeasons: 0,
        totalPlayers: 0,
        description: "Total Drama franchise player statistics and performance data"
      },
      players: []
    };
  }

  function savePlayerDatabase(db) {
    try {
      db.franchise.totalPlayers = db.players.length;
      const allSeasons = new Set();
      db.players.forEach(p => p.seasons.forEach(s => allSeasons.add(s)));
      db.franchise.totalSeasons = allSeasons.size;
      
      localStorage.setItem("players_database", JSON.stringify(db, null, 2));
      console.log(`‚úÖ Database saved: ${db.franchise.totalPlayers} players, ${db.franchise.totalSeasons} seasons`);
    } catch (e) {
      console.error("Error saving player database:", e);
      alert("‚ö†Ô∏è Error saving database. Check console.");
    }
  }
  
})();
}, 500); // Wait 500ms for DOM to fully render and database to load
</script>
</div><footer class="siteFooter">
  <div class="footerInner">
    <div class="footerTitle">DC Franchise Database</div>
    <div class="footerSub">Static archive ‚Ä¢ 5 seasons ‚Ä¢ 58 players ‚Ä¢ Icons: name.png</div>
  </div>
</footer>
<!-- SITE FOOTER END -->
</body>
</html>
